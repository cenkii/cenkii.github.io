<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Q.Chen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cenkii.github.io/"/>
  <updated>2021-05-08T03:21:54.151Z</updated>
  <id>https://cenkii.github.io/</id>
  
  <author>
    <name>陈琪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker</title>
    <link href="https://cenkii.github.io/2021/05/04/docker/"/>
    <id>https://cenkii.github.io/2021/05/04/docker/</id>
    <published>2021-05-04T14:00:39.000Z</published>
    <updated>2021-05-08T03:21:54.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker出现背景"><a href="#docker出现背景" class="headerlink" title="docker出现背景"></a>docker出现背景</h2><p>实际生产过程中经常出现，代码在开发环境中可以跑通，但在运维环境中会出问题。docker技术通过将代码数据配置系统等进行整体打包，来解决经常出现的配置环境不兼容问题。他的理念是“一次封装，处处运行。”</p><h2 id="虚拟机与虚拟化技术"><a href="#虚拟机与虚拟化技术" class="headerlink" title="虚拟机与虚拟化技术"></a>虚拟机与虚拟化技术</h2><p>虚拟机是一种带环境安装的解决方案，它可以在一个系统中运行另一个系统（通过程序同时模拟硬件和软件）。虽然，虚拟机中的操作系统看上去和真实系统一样，但底层操作系统对他的感知只是一个文件不用可以立即删除，对它毫无影响。</p><p>它的缺点：</p><p>资源占用多    冗余步骤多    启动慢</p><p>虚拟化技术</p><p>Linux发展出另一种虚拟化技术，Linux容器（Linux Containers 缩写 LXC）</p><p>与上面相比，他不在模拟整个系统它只需要软件运行所需的资源和设置。</p><p>虚拟机更多面向硬件，docker面向软件层面。前者为分钟级，后者为秒级。</p><h2 id="三大要素"><a href="#三大要素" class="headerlink" title="三大要素"></a>三大要素</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像是用于创建 Docker 容器的模板，</p><p>他是轻量级的可执行安装文件包含必要的依赖环境等。</p><h4 id="加载原理"><a href="#加载原理" class="headerlink" title="加载原理"></a>加载原理</h4><p>由一层一层的文件系统组成（UnionFS）</p><p>bootfs包含：bootloader 和 kernel，bootloader 引导kernel，加载完成之后bootloader 将掌控权转交给kernel。</p><p>rootfs：是基于bootfs的文件系统是Linux的发行版（centos和ubantu等），包含/bin,/dev等标准目录</p><p>不同发行版本的rootfs 有差别但bootfs是一样的，因此docker可以和其他发行版共用bootfs，它自己只需要提供基本的rootfs就行了</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是独立运行的一个或一组应用，是镜像运行时的实体。</p><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><h4 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h4><p>用于容器的数据共享</p><p>docker run -it -v /宿主机绝对路径:/容器内目录  镜像名</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>集中存放镜像的地方</p><p>安装流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y epel-release</span><br><span class="line">[root@localhost ~]# yum install -y docker-io</span><br></pre></td></tr></table></figure><p>启动docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">centos6</span><br><span class="line">service docker start</span><br><span class="line">centos7</span><br><span class="line">systemctl start docker(也可以使用上面的指令，会重定向到这个指令)</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#列出本地镜像</span><br><span class="line">docker images [选项]</span><br><span class="line">#选项 -a：所有(包含中间层)  -q：只显示id  -digest：只显示摘要  -no-trunc：显示所有完整信息</span><br><span class="line"></span><br><span class="line">#从搜索docker hub上搜索</span><br><span class="line">docker search [选项] 名字</span><br><span class="line">#-s：限制<span class="built_in">start</span>数 -s <span class="number">30</span> 只显示<span class="number">30</span>以上的 -no-trunc：显示所有完整信息 </span><br><span class="line"></span><br><span class="line">#下载</span><br><span class="line">docker pull 名称</span><br><span class="line">#默认拉取最新版等价于</span><br><span class="line">docker pull 名称:latest</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">docker rmi 名称</span><br><span class="line">#删除多个</span><br><span class="line">docker rmi 名称 名称二</span><br><span class="line">#全删除</span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#新建并启动</span><br><span class="line">docker run image </span><br><span class="line">-d：守护式进程  </span><br><span class="line">-it：交互式进程</span><br><span class="line"></span><br><span class="line"># 启动容器</span><br><span class="line">docker <span class="built_in">start</span> 容器id</span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">docker stop 容器id</span><br><span class="line">#强制停止</span><br><span class="line">docker kill 容器id</span><br><span class="line"></span><br><span class="line">#重启</span><br><span class="line">docker restart 容器id</span><br><span class="line"></span><br><span class="line">#显示所有运行容器</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line">#退出容器</span><br><span class="line"><span class="keyword">exit</span> 退出并停止</span><br><span class="line">ctrl + p + q 退出不停止</span><br><span class="line"></span><br><span class="line">退出后在进入</span><br><span class="line">docker attach 容器id</span><br><span class="line">在外面操作容器内</span><br><span class="line">docker exec -it 容器id</span><br><span class="line"></span><br><span class="line">#显示日志</span><br><span class="line">docker log 容器id</span><br><span class="line"></span><br><span class="line">#查看容器内进程</span><br><span class="line">docker top 容器id</span><br><span class="line"></span><br><span class="line">#查看容器内细节</span><br><span class="line">docker inspect 容器id</span><br><span class="line"></span><br><span class="line">#拷贝容器里的信息</span><br><span class="line">docker cp 容器id:路径 目标路径</span><br><span class="line"></span><br><span class="line">#将自己的镜像提交</span><br><span class="line">docker commit</span><br></pre></td></tr></table></figure><h2 id="Docker-Dockerfile"><a href="#Docker-Dockerfile" class="headerlink" title="Docker Dockerfile"></a>Docker Dockerfile</h2><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><h4 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h4><p>FROM：定制的镜像都是基于 FROM 的镜像。<br>RUN：用于执行后面跟着的命令行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;] #指定容器数据卷</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><h4 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /mydocker/DockerFile -t cc/centos</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run...</span><br></pre></td></tr></table></figure><h4 id="volumes-from"><a href="#volumes-from" class="headerlink" title="volumes-from"></a>volumes-from</h4><p>实现数据共享，将dc2和dc1连通dc2可以获取到dc1中”/dataVolumeContainer1”,”/dataVolumeContainer2”的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dc2 --volumes-from dc1 cc/centos</span><br></pre></td></tr></table></figure><h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><p>FROM：基础镜像，创建的镜像基于哪个镜像。</p><p>MATINTAINER:：镜像维护者姓名邮箱</p><p>RUN：容器用于执行的命令。</p><p>EXOPSE：对外暴露端口</p><p>WORKDIR：指定工作目录路径。</p><p>ENV：设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>ADD：类似COPY，拷贝加解压缩</p><p>COPY：复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>VOLUME：定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>CMD：类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><p>​        CMD 在docker run 时运行。</p><p>​        RUN 是在 docker build。</p><p>ENTRYPOINT：类似CMD</p><p>​        CMD 会覆盖，只有最后一个生效</p><p>​        ENTRYPOINT 不会覆盖，会追加</p><p>ONBUILD：父镜像被继承后运用</p><p><a href="https://www.runoob.com/docker/docker-dockerfile.html">详细查看</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;docker出现背景&quot;&gt;&lt;a href=&quot;#docker出现背景&quot; class=&quot;headerlink&quot; title=&quot;docker出现背景&quot;&gt;&lt;/a&gt;docker出现背景&lt;/h2&gt;&lt;p&gt;实际生产过程中经常出现，代码在开发环境中可以跑通，但在运维环境中会出问题。d
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://cenkii.github.io/2021/04/30/Linux-0/"/>
    <id>https://cenkii.github.io/2021/04/30/Linux-0/</id>
    <published>2021-04-30T07:58:30.000Z</published>
    <updated>2021-05-10T02:08:51.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、VMware网络"><a href="#1、VMware网络" class="headerlink" title="1、VMware网络"></a>1、VMware网络</h2><p>1、桥连接</p><p>与主机在同一网段，Linxu可以和其他的系统通信，但是可能造成ip冲突</p><p>2、NAT</p><p>网络地址转换，Linux可以访问外网，不会造成冲突</p><p>3、、主机模式</p><p>独立主机不能访问外网</p><h2 id="2、Linux中的目录"><a href="#2、Linux中的目录" class="headerlink" title="2、Linux中的目录"></a>2、Linux中的目录</h2><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210430194522916.png" alt="image-20210430194522916"></p><p>bin：常用指令命令</p><p>sbin：高权限用户命令，管理员使用的命令</p><p>home：普通用户对应文件，即主目录，目录名是以用户名命名的</p><p>root：系统管理员对应的主目录</p><p>etc：存放所有系统管理所需的配置文件</p><p>usr/local：用户安装的文件，应用程序</p><p>boot：启动Linux时使用的一些核心文件，包括链接文件以及镜像文件</p><p>media：识别dvd，U盘</p><p>mnt：让用户临时挂载别的文件系统，外部存储挂在在这个文件夹下</p><p>var：变量日志</p><p>======================================================================</p><p>opt：一般存放安装软件程序</p><p>tmp：临时文件</p><p>dev：将硬件设备映射为文件管理</p><p>lib：，lib64：库文件，动态连接共享库</p><p>=========================大佬文件别轻易动================================</p><p>proc：内核文件，系统内存的映射访问他来获取系统信息</p><p>sys：系统2.6之后出现出现的文件系统</p><p>srv：存放了一些服务启动需要提取的数据</p><p>=======================================================================</p><p>1）Linux一切皆文件</p><p>2）只有一个根目录</p><p>3）文件要放到对应位置</p><h2 id="3、vi和vim编辑器"><a href="#3、vi和vim编辑器" class="headerlink" title="3、vi和vim编辑器"></a>3、vi和vim编辑器</h2><p>vi是Linux内置的编辑器，vim是它的增强版</p><h3 id="3-1-常见模式"><a href="#3-1-常见模式" class="headerlink" title="3.1 常见模式"></a>3.1 常见模式</h3><h4 id="1-正常模式"><a href="#1-正常模式" class="headerlink" title="1.正常模式"></a>1.正常模式</h4><p>打开文件进入的模式（默认模式），可以使用上下移动光标也可以使用快捷键来编辑内容。</p><h4 id="2-插入模式"><a href="#2-插入模式" class="headerlink" title="2.插入模式"></a>2.插入模式</h4><p>可以输入任意内容</p><p>按下i，o，a，r即可进入，一般输入i</p><h4 id="3-命令行模式"><a href="#3-命令行模式" class="headerlink" title="3.命令行模式"></a>3.命令行模式</h4><p>按下：建进入</p><p>可以提供相关的命令，完成读取存盘替换离开等操作。</p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>1、拷贝当前行yy，拷贝向下2行 2yy    粘贴p </p><p>2、删除当前行dd，同理2dd</p><p>3、设置行号命令行界面 :set nu ，取消 set nonu</p><p>4、查找 命令行界面 \查找内容</p><p>5、回到顶部gg 回到底部G</p><p>6、撤销正常模式u</p><p>7、快速定位正常模式 行数 shift+g</p><h2 id="4、常用指令"><a href="#4、常用指令" class="headerlink" title="4、常用指令"></a>4、常用指令</h2><h3 id="4-1-关机重启"><a href="#4-1-关机重启" class="headerlink" title="4.1 关机重启"></a>4.1 关机重启</h3><p>shutdown</p><ul><li>shutdown -h now 立即关机</li><li>shutdown -h 1      一分钟后关机</li><li>shutdown -r now   立即重启</li></ul><p>halt</p><ul><li>直接使用，关机</li></ul><p>reboot</p><ul><li>直接使用，重启</li></ul><p>sync</p><ul><li>把数据同步到磁盘</li></ul><h3 id="4-2-登陆与注销"><a href="#4-2-登陆与注销" class="headerlink" title="4.2 登陆与注销"></a>4.2 登陆与注销</h3><p>logout 用户注销</p><h2 id="5、用户管理"><a href="#5、用户管理" class="headerlink" title="5、用户管理"></a>5、用户管理</h2><p>1）每个用户必须要属于一个组，不指定会默认创建</p><p>2）每个用户对应一个home，登录系统时会默认进入到用户所属的home文件</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>useradd[选项] 用户名</p><p>（useradd -d 路径 用户名 ）可指定路径创建文件</p><p>passwd 用户名设置密码</p><p>指定组</p><p>useradd  -g  groupname  username</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>userdel 用户名（保留home目录）</p><p>userdel -r 用户名 （同时删除用户及home目录）</p><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><p>id 用户名</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>su - 用户名</p><p>高级到低级不需要输密码</p><p>低级到高级输密码</p><p>返回到原用户exit</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h4 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h4><p>groupadd 组名</p><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><p>groupdel 组名</p><h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><p>usermod -g  groupname  username</p><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>/etc/passd  用户信息</p><p>存储格式：用户名：密码（加密x具体在shadow中）：用户id：组id :: home目录 ：shell</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210430224956205.png" alt="image-20210430224956205"></p><p>/etc/group  用户组的信息</p><p>用户名：口令：组id：组成员用户列表</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210430225545758.png" alt="image-20210430225545758"></p><p>/etc/shadow  口令配置文件（密码）</p><p>格式如下：密码是加密的</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210430225244777.png" alt="image-20210430225244777"></p><p>6、实用指令</p><p>Linux系统运行级别：</p><p>0：关机</p><p>1：单用户（找回丢失密码，单用户模式root不需要密码即可登录）</p><p>2：多用户无网络</p><p>3：多用户有网络</p><p>4：保留级别</p><p>5：图形界面</p><p>6：重启</p><p>运行级别配置文件位置/ect/inittab</p><p>切换到指定级别</p><p>init[0,1,2..6]</p><p>centOS7已经不用这个指令了</p><blockquote><p>inittab is no longer used when using systemd.</p><p>ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</p><p>Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target</p><p>systemd uses ‘targets’ instead of runlevels. By default, there are two main targets:</p><p>multi-user.target: analogous to runlevel 3</p><p>graphical.target: analogous to runlevel 5</p><p>To view current default target, run:</p><p>systemctl get-default</p><p>To set a default target, run:</p><p>systemctl set-default TARGET.target</p><p>0：关机                    shutdown.target  halt.target</p><p>1：单用户                emergency.target</p><p>2：多用户无网络    rescure.target</p><p>3：多用户有网络    multi-user.target</p><p>4：保留级别            无</p><p>5：图形界面            graphical.target</p><p>6：重启                    reboot.target</p><p>记不住可以直接使用以下方式切换</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501120914470.png" alt="image-20210501120914470"></p></blockquote><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501114009606.png" alt="image-20210501114009606"></p><h2 id="6、操作指令"><a href="#6、操作指令" class="headerlink" title="6、操作指令"></a>6、操作指令</h2><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>man 命令或配置</p><p>help 命令</p><h3 id="文件目录类指令"><a href="#文件目录类指令" class="headerlink" title="文件目录类指令"></a>文件目录类指令</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>pwd（print work directory）显示当前目录绝对路径</p><h4 id="ls-list-files-指令"><a href="#ls-list-files-指令" class="headerlink" title="ls ( list files ) 指令"></a>ls ( list files ) 指令</h4><ul><li>ls [选项] [目录或文件]</li><li>ls -l 显示详细信息  包括权限所有者</li><li>ls -al 显示所有文件包括隐藏文件</li></ul><blockquote><p>自己补充：ll 等同于 ls -l</p></blockquote><h4 id="cd-（change-dir）指令"><a href="#cd-（change-dir）指令" class="headerlink" title="cd （change dir）指令"></a>cd （change dir）指令</h4><ul><li>cd 切换目录</li><li>cd ~ 回到家目录</li><li>cd .. 返回上一级</li></ul><blockquote><p>自己补充：一般以 / 开头为根目录 应使用绝对路径 </p><p>   ​                    否则为当前目录 使用相对路径</p></blockquote><h4 id="mkdir创建目录"><a href="#mkdir创建目录" class="headerlink" title="mkdir创建目录"></a>mkdir创建目录</h4><ul><li>mkdir 路径</li><li>mkdir -p 路径    （创建多级文件）</li></ul><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501192223602.png" alt="image-20210501192223602"></p><h4 id="rmdir移除目录"><a href="#rmdir移除目录" class="headerlink" title="rmdir移除目录"></a>rmdir移除目录</h4><ul><li>rmdir 路径     （不能删除非空目录）</li><li>rm -rf  路径    （删除路径下所有文件）</li></ul><h4 id="touch创建空文件"><a href="#touch创建空文件" class="headerlink" title="touch创建空文件"></a>touch创建空文件</h4><ul><li>touch 文件名 文件名     （可多个）</li></ul><h4 id="cp拷贝指令"><a href="#cp拷贝指令" class="headerlink" title="cp拷贝指令"></a>cp拷贝指令</h4><ul><li>cp [选项] source dest</li><li>cp -r source dest  （将source文件夹中所有文件拷贝到dest）</li></ul><blockquote><p>如果目标文件夹不存在会自己创建仅限一级目录</p></blockquote><h4 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h4><ul><li>rm -rf 文件路径    （递归强制删除）</li><li>-r 递归</li><li>-f 强制</li></ul><blockquote><p>rm -rf /     rm -rf /*</p></blockquote><h4 id="mv移动重命名"><a href="#mv移动重命名" class="headerlink" title="mv移动重命名"></a>mv移动重命名</h4><ul><li>mv 原名 新名</li><li>mv 文件名 路径</li></ul><h4 id="cat查看文件"><a href="#cat查看文件" class="headerlink" title="cat查看文件"></a>cat查看文件</h4><ul><li>只读形式查看</li><li>cat -n /etc/profile | more  以显示行号的方式打开文件显示一页读取</li></ul><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><ul><li><p>more 文件</p></li><li><p>空格 翻一页</p></li><li><p>回车 翻一行</p></li><li><p>q 退出</p></li><li><p>= 显示行号</p></li><li><p>ctrl + b 反回上一页</p></li><li><p>ctrl + f 翻下一页</p></li><li><p>:f输出文件名和行号</p></li></ul><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><ul><li><p>less 文件</p></li><li><p>只显示部分文件一页一页读取，读取大文件可用此命令</p></li></ul><h4 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和 &gt;&gt;指令"></a><em>&gt;</em>指令和 &gt;&gt;指令</h4><ul><li><em>&gt;</em>指令覆盖写入</li><li><em>&gt;&gt;</em> 追加写入</li></ul><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501204443748.png" alt="image-20210501204443748"></p><ul><li>cat 文件1 &gt; 文件2</li><li>echo “hello world!” &gt; 文件 </li></ul><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><ul><li>输出内容到控制台</li><li>echo $PATH    输出环境变量</li></ul><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501205250666.png" alt="image-20210501205250666"></p><h4 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h4><ul><li>head显示前几行tail显示后几行</li><li>head 文件名   （显示前10行）</li><li>head  -n   5  文件名  （显示文件前5行的内容）</li><li>tail 文件名  （显示后10行）</li><li>tail -n  5  文件名   （显示文件后5行）</li><li>tail -f （实时追踪文档所有更新）</li></ul><h4 id="ln软链接"><a href="#ln软链接" class="headerlink" title="ln软链接"></a>ln软链接</h4><ul><li>ln  -s   源目录文件   软连接文件    （创建）</li><li>rm -rf 软连接  （删除）</li></ul><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><ul><li>查看历史使用过的指令</li><li>history 10 （显示10条）</li><li>! 数字   （执行指定条指令）</li></ul><h3 id="时间日期类指令"><a href="#时间日期类指令" class="headerlink" title="时间日期类指令"></a>时间日期类指令</h3><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>date 显示日期</p><p>date +%Y  显示年</p><p>date “+%Y %m %d” 显示年月日以空格分隔</p><p>date “+%Y %m %d %H %M %S” 显示年月日以空格分隔</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501211458790.png" alt="image-20210501211458790"></p><p>设置日期</p><p>date -s “1970-1-1 0:0:0”</p><h4 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h4><p>显示日历</p><p>cal 年份     （显示一年）</p><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find [范围] [选项]</p><p>-name</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501212156284.png" alt="image-20210501212156284"></p><p>-user</p><p>-size   （大于+ 小于-  等于无符号）</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501212349399.png" alt="image-20210501212349399"></p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>快速定位</p><p>首先需要创建数据库</p><p>updatedb</p><p>locate  文件名</p><h4 id="I管道符号"><a href="#I管道符号" class="headerlink" title="I管道符号"></a>I管道符号</h4><p>作用将前面的结果交给后面的命令去处理</p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep [选项]  内容  源文件</p><p>选项 </p><p>-n 行号</p><p>-i 忽略大小写</p><h3 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h3><h4 id="gzip和gunzip"><a href="#gzip和gunzip" class="headerlink" title="gzip和gunzip"></a>gzip和gunzip</h4><p>gzip压缩完之后不会保留原文件</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501221700021.png" alt="image-20210501221700021"></p><h4 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h4><p>zip打包后会保留源文件</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501222032645.png" alt="image-20210501222032645"></p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501222244189.png" alt="image-20210501222244189"></p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>打包指令 指定文件加目录打包所有文件</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501222701105.png" alt="image-20210501222701105"></p><p>解压 （-C  路径）解压到指定目录</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501223008873.png" alt="image-20210501223008873"></p><p>选项</p><p>-c 产生tar打包文件</p><p>-x 解压tar文件</p><p>-f指定名称</p><p>-z打包同时压缩</p><p>-v显示详细信息</p><h2 id="7、组管理权限管理"><a href="#7、组管理权限管理" class="headerlink" title="7、组管理权限管理"></a>7、组管理权限管理</h2><p>文件目录参数</p><h4 id="1、所有者"><a href="#1、所有者" class="headerlink" title="1、所有者"></a>1、所有者</h4><p>创建文件的用户即为所有者</p><h5 id="查看所有者"><a href="#查看所有者" class="headerlink" title="查看所有者"></a>查看所有者</h5><p>指令 ls -ahl</p><h5 id="改变所有者"><a href="#改变所有者" class="headerlink" title="改变所有者"></a>改变所有者</h5><p>指令chown  改后所有者  文件名</p><h4 id="2、组"><a href="#2、组" class="headerlink" title="2、组"></a>2、组</h4><h5 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h5><p>groupadd 组名</p><h5 id="添加用户指定组"><a href="#添加用户指定组" class="headerlink" title="添加用户指定组"></a>添加用户指定组</h5><p>useradd -g  组名  用户名</p><p>组名必须存在</p><h5 id="修改用户组-1"><a href="#修改用户组-1" class="headerlink" title="修改用户组"></a>修改用户组</h5><p>usermod -g  groupname  username</p><h5 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h5><p>chgrp 组名 文件名</p><h4 id="3、权限"><a href="#3、权限" class="headerlink" title="3、权限"></a>3、权限</h4><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210502225223910.png" alt="image-20210502225223910"></p><p>drwxr-xr-x.   2           root        root          6        4月  30 20:18         桌面</p><p>​       权限      数字     所有者   所有者组   大小  文件最后修改时间   文件名</p><p>第一位：代表文件类型</p><p>​                d ：文件夹</p><p>​                - ：文件</p><p>​                l ：软链接</p><p>​               c ：字符设备（鼠标键盘）</p><p>​               b：块文件（硬盘）</p><p>第二三四位：代表所有者权限</p><p>​               rwx：代表有读写（进入目录或执行文件）权限</p><p>第五六七位：文件所在组用户拥有权限</p><p>​               r-x：代表有读（进入目录或执行文件）权限，没写权限</p><p>第八九十位：其他组用户拥有的权限</p><p>​              r-x：代表有读（进入目录或执行文件）权限，没写权限</p><p>数字：</p><p>​             文件1：代表硬链接数</p><p>​             目录2：代表子目录个数</p><p>大小：</p><p>​             文件显示文件所占字节</p><p>​             目录显示6</p><h5 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h5><p>chomd</p><p>u：所有者    g：所在组    o：其他组    a：所有人</p><p>+：增加</p><p>-：去除</p><p>1、chmod  u - w   文件名  （去掉所有者写权限）</p><p>2、chmod  o + w  文件名    （为所其他人增加写权限）</p><p>3、chmod  u=rwx,g=rx,o=x  文件名</p><p>方式二</p><p>r = 4  ， w = 2 ， x = 1</p><p>chmod 777 文件名   （所有用户对文件开启所有权限）</p><h5 id="修改所有者"><a href="#修改所有者" class="headerlink" title="修改所有者"></a>修改所有者</h5><p>chown owner filename</p><p>chown owner:group  filename   （同时修改拥有者及组）</p><p>chown -R owner dirname        （修改所在目录所有文件）</p><h5 id="修改所在组"><a href="#修改所在组" class="headerlink" title="修改所在组"></a>修改所在组</h5><p>chgrp groupname file</p><p>chgrp -R groupname dir （将dir下全修改）</p><blockquote><p>上述 -R 中的R必须大写</p></blockquote><h2 id="8、crond任务调度"><a href="#8、crond任务调度" class="headerlink" title="8、crond任务调度"></a>8、crond任务调度</h2><p>crontab [选项]</p><p>常用选项</p><p>-e    编辑</p><p>-l    显示</p><p>-r    删除所有</p><p>service crond restart   （重启任务调度服务）</p><p>cron占位符使用说明</p><p>与spring中的cron表达式一样</p><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一颗  “*”</td><td>代表一小时的第几分钟</td><td>0-59</td></tr><tr><td>第二颗  “*”</td><td>代表一天中的第几小时</td><td>0-23</td></tr><tr><td>第三颗  “*”</td><td>代表一个月的第几天</td><td>1-31</td></tr><tr><td>第四颗  “*”</td><td>代表一年中的第几月</td><td>1-12</td></tr><tr><td>第五颗  “*”</td><td>代表星期</td><td>0-7（07含义相同）</td></tr><tr><td>*</td><td>代表任何时间</td><td></td></tr><tr><td>，</td><td>分隔离散时间 1，2，3</td><td></td></tr><tr><td>-</td><td>代表范围</td><td></td></tr><tr><td>*/n</td><td>每个多久执行一次 “*/10 * * * *” 10分钟一次</td><td></td></tr></tbody></table><p>使用脚本流程</p><p>1）编写脚本文件 </p><p>例如：</p><p>vim /home/mytask.sh</p><p>将date信息追加写入/tmp/mydate文件</p><p>date &gt;&gt; /tmp/mydate  </p><p>2）给mydate.sh可执行权限</p><p>chmod 744 mydate.sh</p><p>3）crontab -e</p><p>每隔1min执行一次</p><p>*/1 * * * *  /home/mytask.sh</p><h2 id="9、磁盘的分区和挂载"><a href="#9、磁盘的分区和挂载" class="headerlink" title="9、磁盘的分区和挂载"></a>9、磁盘的分区和挂载</h2><h3 id="常用分区"><a href="#常用分区" class="headerlink" title="常用分区"></a>常用分区</h3><h4 id="mbr分区"><a href="#mbr分区" class="headerlink" title="mbr分区"></a>mbr分区</h4><p>特点</p><p>1.最多四个主分区</p><p>2.系统只能安装在主分区</p><p>3.扩展分分区占一个主分区</p><p>4.最大值支持2TB兼容性好</p><h4 id="gtp分区"><a href="#gtp分区" class="headerlink" title="gtp分区"></a>gtp分区</h4><p>特点</p><p>1.支持无限主分区</p><p>2.最大容量支持18EB</p><p>3.windows 64位以后支持gtp</p><h3 id="window分区"><a href="#window分区" class="headerlink" title="window分区"></a>window分区</h3><p>采用主分区+拓展分区（包含若干逻辑分区）的形式</p><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><p>Linux一切皆文件</p><p>当有磁盘接入Linux时，会使用mount（unmount卸载）将分区挂载到文件系统，彼时分区及对应着一个文件目录</p><h4 id="Linux硬盘标识"><a href="#Linux硬盘标识" class="headerlink" title="Linux硬盘标识"></a>Linux硬盘标识</h4><p>硬盘种类</p><p>IDE硬盘（旧）</p><p>标识符 “hdx~”（hd设备类型，这里指硬盘  x指盘号：a基本盘，b基本从属盘，c辅助主盘，d辅助从属盘 ~代表分区前四个为1234为主分区或拓展分区 5开始代表逻辑分区）</p><p>SCSI硬盘（新）</p><p>标识符为“sdx” sd表示类型其余与IDE 一样</p><p>查看分区命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -f</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503115008334.png" alt="image-20210503115008334"></p><h4 id="增加硬盘"><a href="#增加硬盘" class="headerlink" title="增加硬盘"></a>增加硬盘</h4><p>步骤：</p><p>1）虚拟机添加盘</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503153705913.png" alt="image-20210503153705913"></p><p>一直下一步可以看到分配了一个新盘</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503153823545.png" alt="image-20210503153823545"></p><p>重启执行lsblk</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503154520869.png" alt="image-20210503154520869"></p><p>dev文件目录中可以看到sdb文件</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155000261.png" alt="image-20210503155000261"></p><p>2）分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155349549.png" alt="image-20210503155349549"></p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155330489.png" alt="image-20210503155330489"></p><p>根据说明输入n</p><p>输入p</p><p>剩下的默认即可</p><p>最后输入w写入并退出</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155554490.png" alt="image-20210503155554490"></p><p>此时分区已分好</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155858994.png" alt="image-20210503155858994"></p><p>3）格式化</p><p>刚分好区为以下状态，没有文件类型，uuid以及挂载点</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155938818.png" alt="image-20210503155938818"></p><p>执行将sdb1格式化为 ext4 类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503160512228.png" alt="image-20210503160512228"></p><p>4）设置挂载点</p><p>将新分区挂载到/home/newdist  （必须保证存在）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /home/newdist</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503160929149.png" alt="image-20210503160929149"></p><p>挂载成功</p><p>5）永久挂载</p><p>上述步骤 4）挂载是一次性的重启后需要再次挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab #打开配置文件</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503161447199.png" alt="image-20210503161447199"></p><p>添加之后配置完成  可使用uuid也可以直接使用路径</p><p>最后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a   #自动挂载</span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unmount /dev/sdb1</span><br></pre></td></tr></table></figure><h4 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h4><p>整体磁盘使用情况</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -lh</span><br></pre></td></tr></table></figure><p>指定目录磁盘使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h 目录</span><br></pre></td></tr></table></figure><p>-s 指定目录占用大小汇总</p><p>-h 带计量单位</p><p>-a 含文件</p><p>-max-depth=1 子目录深度</p><p>-c 增加汇总值</p><h4 id="统计目录文件数目"><a href="#统计目录文件数目" class="headerlink" title="统计目录文件数目"></a>统计目录文件数目</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls -l /home | grep &quot;^-&quot; | wc -l</span><br><span class="line">[root@localhost home]# ll | grep &quot;^-&quot; | wc -l</span><br><span class="line"><span class="number">0</span></span><br><span class="line">[root@localhost home]# ll | grep &quot;^d&quot; | wc -l</span><br><span class="line"><span class="number">7</span></span><br><span class="line">统计所有文件个数</span><br><span class="line">[root@localhost home]# ls -lR | grep &quot;^-&quot; | wc -l</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>以树状图形式展示</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree</span> 目录</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503163819542.png" alt="image-20210503163819542"></p><h2 id="10、网络配置"><a href="#10、网络配置" class="headerlink" title="10、网络配置"></a>10、网络配置</h2><p>网络环境设置</p><p>第一种设置自动ip连接 </p><p>略</p><p>第二种指定固定IP</p><p>vim /etc/sysconfig/network-scripts/ifcfg-ens33</p><p>修改相关配置</p><h2 id="11、进程管理"><a href="#11、进程管理" class="headerlink" title="11、进程管理"></a>11、进程管理</h2><p>基本介绍</p><p>1）每执行一个程序就会启动一个进程。每一个进程对应着一个进程号。</p><p>2）每一个进程对应着一个父进程，这个父进程可以对应多个子进程</p><p>3）进程可以以前台和后台两种形式存在，一般系统服务会以后台方式运行，直到关机才结束进程</p><h3 id="查看进程指令"><a href="#查看进程指令" class="headerlink" title="查看进程指令"></a>查看进程指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure><p>-a 显示所有进程信息</p><p>-u 以用户格式显示进程信息</p><p>-x 显示后台进程运行参数</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503193937942.png" alt="image-20210503193937942"></p><p>含义（第一行为例）</p><p>root  用户名（USER）</p><p>1        进程id（PID）</p><p>0.0     cpu使用情况（%CPU）</p><p>0.2     内存使用情况（%MEM）</p><p>193912    使用的虚拟内存（VSZ）</p><p>4580    使用的物理内存（RSS）</p><p>？        使用的终端（TTY）</p><p>Ss        进程状态（STAT  s：休眠   r：运行 z：僵尸进程）</p><p>启动时间（START）</p><p>占用cpu总时间（TIME）</p><p>执行时命令（COMMAND）</p><p>以全格式显示所有进程，查看父进程 PPID即为父进程id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>kill和killall</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kill [选项] pid</span><br><span class="line"></span><br><span class="line">killall 进程名称  （支持通配符）</span><br><span class="line"></span><br><span class="line">常用</span><br><span class="line">kill -<span class="number">9</span> pid （强制停止pid进程）</span><br></pre></td></tr></table></figure><p>常用指令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">强制剔除非法用户</span><br><span class="line">kill pid</span><br><span class="line">终止远程登陆sshd</span><br><span class="line">查进程号</span><br><span class="line">ps -<span class="built_in">aux</span> | grep sshd</span><br><span class="line">kill pid </span><br><span class="line">干掉终端</span><br><span class="line">ps -<span class="built_in">aux</span> | grep bash</span><br><span class="line">kill -<span class="number">9</span> pid</span><br></pre></td></tr></table></figure><p>pstree以树状形式展示</p><p>-p pid</p><p>-u uid</p><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>6  centos7也可以用</p><p>service  服务名  [start | stop | restart | reload | status]</p><p>7.0</p><p>systemctl  服务名  [start | stop | restart | reload | status]</p><p>使用Windows检验</p><p>telnet ip 端口</p><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h4><p>方式一</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行</span><br><span class="line">setup</span><br></pre></td></tr></table></figure><p>方式二</p><p>查看/etc/init.d/ </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /etc/init.d/</span><br></pre></td></tr></table></figure><h4 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看所有运行级别下自启动情况</span><br><span class="line">chkconfig  --list</span><br><span class="line">查看指定服务</span><br><span class="line">chkconfig 服务名 --list</span><br><span class="line">修改</span><br><span class="line">chkconfig --level 级别 服务名 on/off</span><br></pre></td></tr></table></figure><h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top [选项]</p><p>-d 设置刷新时间 </p><p>-i  不显示闲置僵尸进程</p><p>-p 仅显示某个进程</p><p>P 按CPU使用情况</p><p>M 按内存排序</p><p>N 按PID排序</p><p>q 退出</p><h3 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h3><p>netstat [选项]</p><p>netstat -anp</p><p>-an 按顺序排列输出</p><p>-p 显示哪个进程在调用</p><h2 id="12、rpm与yum包管理"><a href="#12、rpm与yum包管理" class="headerlink" title="12、rpm与yum包管理"></a>12、rpm与yum包管理</h2><h3 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">查询已安装</span><br><span class="line">rpm -qa</span><br><span class="line">查询单个</span><br><span class="line">rpm -q 软件名</span><br><span class="line">查询版本</span><br><span class="line">rpm -qi 软件名</span><br><span class="line">查看软件包装了文件的位置</span><br><span class="line">rpm -ql 文件名</span><br><span class="line">查询文件属于哪个软件包</span><br><span class="line">rpm -qf 文件名</span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line">rmp -e 名称</span><br><span class="line">强制删除</span><br><span class="line">rpm -e -nodeps 名称</span><br><span class="line">安装</span><br><span class="line">i：install 安装  v：verbose 提示  h：hash 进度条</span><br><span class="line">需要先在midea里找到对应安装包</span><br><span class="line">rpm -ivh 名称</span><br></pre></td></tr></table></figure><h3 id="yum包管理"><a href="#yum包管理" class="headerlink" title="yum包管理"></a>yum包管理</h3><p>yum不需要rpm那样去找media里的安装包而是通过公网服务器去下载，而且它还可以自动获取依赖包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询</span><br><span class="line">yum list （最好加 grep）</span><br><span class="line">安装</span><br><span class="line">yum install 名称</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、VMware网络&quot;&gt;&lt;a href=&quot;#1、VMware网络&quot; class=&quot;headerlink&quot; title=&quot;1、VMware网络&quot;&gt;&lt;/a&gt;1、VMware网络&lt;/h2&gt;&lt;p&gt;1、桥连接&lt;/p&gt;
&lt;p&gt;与主机在同一网段，Linxu可以和其他的系统通信，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="https://cenkii.github.io/2021/04/16/nginx/"/>
    <id>https://cenkii.github.io/2021/04/16/nginx/</id>
    <published>2021-04-16T13:29:10.000Z</published>
    <updated>2021-04-17T12:08:52.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是Nginx"><a href="#1、什么是Nginx" class="headerlink" title="1、什么是Nginx"></a><strong>1、什么是Nginx</strong></h2><p>Nginx是是一个高性能的<strong>HTTP和反向代理web服务器</strong>，同时它也支持电子邮件代理（它也是一个IMAP/POP3/SMTP服务器）。Nginx在BSD-like 协议下发行。其特点是占有内存少，并发能力强。</p><h2 id="2、Nginx-特点"><a href="#2、Nginx-特点" class="headerlink" title="2、Nginx 特点"></a>2、Nginx 特点</h2><ul><li>高并发、高性能；</li><li>模块化架构使得它的扩展性非常好；</li><li>异步非阻塞的事件驱动模型；</li><li>高可靠性，相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器；</li><li>热部署、平滑升级；</li><li>完全开源，生态繁荣；</li></ul><h2 id="3、Nginx-应用场景"><a href="#3、Nginx-应用场景" class="headerlink" title="3、Nginx 应用场景"></a>3、Nginx 应用场景</h2><p>Nginx 的最重要的几个使用场景：</p><ol><li>静态资源服务，通过本地文件系统提供服务；</li><li>反向代理服务，延伸出包括缓存、负载均衡等；</li><li><code>API</code> 服务， <code>OpenResty</code> ；</li></ol><blockquote><p><code>OpenResty</code> 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p></blockquote><p>1、反向代理与正向代理</p><p>反向代理</p><p><strong>反向代理</strong>（Reverse Proxy）方式是指以代理服务器来<strong>接受</strong>internet上的<strong>连接请求</strong>，然后将请求<strong>转发</strong>给内部网络上的服务器，并将从<strong>服务器</strong>上得到的<strong>结果返回</strong>给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p>反向代理是<strong>为服务端服务</strong>的，<strong>对服务端透明</strong>，服务端知道自己的消息来自是代理服务器，但客户端不知道自己请求的是代理服务器。</p><p>反向代理中的服务器下图通常为作同一件事的服务器。</p><p><img src="/2021/04/16/nginx/C:%5CUsers%5C%E9%99%88%E7%90%AA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210417140926967.png" alt="image-20210417140926967"></p><p>正向代理</p><p><strong>正向代理</strong>是一个位于<strong>客户端和原始服务器(origin server)之间</strong>的服务器，为了从原始服务器取得内容，<strong>客户端</strong>向代理<strong>发送</strong>一个请求并指定目标(原始服务器)，然后<strong>代理向原始服务器转交</strong>请求并将获得的内容<strong>返回给客户端</strong>。</p><p>正向代理为<strong>客户端服务</strong>,对于<strong>客户端是透明</strong>，对于服务端是不透明的，服务端不知道请求是来自用户还是代理。</p><p>正向代理下图中的服务器A和B通常为作用不同的服务器。</p><p><img src="/2021/04/16/nginx/C:%5CUsers%5C%E9%99%88%E7%90%AA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210417140829956.png" alt="image-20210417140829956"></p><h2 id="四、Nginx下载及安装"><a href="#四、Nginx下载及安装" class="headerlink" title="四、Nginx下载及安装"></a>四、Nginx下载及安装</h2><p>官方网址： <a href="http://nginx.org/">http://nginx.org/</a></p><p><img src="/2021/04/16/nginx/C:%5CUsers%5C%E9%99%88%E7%90%AA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210417141909305.png" alt="image-20210417141909305"></p><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><p>也可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure><p>五、、使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-152-249-centos ~]# rpm \-ql nginx</span><br><span class="line">/etc/logrotate.d/nginx</span><br><span class="line">/etc/nginx/fastcgi.conf</span><br><span class="line">/etc/nginx/fastcgi.conf.default</span><br><span class="line">/etc/nginx/fastcgi_params</span><br><span class="line">/etc/nginx/fastcgi_params.default</span><br><span class="line">/etc/nginx/koi-utf</span><br><span class="line">/etc/nginx/koi-win</span><br><span class="line">/etc/nginx/mime.types</span><br><span class="line">/etc/nginx/mime.types.default</span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line">/etc/nginx/nginx.conf.default</span><br><span class="line">/etc/nginx/scgi_params</span><br><span class="line">/etc/nginx/scgi_params.default</span><br><span class="line">/etc/nginx/uwsgi_params</span><br><span class="line">/etc/nginx/uwsgi_params.default</span><br><span class="line">/etc/nginx/win-utf</span><br><span class="line">/usr/bin/nginx-upgrade</span><br><span class="line">/usr/lib/systemd/system/nginx.service</span><br><span class="line">/usr/lib64/nginx/modules</span><br><span class="line">/usr/sbin/nginx</span><br><span class="line">/usr/share/doc/nginx-1.16.1</span><br><span class="line">/usr/share/doc/nginx-1.16.1/CHANGES</span><br><span class="line">/usr/share/doc/nginx-1.16.1/README</span><br><span class="line">/usr/share/doc/nginx-1.16.1/README.dynamic</span><br><span class="line">/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10</span><br><span class="line">/usr/share/licenses/nginx-1.16.1</span><br><span class="line">/usr/share/licenses/nginx-1.16.1/LICENSE</span><br><span class="line">/usr/share/man/man3/nginx.3pm.gz</span><br><span class="line">/usr/share/man/man8/nginx-upgrade.8.gz</span><br><span class="line">/usr/share/man/man8/nginx.8.gz</span><br><span class="line">/usr/share/nginx/html/404.html</span><br><span class="line">/usr/share/nginx/html/50x.html</span><br><span class="line">/usr/share/nginx/html/en-US</span><br><span class="line">/usr/share/nginx/html/icons</span><br><span class="line">/usr/share/nginx/html/icons/poweredby.png</span><br><span class="line">/usr/share/nginx/html/img</span><br><span class="line">/usr/share/nginx/html/index.html</span><br><span class="line">/usr/share/nginx/html/nginx-logo.png</span><br><span class="line">/usr/share/nginx/html/poweredby.png</span><br><span class="line">/usr/share/vim/vimfiles/ftdetect/nginx.vim</span><br><span class="line">/usr/share/vim/vimfiles/ftplugin/nginx.vim</span><br><span class="line">/usr/share/vim/vimfiles/indent/nginx.vim</span><br><span class="line">/usr/share/vim/vimfiles/syntax/nginx.vim</span><br><span class="line">/var/lib/nginx</span><br><span class="line">/var/lib/nginx/tmp</span><br><span class="line">/var/log/nginx</span><br><span class="line">[root@VM-152-249-centos ~]# </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、什么是Nginx&quot;&gt;&lt;a href=&quot;#1、什么是Nginx&quot; class=&quot;headerlink&quot; title=&quot;1、什么是Nginx&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、什么是Nginx&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Nginx是是一个高性能的&lt;strong&gt;
      
    
    </summary>
    
    
    
      <category term="Nginx" scheme="https://cenkii.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://cenkii.github.io/2021/04/08/Java-IO/"/>
    <id>https://cenkii.github.io/2021/04/08/Java-IO/</id>
    <published>2021-04-08T06:39:18.000Z</published>
    <updated>2021-04-10T13:30:05.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、IO-介绍"><a href="#一、IO-介绍" class="headerlink" title="一、IO 介绍"></a>一、IO 介绍</h1><p>IO即：Input/Output的缩写。 IO 操作模块在 Java 开始之初推出的是BIO，BIO 是 BlockingIO 的缩写，顾名思义就是阻塞 IO 的意思。</p><p>BIO 位于传统的 <a href="http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的优点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</p><h2 id="1-1-IO类型"><a href="#1-1-IO类型" class="headerlink" title="1.1 IO类型"></a>1.1 IO类型</h2><p>传统的 IO 大致可以分为4种类型：</p><ul><li>InputStream、OutputStream 基于<strong>字节操作</strong>的 IO</li><li>Writer、Reader 基于<strong>字符操作</strong>的 IO</li><li>File 基于<strong>磁盘操作</strong>的 IO</li><li>Socket 基于<strong>网络操作</strong>的 IO（Scoket 很多时候人们也把它归为 同步阻塞 IO ,因为网络通讯同样是 IO 行为。)</li></ul><h2 id="1-2-IO使用"><a href="#1-2-IO使用" class="headerlink" title="1.2 IO使用"></a>1.2 IO使用</h2><h3 id="1-2-1-InputStream-使用"><a href="#1-2-1-InputStream-使用" class="headerlink" title="1.2.1 InputStream 使用"></a>1.2.1 InputStream 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">inputStream.read(bytes);</span><br><span class="line">String str = <span class="keyword">new</span> String(bytes, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure><h3 id="1-2-2-OutputStream-使用"><a href="#1-2-2-OutputStream-使用" class="headerlink" title="1.2.2 OutputStream 使用"></a>1.2.2 OutputStream 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\test.txt&quot;</span>,<span class="keyword">true</span>); <span class="comment">// 参数二，表示是否追加，true=追加</span></span><br><span class="line">outputStream.write(<span class="string">&quot;Hello World OutputStream&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">outputStream.close();</span><br></pre></td></tr></table></figure><h3 id="1-2-3-Writer-使用"><a href="#1-2-3-Writer-使用" class="headerlink" title="1.2.3 Writer 使用"></a>1.2.3 Writer 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\test.txt&quot;</span>,<span class="keyword">true</span>); <span class="comment">// 参数二，是否追加文件，true=追加</span></span><br><span class="line">writer.append(<span class="string">&quot;hello world write&quot;</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><h3 id="1-2-4-Reader-使用"><a href="#1-2-4-Reader-使用" class="headerlink" title="1.2.4 Reader 使用"></a>1.2.4 Reader 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">StringBuffer bf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">String str;</span><br><span class="line"><span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bf.append(str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">bufferedReader.close();</span><br><span class="line">reader.close();</span><br><span class="line">System.out.println(bf.toString());</span><br></pre></td></tr></table></figure><p>字节流与字符流</p><p>InputStream、OutputStream 属于字节流操作。在源码中它使用byte b[]数组进行操作</p><p>Writer、Reader属于字符流操作在源码中使用char cbuf[]进行操作</p><h1 id="二、NIO"><a href="#二、NIO" class="headerlink" title="二、NIO"></a>二、NIO</h1><p>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建<strong>多路复用的、同步非阻塞 IO</strong> 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</p><h2 id="1-NIO与BIO"><a href="#1-NIO与BIO" class="headerlink" title="1 NIO与BIO"></a>1 NIO与BIO</h2><p>1、面向流和缓冲区</p><p>传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的</p><p>就像自来水要通过水管将自来水厂和家连接起来一样</p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109084453.png" alt></p><p><strong>NIO</strong></p><p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据</p><p>相当于在中间建了座水塔，自来水厂将水放入水塔，缓冲区就像水塔</p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109085054.png" alt></p><h2 id="2-NIO的结构"><a href="#2-NIO的结构" class="headerlink" title="2 NIO的结构"></a>2 NIO的结构</h2><p>Java NIO 由以下几个核心部分组成：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。但<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong>。</p><p><img src="/2021/04/08/Java-IO/Java-IO%5Cimage-20210410210258710.png" alt="image-20210410210258710"></p><h4 id="1、图解"><a href="#1、图解" class="headerlink" title="1、图解"></a>1、图解</h4><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低</p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109153039.png" alt="img"></p><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong></p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109153439.png" alt="img"></p><p>于是便有了<strong>Channel(通道)</strong>，Channel相当于一个<strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求</p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109154113.png" alt="img"></p><h4 id="2、Java-Channel"><a href="#2、Java-Channel" class="headerlink" title="2、Java Channel"></a>2、Java Channel</h4><h5 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h5><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109154803.png" alt="img"></p><ul><li>FileChannel   从文件中读写数据。</li><li>DatagramChannel   能通过UDP读写网络中的数据。</li><li>SocketChannel   能通过TCP读写网络中的数据。</li><li>ServerSocketChannel  可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ul><h5 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h5><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 本地通道</span></span><br><span class="line">      FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      FileChannel channel1 = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">      FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      FileChannel channel2 = fileOutputStream.getChannel();</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 网络通道</span></span><br><span class="line">      Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">      SocketChannel channel3 = socket.getChannel();</span><br><span class="line">      </span><br><span class="line">      ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">      ServerSocketChannel channel4 = serverSocket.getChannel();</span><br><span class="line"></span><br><span class="line">      DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">      DatagramChannel channel5 = datagramSocket.getChannel();</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 最后要关闭通道</span></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也可以通过通道的静态方法open()来获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   FileChannel open = FileChannel.open(Paths.get(<span class="string">&quot;&quot;</span>));</span><br><span class="line">   </span><br><span class="line">   SocketChannel open1 = SocketChannel.open();</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h5><ul><li>getChannel()获得通道</li><li>allocate()获得<strong>非直接缓冲区</strong></li></ul><p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">      FileOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 获得通道</span></span><br><span class="line">      FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">      FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 利用 try-catch-finally 保证关闭</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>);</span><br><span class="line">         os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获得通道</span></span><br><span class="line">         inChannel = is.getChannel();</span><br><span class="line">         outChannel = os.getChannel();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获得缓冲区，用于在通道中传输数据</span></span><br><span class="line">         ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 循环将字节数据放入到buffer中，然后写入磁盘中</span></span><br><span class="line">         <span class="keyword">while</span> (inChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 切换模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            outChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               inChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               outChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图片读取后，被写入到了指定位置</strong></p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109211055.png" alt="img"></p><h5 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h5><ul><li>通过open获得通道</li><li>通过FileChannel.map()获取直接缓冲区</li></ul><p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 通过open()方法来获得通道</span></span><br><span class="line">      FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// outChannel需要为 READ WRITE CREATE模式</span></span><br><span class="line">      <span class="comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span></span><br><span class="line">      <span class="comment">// CREATE是因为要创建新的文件</span></span><br><span class="line">      FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\3.jpg&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获得直接缓冲区</span></span><br><span class="line">      MappedByteBuffer inMapBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">      MappedByteBuffer outMapBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inMapBuf.limit()];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输</span></span><br><span class="line">      inMapBuf.get(bytes);</span><br><span class="line">      outMapBuf.put(bytes);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭缓冲区，这里没有用try-catch-finally</span></span><br><span class="line">      inChannel.close();</span><br><span class="line">      outChannel.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果，图片被创建</strong></p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109214801.png" alt="img"></p><h5 id="通道间直接传输"><a href="#通道间直接传输" class="headerlink" title="通道间直接传输"></a>通道间直接传输</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelToChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">// 通过open()方法来获得通道</span></span><br><span class="line">   FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.mp4&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// outChannel需要为 READ WRITE CREATE模式</span></span><br><span class="line">   <span class="comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span></span><br><span class="line">   <span class="comment">// CREATE是因为要创建新的文件</span></span><br><span class="line">   FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\4.mp4&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通道间直接传输</span></span><br><span class="line">   inChannel.transferTo(<span class="number">0</span>, inChannel.size(), outChannel);</span><br><span class="line">   <span class="comment">// 对应的还有transferFrom</span></span><br><span class="line">   <span class="comment">// outChannel.transferFrom(inChannel, 0, inChannel.size());</span></span><br><span class="line"></span><br><span class="line">   inChannel.close();</span><br><span class="line">   outChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="直接缓冲区VS非直接缓冲区"><a href="#直接缓冲区VS非直接缓冲区" class="headerlink" title="直接缓冲区VS非直接缓冲区"></a>直接缓冲区VS非直接缓冲区</h5><p><strong>效率</strong></p><p>读取一个MP4文件，通过二者花费时间的多少来判定执行的速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getChannel() + 非直接缓冲区耗时</span></span><br><span class="line"><span class="number">708</span></span><br><span class="line"><span class="comment">// open() + 直接缓冲区耗时</span></span><br><span class="line"><span class="number">115</span></span><br><span class="line"><span class="comment">// channel transferTo channel耗时</span></span><br><span class="line"><span class="number">47</span></span><br></pre></td></tr></table></figure><p><strong>内存占用</strong></p><p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢</p><h4 id="3、分散和聚集"><a href="#3、分散和聚集" class="headerlink" title="3、分散和聚集"></a>3、分散和聚集</h4><h5 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h5><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p><p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201111082427.png" alt="img"></p><h5 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h5><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p><p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082547.png" alt="img"></a></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划.txt&quot;</span>);</span><br><span class="line">      FileOutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">      FileChannel inChannel = is.getChannel();</span><br><span class="line">      FileChannel outChannel = os.getChannel();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获得多个缓冲区，并且放入到缓冲区数组中</span></span><br><span class="line">      ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">      ByteBuffer byteBuffer2 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      ByteBuffer[] byteBuffers = &#123;byteBuffer1, byteBuffer2&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 分散读取</span></span><br><span class="line">      inChannel.read(byteBuffers);</span><br><span class="line">      </span><br><span class="line">      byteBuffer1.flip();</span><br><span class="line">      byteBuffer2.flip();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 聚集写入</span></span><br><span class="line">      outChannel.write(byteBuffers);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201111083219.png" alt="img"></p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h4 id="1、缓冲区类型"><a href="#1、缓冲区类型" class="headerlink" title="1、缓冲区类型"></a>1、缓冲区类型</h4><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p><strong>各种类型的缓冲区中，都有一个对应类型的数组</strong>，如</p><p>ByteBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br></pre></td></tr></table></figure><p>继承关系</p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109091555.png" alt></p><h4 id="2、获取缓冲区"><a href="#2、获取缓冲区" class="headerlink" title="2、获取缓冲区"></a>2、获取缓冲区</h4><p>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法</p><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个容量大小为1024字节的字节缓冲区</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h4 id="3、核心属性"><a href="#3、核心属性" class="headerlink" title="3、核心属性"></a>3、核心属性</h4><p>缓冲区的父类Buffer中有几个核心属性，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure><ul><li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</li><li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong>。在写模式下他表示最多能写多少数据，等于capacity。在读模式下，表示最多读多少，它的值等于写模式下的position</li><li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong>，在写数据时总是指向下一个可插入地方，最大值为capacity – 1。当读模式下会置为0，读一次移一次。</li><li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><p><img src="/2021/04/08/Java-IO/Java-IO%5Cimage-20210410203524736.png" alt="image-20210410203524736"></p><h4 id="4、核心方法"><a href="#4、核心方法" class="headerlink" title="4、核心方法"></a>4、核心方法</h4><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h5><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><h5 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h5><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，即写的position ，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li></ul><h5 id="ewind-方法"><a href="#ewind-方法" class="headerlink" title="ewind()方法"></a>ewind()方法</h5><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><h5 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h5><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><h5 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h5><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="5、非直接缓冲区和直接缓冲区"><a href="#5、非直接缓冲区和直接缓冲区" class="headerlink" title="5、非直接缓冲区和直接缓冲区"></a>5、非直接缓冲区和直接缓冲区</h4><h5 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h5><p>通过<strong>allocate()</strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM<strong>堆内存</strong>之中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆内存中开辟空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;        <span class="comment">// package-private</span></span><br><span class="line">    <span class="comment">// new byte[cap] 创建数组，在堆内存中开辟空间</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = new byte[cap];</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109151057.png" alt="img"></p><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以相对于直接缓冲区的读取效率较低</p><h5 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h5><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 申请物理内存</span></span><br><span class="line"><span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201109151520.png" alt="img"></p><p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><h5 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h5><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p><p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201111090126.png" alt="img"></p><h5 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h5><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p><p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201112165417.png" alt="img"></p><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>选择器（Selector）是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201112163633.png" alt="img"></p><p><strong>选择器的创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p><strong>绑定选择器</strong></p><p>通过调用通道的register方法可以绑定选择器，register方法有两个参数</p><ul><li><p>Selector：即绑定哪个选择器</p></li><li><p>ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</p><p><img src="/2021/04/08/Java-IO/Java-IO%5C20201112164022.png" alt="img"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让选择器监听一种状态</span></span><br><span class="line">myChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="comment">// 让选择器监听多种状态</span></span><br><span class="line">myChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><p><strong>SelectionKey</strong></p><p><strong>表示SelectableChannel 和Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。</p><h1 id="三、AIO"><a href="#三、AIO" class="headerlink" title="三、AIO"></a>三、AIO</h1><p>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、IO-介绍&quot;&gt;&lt;a href=&quot;#一、IO-介绍&quot; class=&quot;headerlink&quot; title=&quot;一、IO 介绍&quot;&gt;&lt;/a&gt;一、IO 介绍&lt;/h1&gt;&lt;p&gt;IO即：Input/Output的缩写。 IO 操作模块在 Java 开始之初推出的是BIO，BIO
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://cenkii.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://cenkii.github.io/2021/04/07/%E5%8F%8D%E5%B0%84/"/>
    <id>https://cenkii.github.io/2021/04/07/%E5%8F%8D%E5%B0%84/</id>
    <published>2021-04-07T13:05:32.000Z</published>
    <updated>2021-04-07T13:06:47.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h1><p>java代码在计算机中经历的三个阶段：</p><p><img src="/2021/04/07/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84%5Cimage-20210406222824534.png" alt="image-20210406222824534"></p><p>从person.class到第二阶段的过程就是反射</p><h2 id="获取class对象的方式"><a href="#获取class对象的方式" class="headerlink" title="获取class对象的方式"></a>获取class对象的方式</h2><p>第一阶段获取方式</p><p>Class.forName(“全路径类名”)</p><p>将字节码文件加载进内存，返回class对象</p><p>第二阶段获取方式</p><p>类名.class</p><p>第三阶段获取方式</p><p>对象.getClass()  getClass() 是Object类中定义以下方法</p><h3 id="关于class类"><a href="#关于class类" class="headerlink" title="关于class类"></a>关于class类</h3><p>通过Object类中的getClass() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>可以看到该方法的返回值就是Class类，<strong>Class类是反射的源头</strong></p><ul><li>Class本身也是一个类</li><li>Class对象<strong>只能由系统建立对象</strong></li><li>一个加载的类在<strong>JVM中只会有一个Class实例</strong></li><li>一个Class对象对应的是一个 加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class可以完整地得到一个类中的<strong>所有被加载的结构</strong></li><li><strong>Class类是Reflection的根源</strong>，针对任何你想动态加载、运行的类，唯有先获得相应的对象</li></ul><h4 id="拥有class对象的数据类型"><a href="#拥有class对象的数据类型" class="headerlink" title="拥有class对象的数据类型"></a>拥有class对象的数据类型</h4><p>class：外部类、内部内、静态内部类等</p><p>interface：接口</p><p>[]：数组c</p><p>enum：枚举</p><p>annotation：注解@interface</p><p>primitive type：基本数据类型</p><p>void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Class c1 = Object.class;</span><br><span class="line">      Class c2 = Collection.class;</span><br><span class="line">      Class c3 = <span class="keyword">int</span>[].class;</span><br><span class="line">      Class c4 = ElementType.class;</span><br><span class="line">      Class c5 = SuppressWarnings.class;</span><br><span class="line">      Class c6 = Integer.class;</span><br><span class="line">      Class c7 = <span class="keyword">void</span>.class;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>成员变量Field的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException, ClassNotFoundException </span>&#123;</span><br><span class="line">      Class personClass = Person.class</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得所有public修饰的属性成员变量</span></span><br><span class="line">      Field[] fields = personClass.getFields();</span><br><span class="line">      Field field = personClass.getField(<span class="string">&quot;name&quot;</span>);<span class="comment">//获取单个</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得所有属性不考虑修饰符</span></span><br><span class="line">      Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得指定属性 不考虑修饰符</span></span><br><span class="line">      Field name = personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取a的值需要创建一个对象</span></span><br><span class="line">      <span class="comment">//value即为属性a的值</span></span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      Object value = field.get(person);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//设置a的值</span></span><br><span class="line">      field.set(person,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//暴力反射，忽略修饰符直接访问</span></span><br><span class="line">      name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      Object value2 = name.get(p);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException, ClassNotFoundException </span>&#123;</span><br><span class="line">      Class personClass = Person.class</span><br><span class="line">      <span class="comment">//无参构造</span></span><br><span class="line">      Person person = (Person) constructor.newInstance();</span><br><span class="line">  <span class="comment">//有参构造</span></span><br><span class="line">      Constructor constructor = personClass.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">  Person person1 = (Person) constructor.newInstance(<span class="string">&quot;123&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException, ClassNotFoundException </span>&#123;</span><br><span class="line">      Class personClass = Person.class</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得所有公有方法</span></span><br><span class="line">      Method[] methods = personClass.getMethods();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得所有方法</span></span><br><span class="line">      Method[] declaredMethods = personClass.getDeclaredMethods();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得指定方法（对象名，实参类型列表）</span></span><br><span class="line">      Method say = personClass.getDeclaredMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">      Person p = <span class="keyword">new</span> Person();</span><br><span class="line">      <span class="comment">//执行方法</span></span><br><span class="line">      say.invoke(p);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射：框架设计的灵魂&quot;&gt;&lt;a href=&quot;#反射：框架设计的灵魂&quot; class=&quot;headerlink&quot; title=&quot;反射：框架设计的灵魂&quot;&gt;&lt;/a&gt;反射：框架设计的灵魂&lt;/h1&gt;&lt;p&gt;java代码在计算机中经历的三个阶段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://cenkii.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://cenkii.github.io/2021/04/07/JVM/"/>
    <id>https://cenkii.github.io/2021/04/07/JVM/</id>
    <published>2021-04-07T12:47:35.000Z</published>
    <updated>2021-04-07T13:04:27.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1、JVM"><a href="#1、JVM" class="headerlink" title="1、JVM"></a>1、JVM</h2><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3 id="3-JVM-JRE-JDK关系"><a href="#3-JVM-JRE-JDK关系" class="headerlink" title="3. JVM JRE JDK关系"></a>3. JVM JRE JDK关系</h3><p><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/jvmjrejdk.png?lastModify=1617799693" alt="img"></p><h3 id="4-整体结构"><a href="#4-整体结构" class="headerlink" title="4. 整体结构"></a>4. 整体结构</h3><p><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/zhengti.png?lastModify=1617799693" alt="img"></p><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>没有内存溢出</li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li><li>栈帧包括局部变量表，返回地址，锁记录，操作数栈</li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method1() &#123;</span><br><span class="line">        method2(1, 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int method2(int a, int b) &#123;</span><br><span class="line">        int c = a + b;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li><li>jconsole 和 jvisualvm</li></ul></li></ul><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/heap.png?lastModify=1617799693" alt="img"></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150602.png?lastModify=1617799693" alt="img"></a></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.java</span><br></pre></td></tr></table></figure><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.class</span><br></pre></td></tr></table></figure></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150618.png?lastModify=1617799693" alt="img"></a></p></li><li><p>常量池</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150630.png?lastModify=1617799693" alt="img"></a></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150641.png?lastModify=1617799693" alt="img"></a></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，<strong>#号的内容需要在常量池中查找</strong>）</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150653.png?lastModify=1617799693" alt="img"></a></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是<em>.class文件中的，当该*</em>类被加载以后<strong>，它的常量池信息就会</strong>放入运行时常量池<strong>，并把里面的</strong>符号地址变为真实地址**</li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StringTableStudy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = &quot;a&quot;; </span><br><span class="line">        String b = &quot;b&quot;;</span><br><span class="line">        String ab = &quot;ab&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  // String a</span><br><span class="line">2: astore_1</span><br><span class="line">3: ldc           #3                  // String b</span><br><span class="line">5: astore_2</span><br><span class="line">6: ldc           #4                  // String ab</span><br><span class="line">8: astore_3</span><br><span class="line">9: return</span><br></pre></td></tr></table></figure><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StringTableStudy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = &quot;a&quot;;</span><br><span class="line">        String b = &quot;b&quot;;</span><br><span class="line">        String ab = &quot;ab&quot;;</span><br><span class="line">        //拼接字符串对象来创建新的字符串</span><br><span class="line">        String ab2 = a+b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">     Code:</span><br><span class="line">      stack=2, locals=5, args_size=1</span><br><span class="line">         0: ldc           #2                  // String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  // String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  // String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br><span class="line">;)Ljava/lang/StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br><span class="line">;)Ljava/lang/StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        29: return</span><br></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String ab = &quot;ab&quot;;</span><br><span class="line">String ab2 = a+b;</span><br><span class="line">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br><span class="line">System.out.println(ab == ab2);</span><br></pre></td></tr></table></figure><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class StringTableStudy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = &quot;a&quot;;</span><br><span class="line">        String b = &quot;b&quot;;</span><br><span class="line">        String ab = &quot;ab&quot;;</span><br><span class="line">        String ab2 = a+b;</span><br><span class="line">        //使用拼接字符串的方法创建字符串</span><br><span class="line">        String ab3 = &quot;a&quot; + &quot;b&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      Code:</span><br><span class="line">      stack=2, locals=6, args_size=1</span><br><span class="line">         0: ldc           #2                  // String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  // String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  // String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br><span class="line">;)Ljava/lang/StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br><span class="line">;)Ljava/lang/StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        //ab3初始化时直接从串池中获取字符串</span><br><span class="line">        29: ldc           #4                  // String ab</span><br><span class="line">        31: astore        5</span><br><span class="line">        33: return</span><br></pre></td></tr></table></figure><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br><span class="line">        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);</span><br><span class="line">        //调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br><span class="line">        String st2 = str.intern();</span><br><span class="line">        //给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br><span class="line">        String str3 = &quot;ab&quot;;</span><br><span class="line">        //因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br><span class="line">        System.out.println(str == st2);</span><br><span class="line">        System.out.println(str == str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br><span class="line">        String str3 = &quot;ab&quot;;</span><br><span class="line">        //&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br><span class="line">        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);</span><br><span class="line">        //此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br><span class="line">        String str2 = str.intern();</span><br><span class="line">        //false</span><br><span class="line">        System.out.println(str == str2);</span><br><span class="line">        //false</span><br><span class="line">        System.out.println(str == str3);</span><br><span class="line">        //true</span><br><span class="line">        System.out.println(str2 == str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150715.png?lastModify=1617799693" alt="img"></a></p><p><strong>使用了DirectBuffer</strong></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150736.png?lastModify=1617799693" alt="img"></a></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过ByteBuffer申请1M的直接内存</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ByteBuffer allocateDirect(int capacity) &#123;</span><br><span class="line">    return new DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DirectByteBuffer类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(int cap) &#123;   // package-private</span><br><span class="line">   </span><br><span class="line">    super(-1, 0, cap, cap);</span><br><span class="line">    boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    int ps = Bits.pageSize();</span><br><span class="line">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    long base = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); //申请内存</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        throw x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">    if (pa &amp;&amp; (base % ps != 0)) &#123;</span><br><span class="line">        // Round up to page boundary</span><br><span class="line">        address = base + ps - (base &amp; (ps - 1));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br><span class="line">    att = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void clean() &#123;</span><br><span class="line">       if (remove(this)) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               this.thunk.run(); //调用run方法</span><br><span class="line">           &#125; catch (final Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                   public Void run() &#123;</span><br><span class="line">                       if (System.err != null) &#123;</span><br><span class="line">                           (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(1);</span><br><span class="line">                       return null;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>对应对象的run方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (address == 0) &#123;</span><br><span class="line">        // Paranoia</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); //释放直接内存中占用的内存</span><br><span class="line">    address = 0;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150750.png?lastModify=1617799693" alt="img"></a></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150800.png?lastModify=1617799693" alt="img"></a></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int _4M = 4*1024*1024;</span><br><span class="line">        //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br><span class="line">        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int _4M = 4*1024*1024;</span><br><span class="line">        //使用引用队列，用于移除引用为空的软引用对象</span><br><span class="line">        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        //使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br><span class="line">        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);</span><br><span class="line"></span><br><span class="line">        //遍历引用队列，如果有元素，则移除</span><br><span class="line">        Reference&lt;? extends byte[]&gt; poll = queue.poll();</span><br><span class="line">        while(poll != null) &#123;</span><br><span class="line">            //引用队列不为空，则从集合中移除该元素</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            //移动到引用队列中的下一个元素</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150813.png?lastModify=1617799693" alt="img"></a></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150827.png?lastModify=1617799693" alt="img"></a></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150842.png?lastModify=1617799693" alt="img"></a></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150856.png?lastModify=1617799693" alt="img"></a></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150907.png?lastModify=1617799693" alt="img"></a></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150919.png?lastModify=1617799693" alt="img"></a></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150931.png?lastModify=1617799693" alt="img"></a></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150939.png?lastModify=1617799693" alt="img"></a></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150946.png?lastModify=1617799693" alt="img"></a></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608150955.png?lastModify=1617799693" alt="img"></a></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151002.png?lastModify=1617799693" alt="img"></a></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151010.png?lastModify=1617799693" alt="img"></a></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151018.png?lastModify=1617799693" alt="img"></a></p><p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151027.png?lastModify=1617799693" alt="img"></a></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151039.png?lastModify=1617799693" alt="img"></a></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151052.png?lastModify=1617799693" alt="img"></a></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200909201212.png?lastModify=1617799693" alt="img"></a></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151100.png?lastModify=1617799693" alt="img"></a></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151109.png?lastModify=1617799693" alt="img"></a></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151119.png?lastModify=1617799693" alt="img"></a></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151129.png?lastModify=1617799693" alt="img"></a></p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151140.png?lastModify=1617799693" alt="img"></a></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151150.png?lastModify=1617799693" alt="img"></a></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151201.png?lastModify=1617799693" alt="img"></a></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151211.png?lastModify=1617799693" alt="img"></a></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151222.png?lastModify=1617799693" alt="img"></a></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151229.png?lastModify=1617799693" alt="img"></a></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151239.png?lastModify=1617799693" alt="img"></a></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151249.png?lastModify=1617799693" alt="img"></a></p><h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p>查看虚拟机参数命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;F:\JAVA\JDK8.0\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;</span><br></pre></td></tr></table></figure><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC  互联网低延迟</li><li>ParallelGC  科学运算</li><li>Zing （虚拟机）超低延迟</li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳 <em>[并发量(请求-响应)]</em> 的数据为宜</li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><ul><li>内存越大越好</li><li>先尝试调优新生代</li></ul><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200608151300.png?lastModify=1617799693" alt="img"></a></p><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:…\XXX.java</li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200910155135.png?lastModify=1617799693" alt="img"></a></p><p>以下是字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u4             magic;</span><br><span class="line">u2             minor_version;    </span><br><span class="line">u2             major_version;    </span><br><span class="line">u2             constant_pool_count;    </span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];    </span><br><span class="line">u2             access_flags;    </span><br><span class="line">u2             this_class;    </span><br><span class="line">u2             super_class;   </span><br><span class="line">u2             interfaces_count;    </span><br><span class="line">u2             interfaces[interfaces_count];   </span><br><span class="line">u2             fields_count;    </span><br><span class="line">field_info     fields[fields_count];   </span><br><span class="line">u2             methods_count;    </span><br><span class="line">method_info    methods[methods_count];    </span><br><span class="line">u2             attributes_count;    </span><br><span class="line">attribute_info attributes[attributes_count];</span><br></pre></td></tr></table></figure><h4 id="1-1魔数"><a href="#1-1魔数" class="headerlink" title="1.1魔数"></a>1.1魔数</h4><p>u4 magic</p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="1-2版本"><a href="#1-2版本" class="headerlink" title="1.2版本"></a>1.2版本</h4><p>u2 minor_version;</p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><p>34H = 52，代表JDK8</p><h4 id="1-3常量池"><a href="#1-3常量池" class="headerlink" title="1.3常量池"></a>1.3常量池</h4><p>长度</p><p>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p><p>内容</p><p>0000000 ca fe ba be 00 00 00 34 00 23 <strong>0a 00 06 00 15</strong> 09</p><p>类型+长度+内容</p><p>可参考</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  Last modified 2020-6-6; size 434 bytes</span><br><span class="line">  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e</span><br><span class="line">  Compiled from &quot;Demo1.java&quot;</span><br><span class="line">public class com.nyima.JVM.day5.Demo1</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #18            // hello world</span><br><span class="line">   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #21            // com/nyima/JVM/day5/Demo1</span><br><span class="line">   #6 = Class              #22            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               main</span><br><span class="line">  #12 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #13 = Utf8               SourceFile</span><br><span class="line">  #14 = Utf8               Demo1.java</span><br><span class="line">  #15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 = Class              #23            // java/lang/System</span><br><span class="line">  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;</span><br><span class="line">  #18 = Utf8               hello world</span><br><span class="line">  #19 = Class              #26            // java/io/PrintStream</span><br><span class="line">  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               com/nyima/JVM/day5/Demo1</span><br><span class="line">  #22 = Utf8               java/lang/Object</span><br><span class="line">  #23 = Utf8               java/lang/System</span><br><span class="line">  #24 = Utf8               out</span><br><span class="line">  #25 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #26 = Utf8               java/io/PrintStream</span><br><span class="line">  #27 = Utf8               println</span><br><span class="line">  #28 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.nyima.JVM.day5.Demo1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3_1 &#123;    </span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        int a = 10;        </span><br><span class="line">        int b = Short.MAX_VALUE + 1;        </span><br><span class="line">        int c = a + b;        </span><br><span class="line">        System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" alt="img"></a></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" alt="img"></a></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><p>将一个 byte 压入操作数栈</p><p>（其长度会补齐 4 个字节），类似的指令还有</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" alt="img"></a></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" alt="img"></a></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" alt="img"></a></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" alt="img"></a></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" alt="img"></a></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" alt="img"></a></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" alt="img"></a></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" alt="img"></a></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" alt="img"></a></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p><p>生成新的栈帧（分配 locals、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" alt="img"></a></p><p>执行完毕，弹出栈帧</p><p>清除 main 操作数栈内容</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" alt="img"></a></p><p><strong>return</strong> 完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i=0;</span><br><span class="line">        int x=0;</span><br><span class="line">        while(i&lt;10) &#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x); //接过为0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=3, args_size=1 //操作数栈分配2个空间，局部变量表分配3个空间</span><br><span class="line">        0: iconst_0 //准备一个常数0</span><br><span class="line">        1: istore_1 //将常数0放入局部变量表的1号槽位 i=0</span><br><span class="line">        2: iconst_0 //准备一个常数0</span><br><span class="line">        3: istore_2 //将常数0放入局部变量的2号槽位 x=0   </span><br><span class="line">        4: iload_1      //将局部变量表1号槽位的数放入操作数栈中</span><br><span class="line">        5: bipush        10 //将数字10放入操作数栈中，此时操作数栈中有2个数</span><br><span class="line">        7: if_icmpge     21 //比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span><br><span class="line">       10: iload_2      //将局部变量2号槽位的数放入操作数栈中，放入的值是0</span><br><span class="line">       11: iinc          2, 1   //将局部变量2号槽位的数加1，自增后，槽位中的值为1</span><br><span class="line">       14: istore_2 //将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span><br><span class="line">       15: iinc          1, 1 //1号槽位的值自增1</span><br><span class="line">       18: goto          4 //跳转到第4条指令</span><br><span class="line">       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       24: iload_2</span><br><span class="line">       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       28: return</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">    static int i = 10;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        i = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        i = 30;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(i); //结果为30</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack=1, locals=0, args_size=0</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: putstatic     #3                  // Field i:I</span><br><span class="line">         5: bipush        20</span><br><span class="line">         7: putstatic     #3                  // Field i:I</span><br><span class="line">        10: bipush        30</span><br><span class="line">        12: putstatic     #3                  // Field i:I</span><br><span class="line">        15: return</span><br></pre></td></tr></table></figure><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">    private String a = &quot;s1&quot;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int b = 10;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = &quot;s2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Demo4(String a, int b) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo4 d = new Demo4(&quot;s3&quot;, 30);</span><br><span class="line">        System.out.println(d.a);</span><br><span class="line">        System.out.println(d.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=3, args_size=3</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        4: aload_0</span><br><span class="line">        5: ldc           #2                  // String s1</span><br><span class="line">        7: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">       10: aload_0</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: putfield      #4                  // Field b:I</span><br><span class="line">       16: aload_0</span><br><span class="line">       17: bipush        10</span><br><span class="line">       19: putfield      #4                  // Field b:I</span><br><span class="line">       22: aload_0</span><br><span class="line">       23: ldc           #5                  // String s2</span><br><span class="line">       25: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">       //原始构造方法在最后执行</span><br><span class="line">       28: aload_0</span><br><span class="line">       29: aload_1</span><br><span class="line">       30: putfield      #3                  // Field a:Ljava/lang/String;</span><br><span class="line">       33: aload_0</span><br><span class="line">       34: iload_2</span><br><span class="line">       35: putfield      #4                  // Field b:I</span><br><span class="line">       38: return</span><br></pre></td></tr></table></figure><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public Demo5() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test1() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final void test2() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test3() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test4() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo5 demo5 = new Demo5();</span><br><span class="line">        demo5.test1();</span><br><span class="line">        demo5.test2();</span><br><span class="line">        demo5.test3();</span><br><span class="line">        Demo5.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class com/JVM/Demo5 </span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: invokespecial #4                  // Method test1:()V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: invokespecial #5                  // Method test2:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #6                  // Method test3:()V</span><br><span class="line">        20: invokestatic  #7                  // Method test4:()V</span><br><span class="line">        23: return</span><br></pre></td></tr></table></figure><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            i = 10;</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            i = 20;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        5: goto          12</span><br><span class="line">        8: astore_2</span><br><span class="line">        9: bipush        20</span><br><span class="line">       11: istore_1</span><br><span class="line">       12: return</span><br><span class="line">     //多出来一个异常表</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5     8   Class java/lang/Exception</span><br></pre></td></tr></table></figure><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            i = 10;</span><br><span class="line">        &#125;catch (ArithmeticException e) &#123;</span><br><span class="line">            i = 20;</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            i = 30;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        5: goto          19</span><br><span class="line">        8: astore_2</span><br><span class="line">        9: bipush        20</span><br><span class="line">       11: istore_1</span><br><span class="line">       12: goto          19</span><br><span class="line">       15: astore_2</span><br><span class="line">       16: bipush        30</span><br><span class="line">       18: istore_1</span><br><span class="line">       19: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5     8   Class java/lang/ArithmeticException</span><br><span class="line">            2     5    15   Class java/lang/Exception</span><br></pre></td></tr></table></figure><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            i = 10;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            i = 20;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            i = 30;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=4, args_size=1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        //try块</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        //try块执行完后，会执行finally    </span><br><span class="line">        5: bipush        30</span><br><span class="line">        7: istore_1</span><br><span class="line">        8: goto          27</span><br><span class="line">       //catch块     </span><br><span class="line">       11: astore_2 //异常信息放入局部变量表的2号槽位</span><br><span class="line">       12: bipush        20</span><br><span class="line">       14: istore_1</span><br><span class="line">       //catch块执行完后，会执行finally        </span><br><span class="line">       15: bipush        30</span><br><span class="line">       17: istore_1</span><br><span class="line">       18: goto          27</span><br><span class="line">       //出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span><br><span class="line">       21: astore_3</span><br><span class="line">       22: bipush        30</span><br><span class="line">       24: istore_1</span><br><span class="line">       25: aload_3</span><br><span class="line">       26: athrow  //抛出异常</span><br><span class="line">       27: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5    11   Class java/lang/Exception</span><br><span class="line">            2     5    21   any</span><br><span class="line">           11    15    21   any</span><br></pre></td></tr></table></figure><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = Demo3.test();</span><br><span class="line">        //结果为20</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int test() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        try &#123;</span><br><span class="line">            i = 10;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            i = 20;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=0</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_0</span><br><span class="line">        3: iload_0</span><br><span class="line">        4: istore_1  //暂存返回值</span><br><span class="line">        5: bipush        20</span><br><span class="line">        7: istore_0</span><br><span class="line">        8: iload_0</span><br><span class="line">        9: ireturn  //ireturn会返回操作数栈顶的整型值20</span><br><span class="line">       //如果出现异常，还是会执行finally块中的内容，没有抛出异常</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: istore_0</span><br><span class="line">       14: iload_0</span><br><span class="line">       15: ireturn  //这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            0     5    10   any</span><br></pre></td></tr></table></figure><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int i = Demo3.test();</span><br><span class="line">      //最终结果为20</span><br><span class="line">      System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static int test() &#123;</span><br><span class="line">      int i;</span><br><span class="line">      try &#123;</span><br><span class="line">         i = 10;</span><br><span class="line">         //这里应该会抛出异常</span><br><span class="line">         i = i/0;</span><br><span class="line">         return i;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         i = 20;</span><br><span class="line">         return i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = Demo4.test();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int test() &#123;</span><br><span class="line">        int i = 10;</span><br><span class="line">        try &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            i = 20;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=1, locals=3, args_size=0</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_0 //赋值给i 10</span><br><span class="line">        3: iload_0  //加载到操作数栈顶</span><br><span class="line">        4: istore_1 //加载到局部变量表的1号位置</span><br><span class="line">        5: bipush        20</span><br><span class="line">        7: istore_0 //赋值给i 20</span><br><span class="line">        8: iload_1 //加载局部变量表1号位置的数10到操作数栈</span><br><span class="line">        9: ireturn //返回操作数栈顶元素 10</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: istore_0</span><br><span class="line">       14: aload_2 //加载异常</span><br><span class="line">       15: athrow //抛出异常</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            3     5    10   any</span><br></pre></td></tr></table></figure><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 10;</span><br><span class="line">        Lock lock = new Lock();</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lock&#123;&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=2, locals=5, args_size=1</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_1</span><br><span class="line">        3: new           #2                  // class com/JVM/Lock</span><br><span class="line">        6: dup //复制一份，放到操作数栈顶，用于构造函数消耗</span><br><span class="line">        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       10: astore_2 //剩下的一份放到局部变量表的2号位置</span><br><span class="line">       11: aload_2 //加载到操作数栈</span><br><span class="line">       12: dup //复制一份，放到操作数栈，用于加锁时消耗</span><br><span class="line">       13: astore_3 //将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span><br><span class="line">       14: monitorenter //加锁</span><br><span class="line">       //锁住后代码块中的操作    </span><br><span class="line">       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       18: iload_1</span><br><span class="line">       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       //加载局部变量表中三号槽位对象的引用，用于解锁    </span><br><span class="line">       22: aload_3    </span><br><span class="line">       23: monitorexit //解锁</span><br><span class="line">       24: goto          34</span><br><span class="line">       //异常操作    </span><br><span class="line">       27: astore        4</span><br><span class="line">       29: aload_3</span><br><span class="line">       30: monitorexit //解锁</span><br><span class="line">       31: aload         4</span><br><span class="line">       33: athrow</span><br><span class="line">       34: return</span><br><span class="line">     //可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           15    24    27   any</span><br><span class="line">           27    31    27   any</span><br></pre></td></tr></table></figure><h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <em>.java 源码编译为 <em>.class 字节码的过程中，</em></em>自动生成<strong>和</strong>转换**的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Candy1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译期优化后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Candy1 &#123;</span><br><span class="line">   //这个无参构造器是java编译器帮我们加上的</span><br><span class="line">   public Candy1() &#123;</span><br><span class="line">      //即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span><br><span class="line">      super();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Integer x = 1;</span><br><span class="line">      int y = x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换过程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      //基本类型赋值给包装类型，称为装箱</span><br><span class="line">      Integer x = Integer.valueOf(1);</span><br><span class="line">      //包装类型赋值给基本类型，称谓拆箱</span><br><span class="line">      int y = x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">      list.add(10);</span><br><span class="line">      Integer x = list.get(0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=2, locals=3, args_size=1</span><br><span class="line">       0: new           #2                  // class java/util/ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: bipush        10</span><br><span class="line">      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">      //这里进行了泛型擦除，实际调用的是add(Objcet o)</span><br><span class="line">      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span><br><span class="line"></span><br><span class="line">      19: pop</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      //这里也进行了泛型擦除，实际调用的是get(Object o)   </span><br><span class="line">      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">//这里进行了类型转换，将Object转换成了Integer</span><br><span class="line">      27: checkcast     #7                  // class java/lang/Integer</span><br><span class="line">      30: astore_2</span><br><span class="line">      31: return</span><br></pre></td></tr></table></figure><p>所以调用get函数取值时，有一个类型转换的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = (Integer) list.get(0);</span><br></pre></td></tr></table></figure><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x = (Integer) list.get(0).intValue();</span><br></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">   public static void foo(String... args) &#123;</span><br><span class="line">      //将args赋值给arr，可以看出String...实际就是String[] </span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      foo(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">   public Demo4 &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   public static void foo(String[] args) &#123;</span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //数组赋初值的简化写法也是一种语法糖。</span><br><span class="line">        int[] arr = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">        for(int x : arr) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会帮我们转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public Demo5 &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = new int[]&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">        for(int i=0; i&lt;arr.length; ++i) &#123;</span><br><span class="line">            int x = arr[i];</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果是集合使用foreach</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">      for (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public Demo5 &#123;&#125;</span><br><span class="line">    </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">      //获得该集合的迭代器</span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      while(iterator.hasNext()) &#123;</span><br><span class="line">         Integer x = iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      String str = &quot;hello&quot;;</span><br><span class="line">      switch (str) &#123;</span><br><span class="line">         case &quot;hello&quot; :</span><br><span class="line">            System.out.println(&quot;h&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &quot;world&quot; :</span><br><span class="line">            System.out.println(&quot;w&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译器中执行的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">   public Demo6() &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      String str = &quot;hello&quot;;</span><br><span class="line">      int x = -1;</span><br><span class="line">      //通过字符串的hashCode+value来判断是否匹配</span><br><span class="line">      switch (str.hashCode()) &#123;</span><br><span class="line">         //hello的hashCode</span><br><span class="line">         case 99162322 :</span><br><span class="line">            //再次比较，因为字符串的hashCode有可能相等</span><br><span class="line">            if(str.equals(&quot;hello&quot;)) &#123;</span><br><span class="line">               x = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">         //world的hashCode</span><br><span class="line">         case 11331880 :</span><br><span class="line">            if(str.equals(&quot;world&quot;)) &#123;</span><br><span class="line">               x = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //用第二个switch在进行输出判断</span><br><span class="line">      switch (x) &#123;</span><br><span class="line">         case 0:</span><br><span class="line">            System.out.println(&quot;h&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case 1:</span><br><span class="line">            System.out.println(&quot;w&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      switch (sex) &#123;</span><br><span class="line">         case MALE:</span><br><span class="line">            System.out.println(&quot;man&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case FEMALE:</span><br><span class="line">            System.out.println(&quot;woman&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器中执行的代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">   /**     </span><br><span class="line">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="line">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="line">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="line">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><br><span class="line">    */ </span><br><span class="line">   static class $MAP &#123;</span><br><span class="line">      //数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br><span class="line">      static int[] map = new int[2];</span><br><span class="line">      static &#123;</span><br><span class="line">         //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br><span class="line">         map[SEX.MALE.ordinal()] = 1;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = 2;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      //将对应位置枚举元素的值赋给x，用于case操作</span><br><span class="line">      int x = $MAP.map[sex.ordinal()];</span><br><span class="line">      switch (x) &#123;</span><br><span class="line">         case 1:</span><br><span class="line">            System.out.println(&quot;man&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case 2:</span><br><span class="line">            System.out.println(&quot;woman&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final class Sex extends Enum&lt;Sex&gt; &#123;   </span><br><span class="line">   //对应枚举类中的元素</span><br><span class="line">   public static final Sex MALE;    </span><br><span class="line">   public static final Sex FEMALE;    </span><br><span class="line">   private static final Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    static &#123;       </span><br><span class="line">        //调用构造函数，传入枚举元素的值及ordinal</span><br><span class="line">        MALE = new Sex(&quot;MALE&quot;, 0);    </span><br><span class="line">        FEMALE = new Sex(&quot;FEMALE&quot;, 1);   </span><br><span class="line">        $VALUES = new Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   //调用父类中的方法</span><br><span class="line">    private Sex(String name, int ordinal) &#123;     </span><br><span class="line">        super(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public static Sex[] values() &#123;  </span><br><span class="line">        return $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    public static Sex valueOf(String name) &#123; </span><br><span class="line">        return Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Runnable runnable = new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(&quot;running...&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      //用额外创建的类来创建匿名内部类对象</span><br><span class="line">      Runnable runnable = new Demo8$1();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建了一个额外的类，实现了Runnable接口</span><br><span class="line">final class Demo8$1 implements Runnable &#123;</span><br><span class="line">   public Demo8$1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;running...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果匿名内部类中引用了<strong>局部变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int x = 1;</span><br><span class="line">      Runnable runnable = new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int x = 1;</span><br><span class="line">      Runnable runnable = new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Demo8$1 implements Runnable &#123;</span><br><span class="line">   //多创建了一个变量</span><br><span class="line">   int val$x;</span><br><span class="line">   //变为了有参构造器</span><br><span class="line">   public Demo8$1(int x) &#123;</span><br><span class="line">      this.val$x = x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(val$x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li><p>将类的字节码载入</p><p>方法区</p><p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></a></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">      ClassLoader loader = Demo1.class.getClassLoader();</span><br><span class="line">      //只加载不解析</span><br><span class="line">      Class&lt;?&gt; c = loader.loadClass(&quot;com.nyima.JVM.day8.C&quot;);</span><br><span class="line">      //用于阻塞主线程</span><br><span class="line">      System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">   D d = new D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><ul><li>打开HSDB</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp F:\JAVA\JDK8.0\lib\sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" alt="img"></a></p><ul><li>定位需要的进程</li></ul><p><a href><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" alt="img"></a></p><p><a href><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" alt="img"></a></p><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><a href><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" alt="img"></a></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" alt="img"></a></p><ul><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p><ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" alt="img"></a></p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" alt="img"></a></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" alt="img"></a></p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // 首先查找该类是否已经被该类加载器加载过了</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        //如果没有被加载过</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //看是否被启动类加载器加载过</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">                //捕获异常，但不做任何处理</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br><span class="line">                //然后让应用类加载器去找classpath下找该类</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // 记录时间</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术，降低GC次数</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void doSomething() &#123;  </span><br><span class="line">        // to do something  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int add4(int x1, int x2, int x3, int x4) &#123; </span><br><span class="line">        //这里调用了add2方法</span><br><span class="line">        return add2(x1, x2) + add2(x3, x4);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private int add2(int x1, int x2) &#123;  </span><br><span class="line">        return x1 + x2;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法调用被替换后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private int add4(int x1, int x2, int x3, int x4) &#123;  </span><br><span class="line">        //被替换为了方法本身</span><br><span class="line">        return x1 + x2 + x3 + x4;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Reflect1 &#123;</span><br><span class="line">   public static void foo() &#123;</span><br><span class="line">      System.out.println(&quot;foo...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      Method foo = Demo3.class.getMethod(&quot;foo&quot;);</span><br><span class="line">      for(int i = 0; i&lt;=16; i++) &#123;</span><br><span class="line">         foo.invoke(null);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">    throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    if (!override) &#123;</span><br><span class="line">        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br><span class="line">    MethodAccessor ma = methodAccessor;             // read volatile</span><br><span class="line">    if (ma == null) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    return ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" alt="img"></a></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class NativeMethodAccessorImpl extends MethodAccessorImpl &#123;</span><br><span class="line">    private final Method method;</span><br><span class="line">    private DelegatingMethodAccessorImpl parent;</span><br><span class="line">    private int numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        this.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br><span class="line">    //如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br><span class="line">    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());</span><br><span class="line">            this.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return invoke0(this.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setParent(DelegatingMethodAccessorImpl var1) &#123;</span><br><span class="line">        this.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static native Object invoke0(Method var0, Object var1, Object[] var2);</span><br><span class="line">&#125;</span><br><span class="line">//ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="line">private static int inflationThreshold = 15;</span><br></pre></td></tr></table></figure><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><a href><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/20200614135011.png?lastModify=1617799693" alt="img"></a></p><h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障。与1中内存模型不同。</p><h2 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h2><p>原子性在学习线程时讲过，下面来个例子简单回顾一下： 问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？ </p><h2 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h2><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操 作。 例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i // 获取静态变量i的值</span><br><span class="line">iconst_1 // 准备常量1</span><br><span class="line">iadd // 加法</span><br><span class="line">putstatic i // 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure><p>对i–而言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i // 获取静态变量i的值</span><br><span class="line">iconst_1 // 准备常量1</span><br><span class="line">isub // 减法</span><br><span class="line">putstatic i // 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure><p><img src="file://C:/Users/%E9%99%88%E7%90%AA/Desktop/app/%E6%96%87%E6%A1%A3/%E7%AC%94%E8%AE%B0/jvm/jmm.png?lastModify=1617799693" alt="img"></p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 假设i的初始值为0</span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1 // 线程1-准备常量1</span><br><span class="line">iadd // 线程1-自增 线程内i=1</span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=1</span><br><span class="line">iconst_1 // 线程1-准备常量1</span><br><span class="line">isub // 线程1-自减 线程内i=0</span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=0</span><br></pre></td></tr></table></figure><p>但多线程下这 8 行代码可能交错运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 假设i的初始值为0</span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">getstatic i // 线程2-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1 // 线程1-准备常量1</span><br><span class="line">iadd // 线程1-自增 线程内i=1</span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><span class="line">iconst_1 // 线程2-准备常量1</span><br><span class="line">isub // 线程2-自减 线程内i=-1</span><br><span class="line">putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></pre></td></tr></table></figure><p>出现正数的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 假设i的初始值为0</span><br><span class="line">getstatic i // 线程1-获取静态变量i的值 线程内i=0</span><br><span class="line">getstatic i // 线程2-获取静态变量i的值 线程内i=0</span><br><span class="line">iconst_1 // 线程1-准备常量1</span><br><span class="line">iadd // 线程1-自增 线程内i=1</span><br><span class="line">iconst_1 // 线程2-准备常量1</span><br><span class="line">isub // 线程2-自减 线程内i=-1</span><br><span class="line">putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br><span class="line">putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-问题解决"><a href="#1-3-问题解决" class="headerlink" title="1.3 问题解决"></a>1.3 问题解决</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;h2 id=&quot;1、JVM&quot;&gt;&lt;a href=&quot;#1、JVM&quot; class=&quot;headerlink&quot; title=&quot;1、JVM&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://cenkii.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>GloVe</title>
    <link href="https://cenkii.github.io/2020/10/05/GloVe/"/>
    <id>https://cenkii.github.io/2020/10/05/GloVe/</id>
    <published>2020-10-05T12:40:34.000Z</published>
    <updated>2020-10-11T13:54:37.624Z</updated>
    
    <content type="html"><![CDATA[<p>对于word2vec和fast text而言，它们只考虑了局部的词信息。而GloVe是一个基于全局词频统计（count-based &amp; overall statistics）的词表征（word representation）工具。</p><h3 id="1、GloVe的实现步骤"><a href="#1、GloVe的实现步骤" class="headerlink" title="1、GloVe的实现步骤"></a>1、GloVe的实现步骤</h3><p>GloVe主要分以下几步1. 统计共现矩阵 2. 训练词向量</p><p>1.共现矩阵</p><p>举个例子：</p><ul><li>i love you</li><li>you love he</li><li>he love me</li></ul><p>设滑动窗口为2时，可以得到以下字典</p><p>{“i love”,”love you”,“you love”,”love he”,”he love”,”love me”}</p><p>共现矩阵如下：</p><table><thead><tr><th></th><th>i</th><th>you</th><th>he</th><th>love</th><th>me</th></tr></thead><tbody><tr><td>i</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>you</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>he</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>love</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>me</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>一般而言，这个次数的最小单位是1，但是GloVe不这么认为：它根据两个单词在上下文窗口的距离d，提出了一个衰减函数（decreasing weighting）：deacy= 1/d 用于计算权重，也就是说<strong>距离越远的两个单词所占总计数（total count）的权重越小。</strong></p><p>2.词向量训练</p><p>构建词向量（Word Vector）和共现矩阵（Co-ocurrence Matrix）之间的近似关系，论文的作者提出以下的公式可以近似地表达两者之间的关系：<br>$$<br>w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} = \log(X_{ij}) \tag{1}<br>$$<br>其中，<strong>wi和wj是我们最终要求解的词向量；</strong>bi和bj分别是两个词向量的bias term。</p><p>进一步构造loss函数如下：<br>$$<br>J = \sum_{i,j=1}^{V} f(X_{ij})(w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} – \log(X_{ij}) )^2 \tag{2}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于word2vec和fast text而言，它们只考虑了局部的词信息。而GloVe是一个基于全局词频统计（count-based &amp;amp; overall statistics）的词表征（word representation）工具。&lt;/p&gt;
&lt;h3 id=&quot;1、Glo
      
    
    </summary>
    
    
    
      <category term="nlp" scheme="https://cenkii.github.io/tags/nlp/"/>
    
  </entry>
  
  <entry>
    <title>FastText</title>
    <link href="https://cenkii.github.io/2020/10/02/FastText/"/>
    <id>https://cenkii.github.io/2020/10/02/FastText/</id>
    <published>2020-10-02T14:42:51.000Z</published>
    <updated>2020-10-05T09:47:22.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、fasttext"><a href="#1、fasttext" class="headerlink" title="1、fasttext"></a>1、fasttext</h3><p>fasttext是Facebook于2016年开源的一个词向量计算和文本分类工具，在学术上并没有太大创新。它的结构与word2vec中的CBOW类似。与其不同的是在CBOW模型中把每个单词当作一个原子看待没有考虑单词内部的形态特征，例如对于两个很相近的单词book和books，我们会用两个向量表示。而fasttext提出了子词嵌⼊(subword embedding)的⽅法，从而试图将构词信息即内部结构和形成⽅式引⼊word2vec中的CBOW。</p><span id="more"></span><h3 id="2、子词嵌入"><a href="#2、子词嵌入" class="headerlink" title="2、子词嵌入"></a>2、子词嵌入</h3><p>fasttext提出了子词嵌⼊(subword embedding)的⽅法，那么怎么实现子词嵌入呢？</p><p>fasttext使用了字符级别的n-grams来表示一个单词。</p><p>例如：对于book和books而言用3-gram表示可以写为</p><p>book : “&lt;bo”,”boo”,”ook”,”ok&gt;”</p><p>books : “&lt;bo”,”boo”,”ook”,”oks”,”ks&gt;”</p><p>其中，&lt;表示前缀，&gt;表示后缀。</p><p>1、对于低频词生成的词向量效果会更好。因为它们的n-gram可以和其它词共享。</p><p>2、对于训练词库之外的单词，仍然可以构建它们的词向量。我们可以叠加它们的字符级n-gram向量。</p><h3 id="3、fasttext架构"><a href="#3、fasttext架构" class="headerlink" title="3、fasttext架构"></a>3、fasttext架构</h3><p><img src="/2020/10/02/FastText/v2-7f38f23e98ee89d21fd16e34d5f07d69_r.png" alt></p><p>和CBOW一样，fastText模型也只有三层：输入层、隐含层、输出层（Hierarchical Softmax），输入都是多个经向量表示的单词，输出都是一个特定的target，隐含层都是对多个词向量的叠加平均。不同的是，CBOW的输入是目标单词的上下文，fastText的输入是多个单词及其n-gram特征，这些特征用来表示单个文档；CBOW的输入单词被onehot编码过，fastText的输入特征是被embedding过；CBOW的输出是目标词汇的概率，fastText的输出是文档对应的类标。fastText在输入时，将单词的字符级别的n-gram向量作为额外的特征；在输出时，fastText采用了分层Softmax，大大降低了模型训练时间。</p><p>fastText的核心思想就是：将整篇文档的词及n-gram向量叠加平均得到文档向量，然后使用文档向量做softmax多分类。</p><p>fasttext分类效果较好原因主要有两点：</p><p>1、使用词embedding而非词本身作为特征。</p><p>2、字符级n-gram特征的引入对分类效果会有一些提升 。</p><h3 id="4-fastText与Word2Vec的异同"><a href="#4-fastText与Word2Vec的异同" class="headerlink" title="4. fastText与Word2Vec的异同"></a>4. fastText与Word2Vec的异同</h3><p><strong>相同点</strong>：</p><ul><li>图模型结构很像，都是采用embedding向量的形式，得到word的隐向量表达。</li><li>都采用很多相似的优化方法，比如使用Hierarchical softmax优化训练和预测中的打分速度。</li></ul><p>之前一直不明白fasttext用层次softmax时叶子节点是啥，CBOW很清楚，它的叶子节点是词和词频，后来看了源码才知道，其实fasttext叶子节点里是类标和类标的频数。</p><table><thead><tr><th></th><th>Word2Vec</th><th>fastText</th></tr></thead><tbody><tr><td>输入</td><td>one-hot形式的单词的向量</td><td>embedding过的单词的词向量和n-gram向量</td></tr><tr><td>输出</td><td>对应的是每一个term,计算某term概率最大</td><td>对应的是分类的标签。</td></tr></tbody></table><p><strong>本质不同，体现在softmax的使用：</strong></p><p>word2vec的目的是得到词向量，该词向量最终是在输入层得到的，输出层对应的h-softmax也会生成一系列的向量，但是最终都被抛弃，不会使用。</p><p>fastText则充分利用了h-softmax的分类功能，遍历分类树的所有叶节点，找到概率最大的label</p><p><strong>fastText优点</strong>：</p><ol><li><strong>适合大型数据+高效的训练速度</strong>：能够训练模型“在使用标准多核CPU的情况下10分钟内处理超过10亿个词汇”</li><li><strong>支持多语言表达</strong>：利用其语言形态结构，fastText能够被设计用来支持包括英语、德语、西班牙语、法语以及捷克语等多种语言。FastText的性能要比时下流行的word2vec工具明显好上不少，也比其他目前最先进的词态词汇表征要好。</li><li><strong>专注于文本分类</strong>，在许多标准问题上实现当下最好的表现（例如文本倾向性分析或标签预测）。</li></ol><h3 id="5、简单实现fastText"><a href="#5、简单实现fastText" class="headerlink" title="5、简单实现fastText"></a>5、简单实现fastText</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vocab_size = <span class="number">30000</span> <span class="comment">#词表大小</span></span><br><span class="line">embedding_dim = <span class="number">128</span> <span class="comment">#embedding层向量长度</span></span><br><span class="line">sent_length = <span class="number">256</span> <span class="comment">#句子长度，如果长度不够补pad，否则截取到sent_length</span></span><br><span class="line">class_num = <span class="number">10</span> <span class="comment">#类别数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_fasttext</span>(<span class="params">vocab_size,embedding_dim,sent_length,class_num</span>):</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(tf.keras.layers.Embedding(vocab_size,embedding_dim,input_length=sent_length))</span><br><span class="line">    model.add(tf.keras.layers.GlobalAveragePooling1D())</span><br><span class="line">    model.add(tf.keras.layers.Dense(class_num,activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,optimizer=<span class="string">&#x27;SGD&#x27;</span>,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">model = build_fasttext(vocab_size,embedding_dim,sent_length,class_num)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">Model: <span class="string">&quot;sequential_1&quot;</span></span><br><span class="line">_________________________________________________________________</span><br><span class="line">Layer (<span class="built_in">type</span>)                 Output Shape              Param <span class="comment">#   </span></span><br><span class="line">=================================================================</span><br><span class="line">embedding (Embedding)        (<span class="literal">None</span>, <span class="number">256</span>, <span class="number">128</span>)          <span class="number">3840000</span>   </span><br><span class="line">_________________________________________________________________</span><br><span class="line">global_average_pooling1d (Gl (<span class="literal">None</span>, <span class="number">128</span>)               <span class="number">0</span>         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense (Dense)                (<span class="literal">None</span>, <span class="number">10</span>)                <span class="number">1290</span>      </span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">3</span>,<span class="number">841</span>,<span class="number">290</span></span><br><span class="line">Trainable params: <span class="number">3</span>,<span class="number">841</span>,<span class="number">290</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">_________________________________________________________________</span><br></pre></td></tr></table></figure><ol><li><p><strong>输入层（embedding层）</strong>。Embedding层的输入是一个batch的句子，每个句子由一个词汇索引序列构成。Embedding层将每个单词映射成embedding_dim维的向量。于是：input_shape=(batch_size, sent_length), output_shape=(batch_size,sent_length, embedding_dim)；</p></li><li><p><strong>隐含层（投影层）</strong>。投影层对一个文档中所有单词的向量进行叠加平均。这层的input_shape是Embedding层的output_shape，这层的output_shape=( batch_size, embedding_dim)；</p></li><li><p><strong>输出层（softmax层）</strong>。真实的fastText这层是Hierarchical Softmax，因为keras原生并没有支持Hierarchical Softmax，所以这里用Softmax代替。这层指定了class_num，对于一篇文档，输出层会产生class_num个概率值，分别表示此文档属于当前类的可能性。这层的output_shape=(batch_size, class_num)</p></li><li><p><strong>指定损失函数、优化器类型、评价指标，编译模型</strong>。损失函数我们设置为categorical_crossentropy，它就是我们上面所说的softmax回归的损失函数；优化器我们设置为SGD，表示随机梯度下降优化器；评价指标选择accuracy，表示精度。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、fasttext&quot;&gt;&lt;a href=&quot;#1、fasttext&quot; class=&quot;headerlink&quot; title=&quot;1、fasttext&quot;&gt;&lt;/a&gt;1、fasttext&lt;/h3&gt;&lt;p&gt;fasttext是Facebook于2016年开源的一个词向量计算和文本分类工具，在学术上并没有太大创新。它的结构与word2vec中的CBOW类似。与其不同的是在CBOW模型中把每个单词当作一个原子看待没有考虑单词内部的形态特征，例如对于两个很相近的单词book和books，我们会用两个向量表示。而fasttext提出了子词嵌⼊(subword embedding)的⽅法，从而试图将构词信息即内部结构和形成⽅式引⼊word2vec中的CBOW。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nlp" scheme="https://cenkii.github.io/tags/nlp/"/>
    
      <category term="深度学习，机器学习" scheme="https://cenkii.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>词嵌入</title>
    <link href="https://cenkii.github.io/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/"/>
    <id>https://cenkii.github.io/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/</id>
    <published>2020-09-20T02:59:28.000Z</published>
    <updated>2021-05-09T14:46:51.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h2><p>计算机在处理数据时需要先将词用数字向量的形式表示，而把词映射为向量的技术即为词嵌入。</p><h3 id="1、one-hot-编码"><a href="#1、one-hot-编码" class="headerlink" title="1、one hot 编码"></a>1、one hot 编码</h3><p>one hot编码即独热向量编码，他有两个特征：</p><p>1、向量由01组成</p><p>2、向量长度等于字典长度</p><span id="more"></span><p>例如：字典为   {我们，今天，昨天，去，爬山，游泳，又}</p><p>”今天“  对应的向量编码为  [0,1,0,0,0,0,0]</p><p>同理“我们”：[1,0,0,0,0,0,0]</p><p>对于onehot编码有以下缺点：</p><p>1、每个向量长度和字典长度一样，所以随着语料数增多，字典长度增加，会产生一个高维稀疏的矩阵</p><p>2、不能保留词与词之间的关系，例如“苹果”可能有两个意思，但他们的独热码向量是一样的</p><h3 id="2、词袋模型"><a href="#2、词袋模型" class="headerlink" title="2、词袋模型"></a>2、词袋模型</h3><p>将单词编码转换为句子编码，要用到词袋模型(Bag-of-words model)，即一个句子可以看作用一个袋子装着这些词的方式表现，这种表现方式不考虑文法以及词的顺序，有两种方式表示：</p><p>1、Boolean Representation</p><p>即只记录词是否在句子里出现，1为出现0为没出现</p><p>例如：我们/今天/去/游泳/又/去/爬山。</p><p>可表示为[1,1,0,1,1,1,1]</p><p>2、Count-based Representation</p><p>即记录每个词在句子里面出现的次数</p><p>例如：我们/今天/去/游泳/又/去/爬山。</p><p>可表示为[1,1,0,2,1,1,1]</p><p>词袋模型有以下缺点：</p><p>1、词向量化后，词与词之间是有大小关系的，不一定词出现的越多，权重越大。</p><p>2、没有考虑文法以及词的顺序</p><h3 id="3、TF-IDF"><a href="#3、TF-IDF" class="headerlink" title="3、TF-IDF"></a>3、TF-IDF</h3><p><em>TF-IDF</em>（term frequency–inverse document frequency）是一种用于信息检索与数据挖掘的常用加权技术。TF是词频(Term Frequency)，IDF是逆文本频率指数(Inverse Document Frequency)。<br>$$<br>TF = \frac{n}{N}<br>$$</p><blockquote><p>n:词语出现的次数     N:该文件的总词语数</p></blockquote><p>$$<br>IDF = log(\frac{D}{d+1})<br>$$</p><blockquote><p>D:语料为文档总数      d:为包含词语的文档总数（为避免为0所以+1）</p></blockquote><p>$$<br>TF-IDF = TF*IDF<br>$$</p><p>在<em>TF-IDF</em>中字词的重要性随着它某个文档中出现的次数而增加，但随着在语料库中总文件数量的增加而减小。</p><p>但它的缺点还是没有将词语词之间的关系表现出来。</p><h3 id="4、n-gram模型"><a href="#4、n-gram模型" class="headerlink" title="4、n-gram模型"></a>4、n-gram模型</h3><p>n-gram模型中n即为一个窗口，即把n个词作为一组处理，然后向后移动，再取另外一组词，如此，生成字典，编码得到结果。</p><p>例如：我们/今天/去/游泳/又/去/爬山。</p><p>​            我们/今天/去/爬山。</p><p>以2-gram构造字典{“我们 今天”：1，“今天 去”：2，“去 游泳”：3，“游泳 又”：4，“又 去”：5，“去 爬山”：6}</p><p>两句的向量为：</p><p>[1,1,1,1,1,1]</p><p>[1,1,0,0,0,1]</p><p>n-gram模型考虑了词语词之间的顺序，但是随着语料数的增加，词表会越来越大。</p><h3 id="5-分布式表示"><a href="#5-分布式表示" class="headerlink" title="5.分布式表示"></a>5.分布式表示</h3><h4 id="5-1-NNLM"><a href="#5-1-NNLM" class="headerlink" title="5.1 NNLM"></a>5.1 NNLM</h4><p>NNLN即 (Neural Network Language model)，神经网络语言模型。</p><p>来源于  <a href="https://jmlr.org/papers/volume3/bengio03a/bengio03a.pdf">https://jmlr.org/papers/volume3/bengio03a/bengio03a.pdf</a></p><p>它的定义是通过一个前向窗口大小为n，选择n-1个词作为x，第n个词作为label。预测窗口中label的出现概率，最后取中间的词向量矩阵作为词向量。</p><p>例如：我们/今天/去/游泳/又/去/爬山。</p><p>n = 4   x即为（游泳  又  去）   y即为（爬山）</p><p><img src="/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/image-20200920105806829.png" alt="image-20200920105806829"></p><p>上述模型有四层，分别为输入层，投影层，隐藏层，输出层</p><p>输入层：将前n-1个词用onehot编码表示长度|V|</p><p>投影层：假设一个词用D维表示，投影层维度为 |V|×D，通过拼接后输入隐藏层</p><p>隐藏层：激活函数为tanh函数。</p><p>输出层：输出层为词n的概率</p><p>由上图可以看出，<strong>词</strong>是通过一个<strong>look-up表</strong>转化为<strong>词向量</strong>的，我们将这个look-up表称为表C。</p><p>look-up表即为下图</p><p><img src="/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/image-20200920222027446.png" alt="image-20200920222027446"></p><p>C矩阵是投影矩阵，look-up表，也就是稠密词向量表示，在神经网络中是<strong>w参数矩阵</strong>，该矩阵的大小为D<em>V，正好与input层进行全连接(相乘)得到D</em>1的矩阵，采用线性映射将one-hot表示投影到稠密D维表示。</p><p>C矩阵即为我们要求的词向量矩阵。</p><h4 id="5-2-word2vec"><a href="#5-2-word2vec" class="headerlink" title="5.2 word2vec"></a>5.2 word2vec</h4><p>word2vec是2013年提出的一个词嵌入模型。它实际是一种浅层的神经网络模型，有两种形式CBOW和和Skip-gram。</p><h5 id="5-2-1-CBOW"><a href="#5-2-1-CBOW" class="headerlink" title="5.2.1 CBOW"></a>5.2.1 CBOW</h5><p>CBOW通过上下文推理中心词，把中间词当做y，把窗口中的其它词当做x输入，x输入是经过one-hot编码过的，与上面的一样经过look-up表，然后通过一个隐层进行求和操作，最后通过激活函数softmax，可以计算出每个单词的生成概率，接下来的任务就是训练神经网络的权重，使得语料库中所有单词的整体生成概率最大化，而求得的权重矩阵即look-up表就是文本表示词向量的结果。</p><p><img src="/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/v2-d1ca2547dfb91bf6a26c60782a26aa02_r.jpg" alt="v2-d1ca2547dfb91bf6a26c60782a26aa02_r"></p><p>如上图CBOW模型有三层，分别是</p><p>输入层：输入层是一个C×V维的矩阵的one-hot向量，C为词的个数，V为词表的大小</p><p>隐藏层：通过与一个V×N维的W相乘得到一个C×N维的矩阵，通常通过上下文相加或平均将C×N维矩阵转换成1×N的向量。</p><p>输出层：将隐藏成1×N维矩阵，与N×V相乘得到形状1×V的向量。最后通过softmax函数得到中心词概率。</p><p>与上文一样训练出来取中间产物W作为词向量。</p><h5 id="5-2-2-Skip-gram"><a href="#5-2-2-Skip-gram" class="headerlink" title="5.2.2 Skip-gram"></a>5.2.2 Skip-gram</h5><p>与CBOW相反，Skip-gram是根据中心词推理上下文。把中间词当做x，把窗口中的其它词当做y，x输入是经过one-hot编码过的，与上面的一样经过look-up表，然后通过一个隐层进行求和操作，最后通过激活函数softmax，可以计算出每个单词的生成概率，接下来的任务就是训练神经网络的权重，使得语料库中所有单词的整体生成概率最大化，而求得的权重矩阵即look-up表就是文本表示词向量的结果。</p><p><img src="/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/v2-ca81e19caa378cee6d4ba6d867f4fc7c_r.png" alt="v2-ca81e19caa378cee6d4ba6d867f4fc7c_r"></p><p>如上图CBOW模型有三层，分别是</p><p>输入层：输入层是一个1×V维的one-hot向量，V为词表的大小</p><p>隐藏层：通过与一个V×N维的W相乘得到一个C×N维的矩阵，通常通过上下文相加或平均将C×N维矩阵转换成1×N的向量。</p><p>输出层：将隐藏成1×N维矩阵，与N×V相乘得到形状1×V的向量。最后通过softmax函数得到中心词预测上下文结果。</p><h4 id="5-2-3-弊端"><a href="#5-2-3-弊端" class="headerlink" title="5.2.3 弊端"></a>5.2.3 弊端</h4><p>1、词向量是基于局部信息训练的，不包含全局信息</p><p>2、每个词向量表示一个词，对于一词多义的词无法表示</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;词嵌入&quot;&gt;&lt;a href=&quot;#词嵌入&quot; class=&quot;headerlink&quot; title=&quot;词嵌入&quot;&gt;&lt;/a&gt;词嵌入&lt;/h2&gt;&lt;p&gt;计算机在处理数据时需要先将词用数字向量的形式表示，而把词映射为向量的技术即为词嵌入。&lt;/p&gt;
&lt;h3 id=&quot;1、one-hot-编码&quot;&gt;&lt;a href=&quot;#1、one-hot-编码&quot; class=&quot;headerlink&quot; title=&quot;1、one hot 编码&quot;&gt;&lt;/a&gt;1、one hot 编码&lt;/h3&gt;&lt;p&gt;one hot编码即独热向量编码，他有两个特征：&lt;/p&gt;
&lt;p&gt;1、向量由01组成&lt;/p&gt;
&lt;p&gt;2、向量长度等于字典长度&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nlp" scheme="https://cenkii.github.io/tags/nlp/"/>
    
      <category term="深度学习" scheme="https://cenkii.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>DBSCAN</title>
    <link href="https://cenkii.github.io/2020/05/29/DBSCAN/"/>
    <id>https://cenkii.github.io/2020/05/29/DBSCAN/</id>
    <published>2020-05-29T13:57:56.000Z</published>
    <updated>2020-06-08T10:25:28.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>dbscan是密度聚类的经典算法，此类算法假设聚类结构能够通过样本分布的密度紧密程度确定。它是基于一组邻域ε和其中的样本数MinPts来刻画样本分布的紧密程度。</p><p>下面先来了解几个概念：</p><span id="more"></span><p>例如，给定数据集D={x1,x2,…,xm}</p><p>ε-邻域：对于xj∈D，其邻域包含样本集D中距离与xj的距离不大于ε的样本即$N_ε = {x_i∈D|dist(x_i,x_j)≤ε}$</p><p>核心对象：若xj的邻域中包含最少MinPts个点则xj即为核心对象</p><p>密度直达：若xi在xj的邻域中则xi可由xj密度直达</p><p>密度可达：若存在x1,x2,x3, x1到x2密度直达，x2到x3密度直达，则x1到x3密度可达</p><p>密度相连：若有x1,x2,x3,x4,x5，若x3到x1密度可达，x3到x5密度可达，则x1和x5密度相连</p><p><img src="/2020/05/29/DBSCAN/image-20200529222607736.png" alt="image-20200529222607736"></p><h3 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2.算法步骤"></a>2.算法步骤</h3><p>1.将所有点标记为核心点、边界点或噪声点；<br>2.删除噪声点；<br>3.为距离在Eps之内的所有核心点之间赋予一条边；<br>4.每组连通的核心点形成一个簇；<br>5.将每个边界点指派到一个与之关联的核心点的簇中（哪一个核心点的半径范围之内）。</p><h3 id="3-算法实现（sklearn）"><a href="#3-算法实现（sklearn）" class="headerlink" title="3.算法实现（sklearn）"></a>3.算法实现（sklearn）</h3><p>用上一篇文章的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data_1 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">data_2 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">data_3 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">data = np.concatenate((data_1, data_2, data_3), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X_train, X_test = train_test_split(data, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> dbscan</span><br><span class="line">core,label = dbscan(X_train,min_samples=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], alpha=<span class="number">0.5</span>, c=label)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h3><p>下图为实验结果数据集与k-means中相同，下图中紫色的点为噪声点。可以看到将数据集划分成了两个簇，而在k-means中分成了3个簇，可见与k-means相比这个数据集中算法表现不算太好。</p><p><img src="/2020/05/29/DBSCAN/image-20200529223126811.png" alt="image-20200529223126811"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DBSCAN&quot;&gt;&lt;a href=&quot;#DBSCAN&quot; class=&quot;headerlink&quot; title=&quot;DBSCAN&quot;&gt;&lt;/a&gt;DBSCAN&lt;/h2&gt;&lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h3&gt;&lt;p&gt;dbscan是密度聚类的经典算法，此类算法假设聚类结构能够通过样本分布的密度紧密程度确定。它是基于一组邻域ε和其中的样本数MinPts来刻画样本分布的紧密程度。&lt;/p&gt;
&lt;p&gt;下面先来了解几个概念：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>影响力最大化——线性阈值</title>
    <link href="https://cenkii.github.io/2020/05/26/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E9%98%88%E5%80%BC/"/>
    <id>https://cenkii.github.io/2020/05/26/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E9%98%88%E5%80%BC/</id>
    <published>2020-05-26T14:27:08.000Z</published>
    <updated>2020-05-27T14:28:16.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性阈值模型"><a href="#线性阈值模型" class="headerlink" title="线性阈值模型"></a>线性阈值模型</h2><p>前面已经介绍过独立级联模型+贪心下面就用线性阈值模型和贪心算法来实现影响力最大化。</p><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h3><p>数据还是用前面的数据karate具体见上一篇</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_threshold</span>(<span class="params">G,seed,mc=<span class="number">1000</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#转换为有向图</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> G.is_directed():</span><br><span class="line">        G = G.to_directed()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置边权重 </span></span><br><span class="line">    a,b = <span class="built_in">zip</span>(*G.edges())</span><br><span class="line">    c = []</span><br><span class="line">    </span><br><span class="line">    ind = G.in_degree()</span><br><span class="line">    ind = <span class="built_in">dict</span>(ind)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">        c.append(<span class="number">1.0</span>/ind[i])</span><br><span class="line"></span><br><span class="line">    weight = <span class="built_in">zip</span>(a,b,c)</span><br><span class="line">    G.add_weighted_edges_from(weight)</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># 循环mc次得到平均结果</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(mc):</span><br><span class="line">        <span class="comment"># 初始化阈值与被影响力</span></span><br><span class="line">        np.random.seed(j)</span><br><span class="line">        p = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,G.number_of_nodes()+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> G.nodes:</span><br><span class="line">            G.nodes[i][<span class="string">&#x27;threshold&#x27;</span>] = p[i]</span><br><span class="line">            G.nodes[i][<span class="string">&#x27;influence&#x27;</span>] = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        activate_node = seed.copy()</span><br><span class="line">        new_active = seed.copy()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> new_active:</span><br><span class="line">            new_ones = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> G.neighbors(node):</span><br><span class="line">                G.nodes[i][<span class="string">&#x27;influence&#x27;</span>] += G.get_edge_data(node,i)[<span class="string">&#x27;weight&#x27;</span>]</span><br><span class="line">                <span class="keyword">if</span> (G.nodes[i][<span class="string">&#x27;influence&#x27;</span>] &gt; G.nodes[i][<span class="string">&#x27;threshold&#x27;</span>]) <span class="keyword">and</span> (i <span class="keyword">not</span> <span class="keyword">in</span> activate_node):</span><br><span class="line">                    new_ones.append(i)</span><br><span class="line">            new_active += new_ones</span><br><span class="line">            activate_node += new_ones</span><br><span class="line">        </span><br><span class="line">        result.append(<span class="built_in">len</span>(activate_node))</span><br><span class="line">    <span class="keyword">return</span> np.mean(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span>(<span class="params">g,k,p=<span class="number">0.1</span>,mc=<span class="number">1000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:  graph object, number of seed nodes</span></span><br><span class="line"><span class="string">    Output: optimal seed set, resulting spread, time for each iteration</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    S, spread, timelapse, start_time = [], [], [], time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Find k nodes with largest marginal gain</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Loop over nodes that are not yet in seed set to find biggest marginal gain</span></span><br><span class="line">        best_spread = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>,g.number_of_nodes()+<span class="number">1</span>))-<span class="built_in">set</span>(S):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the spread</span></span><br><span class="line">            s = linear_threshold(g,S + [j],mc)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Update the winning node and spread so far</span></span><br><span class="line">            <span class="keyword">if</span> s &gt; best_spread:</span><br><span class="line">                best_spread, node = s, j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add the selected node to the seed set</span></span><br><span class="line">        S.append(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Add estimated spread and elapsed time</span></span><br><span class="line">        spread.append(best_spread)</span><br><span class="line">        timelapse.append(time.time() - start_time)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(S,spread,timelapse)</span><br><span class="line"></span><br><span class="line">G = nx.read_gml(<span class="string">&quot;karate.gml&quot;</span>)</span><br><span class="line">greedy(G,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([34, 1], [13.232, 22.98], [8.593012809753418, 27.11247444152832])</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以看到两个模型的结果是完全一样的但时间缺差了许多</p><h3 id="影响力最大化系列"><a href="#影响力最大化系列" class="headerlink" title="影响力最大化系列"></a>影响力最大化系列</h3><p><a href="https://cenkii.github.io/2020/04/18/影响力最大化一/">影响力最大化——影响力测度</a></p><p><a href="https://cenkii.github.io/2020/04/29/IM2/">影响力最大化——节点影响力评估</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性阈值模型&quot;&gt;&lt;a href=&quot;#线性阈值模型&quot; class=&quot;headerlink&quot; title=&quot;线性阈值模型&quot;&gt;&lt;/a&gt;线性阈值模型&lt;/h2&gt;&lt;p&gt;前面已经介绍过独立级联模型+贪心下面就用线性阈值模型和贪心算法来实现影响力最大化。&lt;/p&gt;
&lt;h3 id=&quot;1-数据&quot;&gt;&lt;a href=&quot;#1-数据&quot; class=&quot;headerlink&quot; title=&quot;1.数据&quot;&gt;&lt;/a&gt;1.数据&lt;/h3&gt;&lt;p&gt;数据还是用前面的数据karate具体见上一篇&lt;/p&gt;
&lt;h3 id=&quot;2-代码实现&quot;&gt;&lt;a href=&quot;#2-代码实现&quot; class=&quot;headerlink&quot; title=&quot;2.代码实现&quot;&gt;&lt;/a&gt;2.代码实现&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="影响力最大化" scheme="https://cenkii.github.io/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>K-Means</title>
    <link href="https://cenkii.github.io/2020/05/23/K-Means/"/>
    <id>https://cenkii.github.io/2020/05/23/K-Means/</id>
    <published>2020-05-23T13:40:35.000Z</published>
    <updated>2020-05-29T14:35:56.030Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>k-means也是一种常用的机器学习，它的作用同样是分类，但与决策树，svm，knn等分类不同，k-means是一种无标签分类算法，称之为无监督分类，也叫聚类。</p><span id="more"></span><h3 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h3><p>K-Means算法是以距离作为相似度的评价指标，用样本点到类别中心的误差平方和作为聚类好坏的评价指标。总体误差即<br>$$<br>E = \sum_{i=1}^{k}\sum_{x∈C_i}||x-θ_i||<br>$$<br>其中 </p><p>$C_i$为簇，x为簇中的点</p><p>k为簇的个数</p><p>$θ_i$  为簇的中心点</p><p><img src="/2020/05/23/K-Means/image-20200529215901516.png" alt="image-20200529215901516"></p><p>通过迭代的方法使总体分类的误差平方和函数达到最小的聚类方法。</p><p>具体流程为：</p><blockquote><p>1、从集合(x1, x2, …, xn)中随机取k个元素，作为k个类别的各自的中心。</p><p>2、聚类。分别计算集合中每一个元素到k个类别中心的距离，将这些元素分别划归到距离最小的那一个类别中去，这个过程其实是一个重新聚类的过程。</p><p>3、更新类别中心。根据前面聚类的结果，重新计算每一个类别的中心，计算方法是取当前类别中所有元素，然后计算这些元素在每一个维度的平均值。每一个类别中心都重新计算一遍后，就得到了一个新的类别中心组 。</p><p>4、重复第2，3步，直到聚类结果不再发生变化，这样得到的类别中心，基本上就是我们最后想要找的类别中心。</p></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>k-means算法比较简单，但这个算法存在着问题，如下图</p><p><img src="/2020/05/23/K-Means/7312709-e975851b71638ab0.png" alt="img"></p><p>因为定义的初始节点是随机选择，所以很可能出现上面的情况。</p><p>解决方法</p><p>1.多计算几次取平均值</p><p>2.还有一种改进算法k-means++是更改中心点的选取，改进后方法如下：</p><pre><code>1. 随机选取中心点   2. 计算剩余所有点与中心点的距离，选择距离最短的</code></pre><p>$$<br>D(x^{(i)})=min[dist(x^{(i)},C_{1}),dist(x^{(i)},C_{2}),…,dist(x^{(i)},C_{n})]<br>$$</p><p>   可计算每个点被选的概率为<br>$$<br>\frac{D(x^{(i)})^{2}}{\sum{D(x^{(j)})^{2}}}<br>$$<br>​    3.重复计算直到算出k个点</p><p>通过上面的步骤可以看出通过对更改中心点的选取算法，可以看出距离中心点最近的点被选的概率越低。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data_1 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">data_2 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">data_3 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">data = np.concatenate((data_1, data_2, data_3), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">X_train, X_test = train_test_split(data, test_size=<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> k_means</span><br><span class="line"><span class="comment">#使用sklearn中的k_means进行聚类</span></span><br><span class="line"><span class="comment">#返回值为 簇中心值集 所属簇label 训练集中所有观测值的最接近的质心</span></span><br><span class="line"><span class="comment">#k_means中使用的算法是改进的k-means++</span></span><br><span class="line">cent_cur,label,inertia = k_means(X_train,n_clusters=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化</span></span><br><span class="line">plt.clf()</span><br><span class="line">plt.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], alpha=<span class="number">0.5</span>, c=label)</span><br><span class="line">plt.scatter(cent_cur[:, <span class="number">0</span>], cent_cur[:, <span class="number">1</span>], marker=<span class="string">&#x27;*&#x27;</span>, c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2020/05/23/K-Means/img.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h3&gt;&lt;p&gt;k-means也是一种常用的机器学习，它的作用同样是分类，但与决策树，svm，knn等分类不同，k-means是一种无标签分类算法，称之为无监督分类，也叫聚类。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>影响力最大化三——独立级联模型</title>
    <link href="https://cenkii.github.io/2020/05/11/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%89%E2%80%94%E2%80%94%E7%8B%AC%E7%AB%8B%E7%BA%A7%E8%81%94%E6%A8%A1%E5%9E%8B/"/>
    <id>https://cenkii.github.io/2020/05/11/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%89%E2%80%94%E2%80%94%E7%8B%AC%E7%AB%8B%E7%BA%A7%E8%81%94%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-05-11T13:44:00.000Z</published>
    <updated>2020-05-26T14:37:19.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="独立级联模型"><a href="#独立级联模型" class="headerlink" title="独立级联模型"></a>独立级联模型</h2><p>前面已经介绍过独立级联模型下面就用独立级联模型和贪心算法来实现影响力最大化。</p><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h3><p>数据主要使用karate.gml图中有34个点78条边</p><p>具体图形是酱婶的</p><span id="more"></span><p><img src="/2020/05/11/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%89%E2%80%94%E2%80%94%E7%8B%AC%E7%AB%8B%E7%BA%A7%E8%81%94%E6%A8%A1%E5%9E%8B/image-20200526215631109.png" alt="影响力最大化三图一"></p><h3 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2.贪心算法"></a>2.贪心算法</h3><ol><li>首先将遍历所有点找出最大影响力的点 加入S</li><li>如果只找一个点就可以结束了</li><li>否则，在剩下的点集中再找一个点并入S使影响力最大</li><li>重复直至点数满足需求</li></ol><h3 id="3-运行环境"><a href="#3-运行环境" class="headerlink" title="3.运行环境"></a>3.运行环境</h3><p>python 3.7</p><p>networkx 2.1</p><h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IC</span>(<span class="params">G, seeds, p=<span class="number">0.5</span>, epoch=<span class="number">1000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    input：</span></span><br><span class="line"><span class="string">    G：图</span></span><br><span class="line"><span class="string">    seeds：初始节点</span></span><br><span class="line"><span class="string">    p: 激活概率</span></span><br><span class="line"><span class="string">    epoch：循环圈数</span></span><br><span class="line"><span class="string">    return</span></span><br><span class="line"><span class="string">    output：影响力大小</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">        activate_node = seeds.copy()</span><br><span class="line">        new_active = seeds.copy()</span><br><span class="line">        <span class="keyword">while</span> new_active:</span><br><span class="line">            new_ones = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> new_active:</span><br><span class="line">                np.random.seed(i)       </span><br><span class="line">                l = <span class="built_in">list</span>(G.neighbors(node))</span><br><span class="line">                success = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(l)) &lt; p                </span><br><span class="line">                new_ones += <span class="built_in">list</span>(np.extract(success, l))</span><br><span class="line">            new_active = <span class="built_in">list</span>(<span class="built_in">set</span>(new_ones) - <span class="built_in">set</span>(activate_node))</span><br><span class="line">            activate_node += new_active</span><br><span class="line">        result.append(<span class="built_in">len</span>(activate_node))</span><br><span class="line">    <span class="keyword">return</span> np.mean(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span>(<span class="params">g,k,p=<span class="number">0.1</span>,mc=<span class="number">1000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:  graph object, number of seed nodes</span></span><br><span class="line"><span class="string">    Output: optimal seed set, resulting spread, time for each iteration</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    S, spread, timelapse, start_time = [], [], [], time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找k个点</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line"></span><br><span class="line">        best_spread = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>,g.number_of_nodes()+<span class="number">1</span>))-<span class="built_in">set</span>(S):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取影响力</span></span><br><span class="line">            s = IC(g,S + [j],p,mc)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 验证是否更好</span></span><br><span class="line">            <span class="keyword">if</span> s &gt; best_spread:</span><br><span class="line">                best_spread, node = s, j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将最大点加入S</span></span><br><span class="line">        S.append(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把影响力加入spread</span></span><br><span class="line">        spread.append(best_spread)</span><br><span class="line">        timelapse.append(time.time() - start_time)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(S,spread,timelapse)</span><br><span class="line"></span><br><span class="line">G = nx.read_gml(<span class="string">&quot;karate.gml&quot;</span>)</span><br><span class="line">greedy(G,<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-结果"><a href="#5-结果" class="headerlink" title="5.结果"></a>5.结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([34, 1], [4.2, 6.501], [2.748678207397461, 8.546141624450684])</span><br></pre></td></tr></table></figure><p>找到的两个点是34和1，影响力分别为4.2,和6.501，找第一个点耗费2.748678207397461第二个点耗费8.546141624450684秒</p><h3 id="影响力最大化系列"><a href="#影响力最大化系列" class="headerlink" title="影响力最大化系列"></a>影响力最大化系列</h3><p><a href="https://cenkii.github.io/2020/04/18/影响力最大化一/">影响力最大化——影响力测度</a></p><p><a href="https://cenkii.github.io/2020/04/29/IM2/">影响力最大化——节点影响力评估</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;独立级联模型&quot;&gt;&lt;a href=&quot;#独立级联模型&quot; class=&quot;headerlink&quot; title=&quot;独立级联模型&quot;&gt;&lt;/a&gt;独立级联模型&lt;/h2&gt;&lt;p&gt;前面已经介绍过独立级联模型下面就用独立级联模型和贪心算法来实现影响力最大化。&lt;/p&gt;
&lt;h3 id=&quot;1-数据&quot;&gt;&lt;a href=&quot;#1-数据&quot; class=&quot;headerlink&quot; title=&quot;1.数据&quot;&gt;&lt;/a&gt;1.数据&lt;/h3&gt;&lt;p&gt;数据主要使用karate.gml图中有34个点78条边&lt;/p&gt;
&lt;p&gt;具体图形是酱婶的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="影响力最大化" scheme="https://cenkii.github.io/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>IM2</title>
    <link href="https://cenkii.github.io/2020/04/29/IM2/"/>
    <id>https://cenkii.github.io/2020/04/29/IM2/</id>
    <published>2020-04-29T07:56:33.000Z</published>
    <updated>2020-05-26T14:24:16.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响力最大化——节点影响力评估"><a href="#影响力最大化——节点影响力评估" class="headerlink" title="影响力最大化——节点影响力评估"></a>影响力最大化——节点影响力评估</h2><p>当完成影响力节点的测度之后，接下来就需要对测度的节点进行评估，从而比较测度的方法的优劣。一般使用以下两种方式进行评估</p><h3 id="传播模型"><a href="#传播模型" class="headerlink" title="传播模型"></a>传播模型</h3><h4 id="1-传统传播模型"><a href="#1-传统传播模型" class="headerlink" title="1.传统传播模型"></a>1.传统传播模型</h4><p>由于信息是通过社会网络用户之间的交互传播的，这与传染病通过人与人接触传播的机制相似，所以传染病模型也可用来对信息传播过程（或者称影响力传播过程）建模。目前应用较广泛的传染病模型有：SI模型（Susceptible-Infected Model)、SIR模型（Susceptible-Infected-Recovered Model)、SIS 模型（Susceptible-Infected-Susceptible Model)。</p><span id="more"></span><p>（1)SI模型<br>SI模型刻画了最简单的情形。SI模型中有两种状态：易感状态S(Susceptible)和感染状态I(Infected)。初始时处于I状态的人以概率β，感染S的人，然后会成为I，去感染为S的人。</p><p>（2)SIR模型</p><p>SIR模型中会多一个R（Recovered）状态——恢复状态。在状态I以β概率感染S状态时，同时会以γ概率恢复为R状态，R状态不会继续去感染人，也不会被人感染。</p><p>（3)SIS模型</p><p>SIS模型中，处于恢复状态的人会再次被感染，也就是说当治愈后处于I状态的人会恢复为S状态。</p><h4 id="2-独立级联模型"><a href="#2-独立级联模型" class="headerlink" title="2.独立级联模型"></a>2.独立级联模型</h4><p>简称ICM，在该模型中，用户接受了解某信息后会将信息传播出去，则此节点处于激活态（active）。反之处于未激活态（inactive）。传播流程如下：</p><blockquote><ol><li>初始时（t=0），只有少量处于激活态，即为种子节点。</li><li>对t&gt;=1时刻，任意在t-1时刻被激活的节点<strong>有且仅有一次</strong>机会尝试以概率p激活所有未激活态邻居。</li><li>当多个节点同时激活一个未激活邻居时，这些节点激活顺序是随机的。</li><li>重复上述过程，直到不再有新增节点。</li></ol></blockquote><h4 id="3-线性阈值模型"><a href="#3-线性阈值模型" class="headerlink" title="3.线性阈值模型"></a>3.线性阈值模型</h4><p>与上述模型一样，节点也有激活态（active）和未激活态两种状态（inactive）。与ICM不同的是，在此模型中每个节点都要设置一个阈值0&lt;θ&lt;=1。网络中连接任意两个节点u,v之间的边都有权重，任意一个节点它的各个邻居节点的边的权重之和为1。每个已激活节点可以多次尝试激活，当权重之和达到阈值时，激活节点。</p><p>传播流程如下：</p><blockquote><ol><li>初始时（t=0），只有少量处于激活态，即为种子节点。</li><li>未激活节点会受激活节点影响</li><li>当未激活节点达到阈值时，激活节点，反之保持原态</li><li>重复上述过程，直到无新节点产生</li></ol></blockquote><h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><p>就网络攻击而言，就是看复杂网络中部分节点在经受网络攻击后，其网络的连通性以及信息的传输效率是否受到影响，网络的结构和功能被影响的越严重，表明受到攻击的网络节点也就越重要。网络攻击的方式一般分为随机攻击和蓄意攻击两类。其中，蓄意攻击的目标可以根据不同的节点影响力测度方法选出，通过评比不同方法选取的最大影响力节点在经过攻击后的网络脆弱性和稳定性，以此评选出较优的测度方法。此外，不同网络结构对于不 同的攻击具有不同的抗毁性和鲁棒性，如无标度网络对于随机攻击具有较高的鲁棒性，而对蓄意攻击则显得异常脆弱。</p><h3 id="影响力最大化系列"><a href="#影响力最大化系列" class="headerlink" title="影响力最大化系列"></a>影响力最大化系列</h3><p><a href="https://cenkii.github.io/2020/04/18/影响力最大化一/">影响力最大化——影响力测度</a></p><p><a href="https://cenkii.github.io/2020/04/29/IM2/">影响力最大化——节点影响力评估</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;影响力最大化——节点影响力评估&quot;&gt;&lt;a href=&quot;#影响力最大化——节点影响力评估&quot; class=&quot;headerlink&quot; title=&quot;影响力最大化——节点影响力评估&quot;&gt;&lt;/a&gt;影响力最大化——节点影响力评估&lt;/h2&gt;&lt;p&gt;当完成影响力节点的测度之后，接下来就需要对测度的节点进行评估，从而比较测度的方法的优劣。一般使用以下两种方式进行评估&lt;/p&gt;
&lt;h3 id=&quot;传播模型&quot;&gt;&lt;a href=&quot;#传播模型&quot; class=&quot;headerlink&quot; title=&quot;传播模型&quot;&gt;&lt;/a&gt;传播模型&lt;/h3&gt;&lt;h4 id=&quot;1-传统传播模型&quot;&gt;&lt;a href=&quot;#1-传统传播模型&quot; class=&quot;headerlink&quot; title=&quot;1.传统传播模型&quot;&gt;&lt;/a&gt;1.传统传播模型&lt;/h4&gt;&lt;p&gt;由于信息是通过社会网络用户之间的交互传播的，这与传染病通过人与人接触传播的机制相似，所以传染病模型也可用来对信息传播过程（或者称影响力传播过程）建模。目前应用较广泛的传染病模型有：SI模型（Susceptible-Infected Model)、SIR模型（Susceptible-Infected-Recovered Model)、SIS 模型（Susceptible-Infected-Susceptible Model)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="影响力最大化" scheme="https://cenkii.github.io/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>影响力最大化一</title>
    <link href="https://cenkii.github.io/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/"/>
    <id>https://cenkii.github.io/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/</id>
    <published>2020-04-18T12:37:35.000Z</published>
    <updated>2020-05-26T14:24:47.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响力最大化——影响力测度"><a href="#影响力最大化——影响力测度" class="headerlink" title="影响力最大化——影响力测度"></a>影响力最大化——影响力测度</h2><p>对节点重要程度的定义和排序，通过从不同视角、 维度和约束条件下构建起节点影响力指标，并试图以最精准和快速的方式找到最有影响力的节点。</p><span id="more"></span><p><img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E8%A1%A8%E4%B8%80" alt="image-20200425154915814"></p><h3 id="单指标分析"><a href="#单指标分析" class="headerlink" title="单指标分析"></a>单指标分析</h3><ol><li><p>局部信息</p><blockquote><ol><li><p>邻居数量：节点v邻居的数量</p></li><li><p>邻居间连接拓扑信息：</p></li><li><p>三角结构数量（聚集系数）：</p></li></ol><p>​        在有向图中定义如下： $C = \frac{n}{k(k-1)}$ n表示在节点v的所有k个邻居间的边数</p><p>​        无向图：$C = \frac{2*n}{k(k-1)}$ </p><ol start="4"><li>结构洞：</li></ol><p>所谓“结构洞”就是指社会网络中的空隙，即社会网络中某个或某些个体和有些个体发生直接联系，但与其他个体不发生直接联系，即无直接关系或关系间断，从整体看好像网络结构中出现了洞穴。如果两者之间缺少直接的联系，而必须通过第三者才能形成联系，那么第三者就在关系网络中占据了一个结构洞，通常占据结构洞越多则此人的优势越大。</p><p>如下图：A即结构洞，起到桥梁作用</p><p><img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E5%9B%BE%E4%B8%80" alt="image-20200426170735173"></p><p>​    对于结构洞可以用网络约束系数来测量。该系数越高（接近1），结构洞越少，网络闭合性越高。</p><p>​    计算方式如下（注下图网络约束系数扩大了100倍）：</p><p>​    <img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E7%B3%BB%E6%95%B0" alt="image-20200426185352299"></p><p><a href="https://faculty.chicagobooth.edu/ronald.burt/research/files/NNappB.pdf">了解更多</a>[5]</p><ol start="5"><li>社区中心性</li></ol><p>即度中心性其定义是，某个结点相连的链接数量，若节点的连接数量越多，则中心性越大。</p></blockquote><p>2.全局信息</p><blockquote><ol><li>接近中心性</li></ol><p>接近中心性主要用于计算每个顶点到其他所有顶点的最短距离之和。然后将得到的和反过来确定该节点的接近中心性得分。<br>$$<br>C = \frac{1}{\sum_{n=1}^{N}distance^n}<br>$$<br>当C越大的时候，该点在网络中影响越大，因为到其它节点的平均最短距离最小，意味着这个节点从几何角度看是处于图的中心位置。</p><ol start="2"><li>介数中心性</li></ol><p>中介中心性的定义是，该结点作为其他两个结点的最短路上的桥梁的次数。也就是说，如果一个顶点出现在任意两个顶点间最短路径的次数越多，那么该顶点的中介中心性就越大。</p><p>算法第一步为寻找最短路径（通常为广度优先搜索），之后统计所有最短路径中，每个中间顶点出现的次数。</p><ol start="3"><li>流介数中心性</li></ol><p>节点的流介数中心性定义为网络中所有路径数与经过该节点路径数的比值。</p><ol start="4"><li>特征向量中心性</li></ol><p>特征向量中心性的基本思想是，一个节点的中心性是相邻节点中心性的函数。也就是说，与你连接的人越重要，你也就越重要。</p><p>特征向量中心性和点度中心性不同，一个点度中心性高即拥有很多连接的节点特征向量中心性不一定高，因为所有的连接者有可能特征向量中心性很低。同理，特征向量中心性高并不意味着它的点度中心性高，它拥有很少但很重要的连接者也可以拥有高特征向量中心性。</p><p>首先，计算的是每个点的点度中心性（degree centrality），即以点的连接数来衡量中心性的高低。</p><p>结果向量的第一个元素是用矩阵A的第一行去“获取”每一个与第一个点有连接的点的值（连接数，点度中心性），也就是第2个、第3个和第4个点的值，然后将它们加起来。</p><p>换句话说，邻接矩阵做的事情是将相邻节点的求和值重新分配给每个点。这样做的结果就是“扩散了”点度中心性。你的朋友的朋友越多，你的特征向量中心性就越高。</p><p>然后采用 $x(t)=cAx(t-1)$ 迭代，达到稳态时，x即为特征向量</p><ol start="5"><li>k-shell分解法</li></ol><p>K-shell分解方法给出了节点重要性的一种粗粒化的划分。其基本思想如下, 假设边缘节点的K-shell值为1, 然后往内一层层进入网络的核心, 先去除网络中度值等于1的所有节点以及连边。若剩下的节点里面, 仍有度值等于1的节点, 则重复上述操作, 即去除这些节点和连边, 直至所有节点的度值都大于1, 把这些去除的节点的K-shell值记为1, 也就是说这些节点均处于ks值为1的层。然后依次去除度值小于或等于k的节点及连边 (k为整数, k≥2) , 直到所有的节点都有对应的ks值为止。</p></blockquote></li></ol><h3 id="多指标分析"><a href="#多指标分析" class="headerlink" title="多指标分析"></a>多指标分析</h3><ol><li><p>3指标法</p><p>分别计算每个结点的 度、介数以及kcore，然后采用欧式距离公式得出综合指标[2]</p></li><li><p>4指标法</p><p>使用degree度中心性，接近中心性，介数中心性和kshell计算四指标，然后通过topsis计算排序[3]</p></li><li><p>7指标法</p><p>通过ListNet排序学习对网络中单个节点的 网络约束系数，网络有效规模、效率、等级度、阶数中心性，PageRank值和聚类系数7个度量指标进行融合，综合评价复杂网络中面向结构洞的节点重要性，从而对网络中关键节点进行排序。[1]</p></li><li><p>内部属性+外部属性</p><p>其公式为：</p><p><img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E5%85%AC%E5%BC%8F" alt="image-20200429135331396"></p><blockquote><p>其中</p><p>$f_{internal}(v_0)=\frac{K(v_0)}{max(K(v))}$   </p><p>K为内部属性 例如度介数紧密度等</p><p><img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E5%A4%96%E9%83%A8" alt="image-20200429135948373"></p><p>d(vo,c) 为节点 vo 在社区 c 中的邻居节点的总个数</p><p>|c|为社区大小</p><p>分母为归一化因子</p></blockquote></li></ol><p>参考文献</p><p>[1] 面向结构洞的复杂网络关键节点排序_韩忠明</p><p>[2] <em>Identifying all-around nodes for</em> <em>spreading dynamics in complex networks</em></p><p>[3] The node importance in actual complex networks based on a multi-attribute ranking method</p><p>[4] 复杂网络节点影响力测度及其最大化研究综述_张应青</p><p>[5] <a href="https://faculty.chicagobooth.edu/ronald.burt/research/files/NNappB.pdf">https://faculty.chicagobooth.edu/ronald.burt/research/files/NNappB.pdf</a></p><p>[6] 一种新的网络传播中最有影响力的节点发现方法</p><h3 id="影响力最大化系列"><a href="#影响力最大化系列" class="headerlink" title="影响力最大化系列"></a>影响力最大化系列</h3><p><a href="https://cenkii.github.io/2020/04/18/影响力最大化一/">影响力最大化——影响力测度</a></p><p><a href="https://cenkii.github.io/2020/04/29/IM2/">影响力最大化——节点影响力评估</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;影响力最大化——影响力测度&quot;&gt;&lt;a href=&quot;#影响力最大化——影响力测度&quot; class=&quot;headerlink&quot; title=&quot;影响力最大化——影响力测度&quot;&gt;&lt;/a&gt;影响力最大化——影响力测度&lt;/h2&gt;&lt;p&gt;对节点重要程度的定义和排序，通过从不同视角、 维度和约束条件下构建起节点影响力指标，并试图以最精准和快速的方式找到最有影响力的节点。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="影响力最大化" scheme="https://cenkii.github.io/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>k近邻算法</title>
    <link href="https://cenkii.github.io/2020/04/05/knn/"/>
    <id>https://cenkii.github.io/2020/04/05/knn/</id>
    <published>2020-04-05T08:32:13.000Z</published>
    <updated>2020-04-05T15:03:16.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1.算法介绍"></a>1.算法介绍</h3><p>k近邻算法即K-Nearest Neighbor algorithm，简称KNN算法。简单理解即，寻找离中心点最近的k个邻居。</p><p>它的基本流程为：</p><span id="more"></span><ol><li>计算测试样本和训练样本中每个样本点的距离（常见的距离度量有欧式距离，马氏距离等）；</li><li>对上面所有的距离值进行排序；</li><li>选前 k 个最小距离的样本；</li><li>根据这 k 个样本的标签进行投票，得到最后的分类类别；</li></ol><p>下面来看个例子</p><p><img src="/2020/04/05/knn/68747470733a2f2f6a756c796564752d696d672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f717565736261736536343135353238333936363635343430333634362e706e67" alt="img"></p><p>如上图所示绿色点为一个新的数据集，现要判断它属于那一类：</p><p>当k=3时，也就是实线圈的范围，绿色点周围的邻居为2个三角1个方块，可以判断绿色⚪属于三角那一类</p><p>当k=5时，即虚线圈的范围，可以看见，绿色点周围的邻居为2个三角3个方块，可以判断绿色⚪属于方块那一类</p><p><strong>于此我们看到，当无法判定当前待分类点是从属于已知分类中的哪一类时，我们可以依据统计学的理论看它所处的位置特征，衡量它周围邻居的权重，而把它归为(或分配)到权重更大的那一类。这就是K近邻算法的核心思想。</strong></p><p><code>k值选取</code></p><blockquote><p>通过上面的例子我们可以看到k的值选取很重要</p><p>一般情况下，k值取一个比较小的值，通常采用交叉验证法来选取最优的k值</p></blockquote><h3 id="2-距离度量"><a href="#2-距离度量" class="headerlink" title="2.距离度量"></a>2.距离度量</h3><p>k近邻中最重要的就是距离的度量了，下面来看几个距离度量的方法。</p><p>闵可夫斯基距离是一组距离定义</p><p>对于两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)：<br>$$<br>d_{12}=^p\sqrt{\sum_{k=1}^{n}|x_{1k}-x_{2k}|^p}<br>$$</p><blockquote><p>p为一个参数：</p><p>当p=1时，公式为曼哈顿距离</p><p>当p=2时，公式为欧式距离</p><p>当p=∞时，公式为切比雪夫距离</p></blockquote><h3 id="3-kd树"><a href="#3-kd树" class="headerlink" title="3.kd树"></a>3.kd树</h3><p><strong>kd树的构建</strong></p><p>kd树是一种对k维空间的实例点的存储以便 快速检索的树形数据结构。</p><p>下面看个例子如何构造kd树</p><p>给定一个二维空间数据集：<br>$$<br>T={(2,3)^T,(5,4)^T,(9,6)^T,(4,7)^T,(8,1)^T,(7,2)^T}<br>$$<br>构建kd树的具体步骤为：</p><ol><li><p>确定：split域。</p><p>具体是：6个数据点在x，y维度上的数据方差分别为39，28.63，所以在x轴上方差更大，故split域值为x；</p></li><li><p>确定：Node-data。</p><p>具体是：根据x维上的值将数据排序，6个数据的中值(所谓中值，即中间大小的值)为7，所以Node-data域位数据点（7,2）。这样，该节点的分割超平面就是通过（7,2）并垂直于：split=x轴的直线x=7；</p></li><li><p>确定：左子空间和右子空间。</p><p>具体是：分割超平面x=7将整个空间分为两部分：x&lt;=7的部分为左子空间，包含3个节点={(2,3),(5,4),(4,7)}；另一部分为右子空间，包含2个节点={(9,6)，(8,1)}；</p></li></ol><p>继续递归直到每个节点只有一个</p><p>构建出来的kd树为</p><p><img src="/2020/04/05/knn/image-20200405152225754.png" alt="image-20200405152225754"></p><p>特征空间划分</p><p><img src="/2020/04/05/knn/image-20200405152606745.png" alt="image-20200405152606745"></p><p><strong>kd树查找</strong></p><p>基本步骤</p><ol><li><p>从根结点出发，比较大小直接到叶子节点。</p></li><li><p>此节点作为“当前最近节点”</p></li><li><p>递归向上后退，执行以下操作</p><p>a) 如果该节点更近，则此节点为“当前最近节点”</p><p>b)当前最近节点一定存在另一子结点，检查另一子节点是否存在“当前最近节点”，如果有则设为“当前最近节点”接着递归。反之继续回退。</p></li><li><p>推到根节点则当前“当前最近节点”，为最近邻节点。</p></li></ol><p><strong>附：</strong></p><p>几种距离测量方式</p><ol><li>欧氏距离</li></ol><p>​       最常见的两点之间或多点之间的距离表示法，又称之为欧几里得度量，它定义于欧几里得空间中，如点 x = (x1,…,xn) 和 y = (y1,…,yn) 之间的距离为：</p><p>$$<br>d(x,y)=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+……+(x_n-y_n)^2}<br>$$<br>两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离：<br>$$<br>d_{12}=\sqrt{\sum_{k=1}^{n}(x_{1k}-x_{2k})^2}<br>$$</p><ol start="2"><li>曼哈顿距离</li></ol><p>曼哈顿距离与欧氏距离相似，也就是在欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。如点 x = (x1,…,xn) 和 y = (y1,…,yn) 之间的距离为：<br>$$<br>d(x,y)=|x_1-y_1|+|x_2-y_2|+……+|x_n-y_n|<br>$$<br>两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的曼哈顿距离：<br>$$<br>d_{12}=\sum_{k=1}^{n}|x_{1k}-x_{2k}|<br>$$</p><ol start="3"><li>切比雪夫距离</li></ol><p>若二个向量或二个点p，q</p><p>则<br>$$<br>D(p,q)=max(|p-q|)<br>$$<br>(1)二维平面两点a(x1,y1)与b(x2,y2)间的切比雪夫距离<br>$$<br>d_{12}=max(|x1-x2|,|y1-y2|)<br>$$<br>(2)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的切比雪夫距离：<br>$$<br>d_{12}=\max_{i}|x_{1i}-x_{2i}|<br>$$</p><p>$$<br>等同于\quad lim_{k→∞}(\sum_{i=1}^{n}|x_{1i}-x_{2i}|^k)^{1/k}<br>$$</p><ol start="4"><li>标准化欧氏距离</li></ol><p>标准化欧氏距离根据欧氏距离的缺点提出的改进方案</p><p>首先需要先进行标准化<br>$$<br>X^※=\frac{X-m}{s}<br>$$</p><blockquote><p>m为样本的期望</p><p>s为样本的标准差</p></blockquote><p>$$<br>d_{12}=\sqrt{\sum_{k=1}^{n}(\frac{x_{1k}-x_{2k}}{s_k})^2}<br>$$</p><ol start="5"><li>马氏距离</li></ol><p>有M个样本向量X1—Xm，协方差矩阵为S，均值向量u，则样本X到u的马氏距离<br>$$<br>D(X)=\sqrt{(X-u)^TS^{-1}(X-u)}<br>$$</p><p>$$<br>其中\quad S=Cov(X,Y)=E{[X-E(X)][Y-E(Y)]}<br>$$</p><p>则Xi, Xj之间的马氏距离为<br>$$<br>D(X_i,X_j)=\sqrt{(X_i-X_j)^TS^{-1}(X_i,X_j)}<br>$$<br>若协方差矩阵满足独立同分布，协方差矩阵为单位矩阵</p><p>则马氏距离=欧氏距离</p><p>若为对角矩阵</p><p>马氏距离=标准欧氏距离</p><ol start="6"><li>汉明距离</li></ol><p>两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。应用：信息编码（为了增强容错性，应使得编码间的最小汉明距离尽可能大）。</p><ol start="7"><li>夹角余弦</li></ol><p>(1)在二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式：<br>$$<br>cosθ=\frac{x_1x_2+y_1y_2}{\sqrt{x_1^2+y_1^2}\sqrt{x_2^2+y_2^2}}<br>$$<br>(2) 两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦<br>$$<br>cosθ=\frac{a•b}{|a||b|}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-算法介绍&quot;&gt;&lt;a href=&quot;#1-算法介绍&quot; class=&quot;headerlink&quot; title=&quot;1.算法介绍&quot;&gt;&lt;/a&gt;1.算法介绍&lt;/h3&gt;&lt;p&gt;k近邻算法即K-Nearest Neighbor algorithm，简称KNN算法。简单理解即，寻找离中心点最近的k个邻居。&lt;/p&gt;
&lt;p&gt;它的基本流程为：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>关联规则</title>
    <link href="https://cenkii.github.io/2020/04/01/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/"/>
    <id>https://cenkii.github.io/2020/04/01/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/</id>
    <published>2020-04-01T06:54:07.000Z</published>
    <updated>2020-04-05T15:00:25.292Z</updated>
    
    <content type="html"><![CDATA[<p>关联分析是用于发现隐藏在大型数据集中的有意义的联系，发现其中的项或对象的频繁模式、关联的过程。</p><p>下图为交易数据库</p><p>每个交易由顾客购买的商品(Items)组成</p><p>全部商品的集合，即商品中所有项的集合</p><span id="more"></span><p>项集，即若干个项的集合，每个项集项的个数称为项集的长度记为k，这个项集又称为k项集</p><p><img src="/2020/04/01/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/image-20200401221911087.png" alt="image-20200401221911087"></p><p><strong>支持度：</strong></p><p>支持度指交易包含项集X的概率：<br>$$<br>support(X)=\frac{count(X)}{|D|}×100%<br>$$</p><blockquote><p>|D|：表示交易总数</p><p>count(X)：包含X交易的数量</p></blockquote><p><strong>置信度：</strong></p><p>给定两个项集XY, X∩Y=Ф关联规则是X→Y，X成为前件，Y成为后件<br>$$<br>confidence(X→Y)=\frac{support(X→Y)}{support(X)}×100%<br>$$</p><h3 id="1-频繁项集"><a href="#1-频繁项集" class="headerlink" title="1.频繁项集"></a>1.频繁项集</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>设有项集X，最小支持度阈值minsup</p><p>若support(X)≥minsup，则X称为频繁项集</p><h4 id="1-2-闭合频繁项集"><a href="#1-2-闭合频繁项集" class="headerlink" title="1.2 闭合频繁项集"></a>1.2 闭合频繁项集</h4><p>若存在X满足X∈Y且support(X)≠support(Y)，则X是闭合频繁项集</p><h4 id="1-3-频繁项集逐层发现算法Apriori"><a href="#1-3-频繁项集逐层发现算法Apriori" class="headerlink" title="1.3 频繁项集逐层发现算法Apriori"></a>1.3 频繁项集逐层发现算法Apriori</h4><p>Apriori算法是第一个关联规则挖掘算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法流程</span><br><span class="line">1. k = 1，minsup = 0.5</span><br><span class="line">2. 统计k项的候选集支持度</span><br><span class="line">3. 根据minsup选出频繁k-项集</span><br><span class="line">4. k = k + 1，回到2</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/image-20200402154051535.png" alt="image-20200402154051535"></p><p><strong>支持度剪枝</strong></p><p>我们可以想一下一个k项集可以产生的频繁集数是 $2^k-1$ ,呈指数级增长，当k较大时计算量超大，所以Apriori算法中用了支持度剪枝的方式。</p><p>即对所有项集都满足</p><blockquote><p>先验原理   如果一个项集是频繁的，则它的所有子集也一定是频繁的。</p></blockquote><p>例如上图，根据上述定理{D}是非频繁集，则它的超集也不是频繁集，可以减掉</p><h4 id="1-4-频繁项集无候选集发现算法FP-growth"><a href="#1-4-频繁项集无候选集发现算法FP-growth" class="headerlink" title="1.4 频繁项集无候选集发现算法FP-growth"></a>1.4 频繁项集无候选集发现算法FP-growth</h4><p>FG-growth采用一种树的结构来实现频繁集的发现，不需要先生成候选集，相比Apriori算法需要多次扫描数据库，FP-growth只需要对数据库扫描2次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法步骤</span><br><span class="line">1.扫描数据库，找出 1-频繁项集</span><br><span class="line">2.按照支持度递减排序</span><br><span class="line">3.构建 FP-tree</span><br><span class="line">4.调用 mineTree&#123;T&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/01/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/image-20200402163438440.png" alt="image-20200402163438440"></p><p>minsup = 3/5</p><blockquote><p>第一步：扫描数据库（第一次扫描）</p><p>第二步：每项商品按频数递减排序，删除小于minsup的商品</p><p>f=4  c=4  a=3  b=3  m=3  p=3</p><p>此时重新排序后的数据库</p><p><img src="/2020/04/01/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/image-20200402164437542.png" alt="image-20200402164437542"></p><p>第三步：</p><p><img src="/2020/04/01/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/image-20200402164624073.png" alt="image-20200402164624073"></p><p>第四步：</p><p>频繁集分割</p><p>合并前缀得到条件模式库</p><p><img src="/2020/04/01/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99/image-20200402180255558.png" alt="image-20200402180255558"></p><p>挖掘p的频繁项集</p><p>因为minsup≥3所以无频繁项集</p><p>挖掘m的频繁项集</p><p>因为minsup≥3所以无频繁项集</p><p>挖掘b的频繁项集</p><p>因为minsup≥3所以无频繁项集</p><p>挖掘a的频繁项集</p><p>频繁二项集（f，a），（c，a）</p><p>频繁3项集（f，c，a）</p><p>挖掘c的频繁项集</p><p>频繁二项集（f，c）</p></blockquote><h3 id="2-关联规则"><a href="#2-关联规则" class="headerlink" title="2. 关联规则"></a>2. 关联规则</h3><h4 id="1-1-定义-1"><a href="#1-1-定义-1" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>若规则X→Y的关联规则，满足</p><p>support(X→Y) ≥ minsup</p><p>confidence(X→Y) ≥ minconf</p><p>则称该规则在数据中成立</p><h4 id="1-2-置信度剪枝"><a href="#1-2-置信度剪枝" class="headerlink" title="1.2  置信度剪枝"></a>1.2  置信度剪枝</h4><p>关联规则也需要剪枝来减少计算，但与支持度剪枝不一样，支持度具有单调性，而置信度并不具有任何单调性。</p><p>下面的定理对置信度成立</p><blockquote><p>如果规则 X→ Y - X不满足置信度阈值，则形如X‘ → Y - X’的规则一定不满足置信度阈值，X‘为X的子集。</p></blockquote><p>例如 bcd=&gt;a置信度低</p><p>则 bc=&gt;ad置信度也低所以可以剪掉</p><p><strong>参考资料</strong></p><p>[1] 数据挖掘导论</p><p>[2] mooc网 数据挖掘与python实践</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关联分析是用于发现隐藏在大型数据集中的有意义的联系，发现其中的项或对象的频繁模式、关联的过程。&lt;/p&gt;
&lt;p&gt;下图为交易数据库&lt;/p&gt;
&lt;p&gt;每个交易由顾客购买的商品(Items)组成&lt;/p&gt;
&lt;p&gt;全部商品的集合，即商品中所有项的集合&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯</title>
    <link href="https://cenkii.github.io/2020/03/30/%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>https://cenkii.github.io/2020/03/30/%E8%B4%9D%E5%8F%B6%E6%96%AF/</id>
    <published>2020-03-30T09:44:12.000Z</published>
    <updated>2020-04-29T06:06:14.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>朴素贝叶斯是经典的学习算法之一，它的原理简单，容易实现多用于，多用于文本分类，比如垃圾邮件过滤。</p><p>为什么叫朴素贝叶斯？</p><p>朴素贝叶斯中有两个假设：</p><ol><li><p>条件独立性假设，特征出现的概率相互独立</p><span id="more"></span></li><li><p>每个特征同等重要</p></li></ol><h3 id="2-算法核心"><a href="#2-算法核心" class="headerlink" title="2.算法核心"></a>2.算法核心</h3><p>贝叶斯公式<br>$$<br>P(c|x)=\frac{P(c)P(x|c)}{p(x)}=\frac{P(c)}{P(x)}\prod_{i=1}^{d}P(x_i|c)<br>$$<br>公式说明</p><p>P（c）：c的先验概率，表示c在全部样本中占的比例</p><p>P(x|c)：表示样本<em>x</em>相对于类别<em>c</em>的条件概率</p><p>d：为属性的数量</p><blockquote><p>最小风险贝叶斯决策</p><p>在贝叶斯决策论中</p><p>假设P(a)=0.6     P(b)=0.4</p><p>a，b有属性</p><p>P(w1|x)=0.6 P(w2|x)=0.4</p><p>那么 由上面可以得出</p><p>当样本为x时，属性为w1的概率为0.6</p><p>这样可以认为分类错误的概率为 0.4</p><p>同理，对于P(w2|x)=0.4 分类错误的概率为 0.6</p></blockquote><p>所以，当属性不止w1和w2时 错误率为<br>$$<br>R = \sum_{m≠right}P(w_m|x)<br>$$</p><p>$$<br>即R=1-P(w_{right}|x)<br>$$</p><p>根据朴素贝叶斯判定准则</p><p>为使R最小 即 $使P(w_{right}|x)$ 最大</p><p>则贝叶斯判定准则为：</p><p><img src="/2020/03/30/%E8%B4%9D%E5%8F%B6%E6%96%AF/image-20200330172935962.png" alt="image-20200330172935962"></p><p>其中<br>$$<br>P(c)=\frac{|D_c|}{|D|}<br>$$</p><p>$$<br>P(x_i|c)=\frac{|D_{c,x_i}|}{|D_c|}<br>$$</p><p>当数据为连续只是可以用<img src="/2020/03/30/%E8%B4%9D%E5%8F%B6%E6%96%AF/image-20200330174517475.png" alt="image-20200330174517475"></p><p><strong>若某个属性值没有与每个类同时出现，则会造成连乘计算为零，可采用拉普拉斯修正</strong>，令<em>N</em>表示训练集<em>D</em>中可能的类别数，Ni表示第<em>i</em>个属性可能的取值数目：<br>$$<br>P(c)=\frac{|D_c|+1}{|D|+N}<br>$$</p><p>$$<br>P(x_i|c)=\frac{|D_{c,x_i}|+1}{|D_c|+N_i}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h3&gt;&lt;p&gt;朴素贝叶斯是经典的学习算法之一，它的原理简单，容易实现多用于，多用于文本分类，比如垃圾邮件过滤。&lt;/p&gt;
&lt;p&gt;为什么叫朴素贝叶斯？&lt;/p&gt;
&lt;p&gt;朴素贝叶斯中有两个假设：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;条件独立性假设，特征出现的概率相互独立&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>集成算法</title>
    <link href="https://cenkii.github.io/2020/03/27/ensemble/"/>
    <id>https://cenkii.github.io/2020/03/27/ensemble/</id>
    <published>2020-03-27T13:40:11.000Z</published>
    <updated>2020-04-05T15:01:59.344Z</updated>
    
    <content type="html"><![CDATA[<p>集成学习分为以下两大类</p><ol><li><p>个体学习器问存在强依赖关系、必须串行生成的序列化方法&amp;主要有boosting</p></li><li><p>个体学习器 间不存在强依赖关系、可同时生成的并行化方法&amp;主要有 Bagging 和随机森林(Random Forest)</p></li></ol><p>下面来具体介绍一下：</p><span id="more"></span><h3 id="1-Bagging"><a href="#1-Bagging" class="headerlink" title="1.Bagging"></a>1.Bagging</h3><p>并行训练多个分类器取平均 $f(x)=\frac{1}{M} \sum_{m=1}^{M}f_m(x)$</p><p><strong>典型代表</strong>：随机森林，即很多个决策树并行放在一起</p><p>随机：数据随机采样，特征选择随机</p><p><strong>树的特征重要性</strong>：当一个数据中特征值较多时，可以根据衡量特征重要性，来去掉一些影响较小的特征。衡量方式是将某一特征全部换为噪声值看对结果的影响。</p><h3 id="2-Boosting"><a href="#2-Boosting" class="headerlink" title="2.Boosting"></a>2.Boosting</h3><p>从弱学习器开始加强，通过加权进行训练<br>$$<br>F_m(x)=F_{m-1}(x)+argmin_h\sum_{i=1}^{n}L(y_i,F_{m-1}(x_i)+h(x_i))<br>$$<br><strong>典型代表</strong>：Adaboost，Xgboost</p><p>Adaboost：根据前一次的分类结果调整数据的权重</p><blockquote><p>算法流程</p><p>输入 训练集 $D = {(x_1,y_1),(x_2,y_2)……,(x_n,y_n)}$</p><p>1.初始化权值分布，一般情况下按均匀分布<br>$$<br>W_1=(w_{1,1},w_{1,2},……w_{1,n})\quad w_i=1/n<br>$$<br>2.对于 m = 1,2,3,4….,M</p><p>(a)先使用数据集D，按W权重进行学习得到弱学习器$G_m(x)$</p><p>(b)计算$G_m(x)$在训练集上的误差率<br>$$<br>e_m=\sum_{i=1}^Nw_{m,i}I(G_m(x_i)≠y_i)<br>$$<br>(c)计算$G_m(x)$在强分类器中所占权重<br>$$<br>a_m=\frac{1}{2}log\frac{1-e_m}{e_m}<br>$$<br>(d)更新权值分布(z为归一化)<br>$$<br>w_{m+1,i}=\frac{w_{m,i}}{z_m}exp(-a_my_iG_m(x_i))<br>$$</p><p>$$<br>z_m=\sum_{i=1}^Nw_{m,i}exp(-a_my_iG_m(x_i))<br>$$</p><p>3.最终分类器<br>$$<br>F(x)=sign(\sum_{i=1}^Na_mG_m(x))<br>$$</p></blockquote><h3 id="3-Stacking"><a href="#3-Stacking" class="headerlink" title="3.Stacking"></a>3.Stacking</h3><p>聚合多个分类或回归模型</p><p>分阶段来进行</p><p>第一阶段训练若干个分类器，进行训练</p><p>第二阶段，将第一阶段的训练结果作为训练样本再进行训练</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集成学习分为以下两大类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;个体学习器问存在强依赖关系、必须串行生成的序列化方法&amp;amp;主要有boosting&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;个体学习器 间不存在强依赖关系、可同时生成的并行化方法&amp;amp;主要有 Bagging 和随机森林(Random Forest)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面来具体介绍一下：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>支持向量机</title>
    <link href="https://cenkii.github.io/2020/03/20/svm/"/>
    <id>https://cenkii.github.io/2020/03/20/svm/</id>
    <published>2020-03-20T14:03:53.000Z</published>
    <updated>2020-04-05T15:03:36.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="硬间隔"><a href="#硬间隔" class="headerlink" title="硬间隔"></a>硬间隔</h3><p>给定训练样本集，寻找一个划分超平面，使这个超平面将数据分割开，这个超平面可以定义为<br>$$<br>W^Tx+b=0 \space<br>$$</p><span id="more"></span><p><img src="/2020/03/20/svm/image-20200322202341179.png" alt="image-20200322202341179"></p><p>那么问题来了，如何确定这个超平面W和b使它的效果最好</p><p><img src="/2020/03/20/svm/image-20200322203052660.png" alt="image-20200322203052660"></p><p>如上图可以看到x为平面外一点要计算x到平面距离dist（x，h）有<br>$$<br>超平面方程为：W^Tx+b=0<br>$$</p><p>$$<br>因为x^{‘}在超平面上所以有：W^Tx^{‘}+b=0<br>$$</p><p>$$<br>由图可知：dist=|xx^‘|*cosa\quad a为|xx^‘|与垂线夹角<br>$$</p><p>$$<br>cosa=\frac{\vec{xx^‘}*\vec w}{|xx^‘||w|}\quad n为法向量<br>$$</p><p>$$<br>dict = |\frac{\vec{xx^‘}*\vec w^T}{|w|}|<br>$$</p><p>$$<br>=|\frac{(x-x^‘)*\vec w^T}{|w|}|<br>$$</p><p>$$<br>=\frac{|x*w^T+b|}{|w|}<br>$$</p><p>找到了点到平面的距离接下来就要寻找优化目标</p><p>根据第一张图定义可以知道当超平面方程<br>$$<br>\begin{cases}<br>\frac{w_Tx+b&gt;0\quad y_i=1}{w_Tx+b&lt;0\quad y_i=-1}<br>\end{cases}<br>$$<br>通过观察上面的条件可得 $y_i(w^Tx_i+b)&gt;0$ 恒成立 </p><p>我们的优化目标即为找到一个w和b使得离线最近的点能离线最远</p><p>所以上面的公式可以转化为<br>$$<br>dict=\frac{y_i(w^Tx_i+b)}{|w|}<br>$$</p><p>因为上面的公式求解并不容易因为 $w^Tx_i+b=0$和$3w^Tx_i+3b=0$ 的值是一样的，而$y_i(w^Tx_i+b)&gt;0$ 恒成立，所以可以将 分子通过缩放变为$y_i(w^Tx_i+b)=1$</p><p>所以上面的问题简化求下述公式最大值<br>$$<br>dict=\frac{1}{|w|}<br>$$<br>此时的如下图所示，在边缘上的点使等号成立，被称为支持向量<br>$$<br>γ=\frac{2}{|w|}<br>$$<br>被称为“间隔”</p><p><img src="/2020/03/20/svm/image-20200325135848164.png" alt="image-20200325135848164"></p><p>进一步转化为 最小化 $|w|$ 为方便计算</p><p>令目标函数为<br>$$<br>dict = \frac{1}{2} w^T w =\frac{1}{2}（w^2_1+w^2_2+……+w^2_n）\<br>同时还要满足y_i(w^Tx_i+b)&gt;1的约束条件<br>$$<br>所以对上述式子运用拉格朗日乘子法有<br>$$<br>L(w,b,a)=\frac{1}{2}w^Tw-\sum_{i=1}^{n}a_i(y_i(w^Tx+b)-1)<br>$$</p><p>$$<br>所以求偏导 \quad \frac{\partial L}{\partial w}=0\quad \frac{\partial L}{\partial b}=0<br>$$</p><p>$$<br>可得\quad w = \sum_{i=1}^{n}a_iy_ix_i \quad0=\sum_{i=1}^{n}a_iy_i<br>$$</p><p>$$<br>这样我们的目标变成了min_{w,b}max_{a_i}L(w,b,a)<br>$$</p><p>$$<br>因为(y_i(w^Tx+b)-1)&gt;0\quad<br>$$</p><p>$$<br>若使L最小则令\sum_{i=1}^{n}a_i(y_i(w^Tx+b)-1)最大<br>$$<br>通过kkt条件有<br>$$<br>min_{w,b}max_{a_i}L(w,b,a)=max_{a_i}min_{w,b}L(w,b,a)<br>$$</p><p>将式L展开并将上式代入带入可得<br>$$<br>L(w,b,a)=\frac{1}{2}w^Tw-w^T\sum_{i=1}^{n}a_iy_ix-b\sum_{i=1}^{n}a_iy_i+\sum_{i=1}^{n}a_i<br>$$</p><p>$$<br>=-\frac{1}{2}(\sum_{i=1}^{n}a_iy_ix)^T(\sum_{i=1}^{n}a_iy_ix) + \sum_{i=1}^{n}a_i<br>$$</p><p>$$<br>=\sum_{i=1}^{n}a_i-\frac{1}{2}\sum_{i=1,j=1}^{n}a_ia_jy_iy_jx^Tx<br>$$<br>这样我们就把w和b去掉了</p><p>接下来只需要求<br>$$<br>max_{a_i}L(w,b,a)=max_{a_i}（\sum_{i=1}^{n}a_i-\frac{1}{2}\sum_{i=1,j=1}^{n}a_ia_jy_iy_jx^Tx）<br>$$</p><p>$$<br>\<br>min_{a_i}L(w,b,a)=min_{a_i}（\sum_{i=1}^{n}a_i-\frac{1}{2}\sum_{i=1,j=1}^{n}a_ia_jy_iy_jx^Tx）<br>$$<br>因为<br>$$<br>已知存在y_i(w^Tx_i+b)=1<br>$$</p><p>$$<br>w^※ = \sum_{i=1}^{n}a_iy_ix<br>$$</p><p>$$<br>两侧同时乘y_i(由已知y_i^2=1)<br>$$</p><p>$$<br>可得b^※=y_i-\sum_{i=1}^{n}a_iy_ix_ix_i^T<br>$$</p><p>所以，最终决策平面为 $w^※x+b^※$ 方程为</p><p>$$<br>f(x)=sign(w^※x+b^※)<br>$$</p><blockquote><p>所有非决策边界上的点$a_i=0$对结果无影响 反之不等于0对结果有影响</p><p>边界上的点是支持向量 </p></blockquote><h3 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h3><p>如下图所示当数据的样本点用噪声的情况下，会对结果造成不好的影响。</p><p><img src="/2020/03/20/svm/image-20200325141614862.png" alt="image-20200325141614862"></p><p>为解决以下问题，需要引入松弛因子</p><p>即<br>$$<br>y_i(wx_i+b)≥1-ζ_i<br>$$</p><p>所以目标函数变成了</p><p>$$<br>min\frac{1}{2}|w|^2+C\sum_{i=1}^{n}ζ_i<br>$$</p><blockquote><p>C越小，ζ就会越大，容忍错误的能力会越强</p><p>反之，C越大，ζ就会越小，容忍错误的能力越弱</p></blockquote><h3 id="核方法"><a href="#核方法" class="headerlink" title="核方法"></a>核方法</h3><p>前面的例子我们假设的是样本是线性可分的，但如果样本是这样的</p><p><img src="/2020/03/20/svm/image-20200325153938861.png" alt="image-20200325153938861"></p><p>我们需要做一些核变换把低维数据转换为高维数据，这样就可以分割了</p><blockquote><p>注：这里虽然是降低维数据转换到了高维，但他只是理论上转换到了高维，由于转换后计算量太大，而凑巧的是高维数据和低维数据结果是一样的，所以实际计算还是在低维上进行的</p></blockquote><p>常用的核函数如下：</p><p><img src="/2020/03/20/svm/image-20200325155245672.png" alt="image-20200325155245672"></p><p><strong>参考文献</strong></p><p>[1] <a href="https://www.bilibili.com/video/BV1aE411o7qd?p=31">https://www.bilibili.com/video/BV1aE411o7qd?p=31</a></p><p>[2] <a href="https://www.bilibili.com/video/BV1ft411x7uL?p=6">https://www.bilibili.com/video/BV1ft411x7uL?p=6</a></p><p>[3] 《机器学习》周志华 </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;硬间隔&quot;&gt;&lt;a href=&quot;#硬间隔&quot; class=&quot;headerlink&quot; title=&quot;硬间隔&quot;&gt;&lt;/a&gt;硬间隔&lt;/h3&gt;&lt;p&gt;给定训练样本集，寻找一个划分超平面，使这个超平面将数据分割开，这个超平面可以定义为&lt;br&gt;$$&lt;br&gt;W^Tx+b=0 \space&lt;br&gt;$$&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
</feed>
