<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Q.Chen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cenkii.github.io/"/>
  <updated>2021-06-11T11:01:02.048Z</updated>
  <id>https://cenkii.github.io/</id>
  
  <author>
    <name>陈琪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis原理</title>
    <link href="https://cenkii.github.io/2021/06/11/Redis%E5%8E%9F%E7%90%86/"/>
    <id>https://cenkii.github.io/2021/06/11/Redis%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-11T05:20:52.000Z</published>
    <updated>2021-06-11T11:01:02.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ol><li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ol><h2 id="Redis和Memcached区别"><a href="#Redis和Memcached区别" class="headerlink" title="Redis和Memcached区别"></a>Redis和Memcached区别</h2><ol><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>value大小：redis最大可以达到1GB，而memcache只有1MB</li></ol><h2 id="Redis内部数据结构"><a href="#Redis内部数据结构" class="headerlink" title="Redis内部数据结构"></a>Redis内部数据结构</h2><p>在Redis中，每一个Value都是一个Redis对象，对应的都是RedisObject结构，在RedisObject结构中，保存了对象的类型type，底层的编码encoding等一些属性，也拥有一个ptr指针，指向对象具体的存储地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisObject</span> &#123;</span></span><br><span class="line">    int4 type; <span class="comment">//类型</span></span><br><span class="line">    int4 encoding; <span class="comment">//编码</span></span><br><span class="line">    int24 lru; </span><br><span class="line">    int32 refcount; </span><br><span class="line">    <span class="keyword">void</span> *ptr; </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>在Redis中，字符串有两种存储方式，int编码，embstr编码和raw编码。</p><h3 id="int编码"><a href="#int编码" class="headerlink" title="int编码"></a>int编码</h3><p>当value是一个<strong>整数</strong>，并且可以使用<strong>long类型</strong>（8字节）来表示时，那么会属于int编码，<strong>ptr直接存储数值</strong>。（并且Redis会进行优化，启动时创建0~9999的字符串对象作为共享变量。）</p><h3 id="embstr和raw编码"><a href="#embstr和raw编码" class="headerlink" title="embstr和raw编码"></a>embstr和raw编码</h3><p>两种存储方式下，都RedisObject和SDS结构(简单动态字符串)来存储字符串，区别在于，<strong>embstr</strong>对象用于<strong>存储较短</strong>的字符串，embstr编码中RedisObject结构与ptr指向的SDS结构<strong>在内存中是连续的</strong>，内存分配次数和内存释放次数均是一次，而<strong>raw编码</strong>会分别<strong>调用两次内存</strong>分配函数来分别<strong>创建RedisObject结构</strong>和<strong>SDS结构</strong>。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Redis的字符串叫做[SDS]，即Simple Dynamic String。它的结构是一个带长度信息的字节数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;</span>T&gt; &#123;</span><br><span class="line">T capacity; <span class="comment">// 数组容量</span></span><br><span class="line">T len; <span class="comment">// 数组长度</span></span><br><span class="line">byte flags; <span class="comment">// 特殊标识位，不理睬它</span></span><br><span class="line">byte[] content; <span class="comment">// 数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>content存储真正的字符串内容，capacity表示所分配数组的长度，len表示字符串的实际长度</li><li>SDS使泛型用T，是因为当字符串比较短时，len和capacity可以使用byte和short来表示</li><li>Redis的字符串有两种存储方式，当长度特别短使用<code>EMB</code>形式存储，当长度超过44时，使用<code>raw</code>形式存储</li><li>字符串在长度小于 1M 之前，扩容空间采用加倍策略，也就是保留 100% 的冗余空间。当长度超过 1M 之后，为了避免加倍后的冗余空间过大而导致浪费，每次扩容只会多分配 1M 大小的冗余空间。</li></ol><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>字典，是一种用于保存键值对的抽象数据结构，Redis中的hash结构、zset中value和score值的映射关系、Redis所有的key和value、带过期时间的key都是使用字典（dict）这个数据结构。</p><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>元素保存的字符串长度较短且元素个数较少时(<strong>小于64字节，个数小于512</strong>)，出于节约内存的考虑，hash表会使用ziplist作为的底层实现，ziplist是一块连续的内存，里面每一个节点保存了对应的key和value，然后每个节点很紧凑地存储在一起，优点是<strong>没有冗余空间</strong>，缺点<strong>插入新元素</strong>需要调用realloc<strong>扩展内存</strong>。（可能会进行内存重分配，将内容拷贝过去，也可能在原有地址上扩展）。</p><ul><li>zlbytes：4字节，记录整个压缩列表占用内存的字节数</li><li>zltail：4字节，记录压缩列表尾部节点距离起始地址的偏移量</li><li>zllen：2字节，记录压缩列表包含的节点数量</li><li>entry：不定，列表中的每个节点</li><li>zlend：1字节，特殊值0xFF，标记压缩列表的结束</li></ul><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p><strong>元素比较多</strong>时就会使用<strong>hashtable编码</strong>来作为底层实现，这个时候RedisObject的ptr指针会指向一个dict结构，dict结构中的ht数组保存了ht[0]和ht[1]两个元素，通常使用<strong>ht[0]保存键值对，ht[1]只在渐进式rehash</strong>时使用。待搬迁结束后，旧的 hashtable 被删除，新的 hashtable 取而代之。hashtable是通过链地址法来解决冲突的，table数组存储的是链表的头结点（添加新元素，首先根据键计算出hash值，然后与数组长度取模之后得到数组下标，将元素添加到数组下标对应的链表中去）。</p><p>扩容：</p><ol><li>如果服务器没有正在执行bgsave令，并且哈希表中的元素个数大于等于一维数据的长度，自动开始对dict进行扩容扩容至2倍</li><li>如果服务器正在执行bgsave命令，并且哈希表中的元素个数大于等于一维数据的长度的5倍，才进行强制扩容</li></ol><p>缩容：</p><ol><li>当元素个数低于数组长度的 10%，Redis 会对 hash 表进行缩容来减少 hash 表的第一维数组空间占用。缩容不会考虑 Redis 是否正在做 bgsave。</li></ol><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>在Redis中，存储的value可以是一个列表List，跟Java中的LinkedList很像，底层数据结构是一个<strong>链表</strong>，<strong>插入和删除很快</strong>，<strong>随机访问较慢</strong>，时间复杂度是O(N)。Java中的列表数据进行缓存时一般是序列化成JSON，以字符串的形式存储在Redis上，而不是使用Redis中的List来进行存储。Redis中的List可以作为一个队列来使用，也可以作为一个栈来使用。在实际使用中，常用来做异步队列使用，将可以延时处理的任务序列化成字符串塞进Redis的列表，另外一个线程从列表中轮询数据进行处理</p><h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>老版本中的Redis，元素较少时，使用ziplist来作为底层编码，元素较多时使用双向链表linkedList作为底层编码。因为链表每个节点需要prev，next指针，需要<strong>占用16字节</strong>，而且每个节点内存都是单独分配，加剧内存<strong>碎片化</strong>，所以新版本使用quiklist作为底层编码，quicklist的是一个<strong>双向链表</strong>，但是它的<strong>每一个节点是一个ziplist</strong>。（默认每个ziplist最大长度为8k字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;        <span class="comment">// 指向quicklist的头部</span></span><br><span class="line">    quicklistNode *tail;        <span class="comment">// 指向quicklist的尾部</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">// 列表中所有数据项的个数总和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">// quicklist节点的个数，即ziplist的个数</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">// ziplist大小限定，由list-max-ziplist-size给定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">// 节点压缩深度设置，由list-compress-depth给定</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p>quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。</p><p><img src="/2021/06/11/Redis%E5%8E%9F%E7%90%86/Redis%E5%8E%9F%E7%90%86%5Credis-3.png" alt="img"></p><ol><li>quicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个 ziplist。ziplist 的长度由配置参数list-max-ziplist-size决定。</li><li>quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</li></ol><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set是一个无序的，不重复的字符串集合，底层编码有inset和hashtable两种。</p><h3 id="inset"><a href="#inset" class="headerlink" title="inset"></a>inset</h3><p>当元素都为整数，且元素个数较少时会使用inset作为底层编码，inset结构中的有一个contents属性，content是是一个<strong>整数数组</strong>，<strong>从小到大</strong>保存了所有元素。</p><h3 id="hashtable-1"><a href="#hashtable-1" class="headerlink" title="hashtable"></a>hashtable</h3><p>当元素个数较多时，Set使用hashtable来保存元素，元素的值作为key，value都是NULL。</p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>Zset与Set的区别在于每一个元素都有一个Score属性，并且存储时会将元素按照Score从低到高排列。底层是通过跳跃表实现的。</p><h3 id="ziplist-1"><a href="#ziplist-1" class="headerlink" title="ziplist"></a>ziplist</h3><p>当元素较少时(元素个数&lt;128个，且每个元素的长度小于64字节)，ZSet的底层编码使用ziplist实现，所有元素按照Score从低到高排序。</p><h3 id="skiplist-dict"><a href="#skiplist-dict" class="headerlink" title="skiplist+dict"></a>skiplist+dict</h3><p>当元素较多时，使用skiplist+dict来实现。 skiplist存储元素的值和Score，并且将所有元素按照分值有序排列。便于以O(logN)的时间复杂度插入，删除，更新，及根据Score进行范围性查找。</p><p>dict存储元素的值和Score的映射关系，便于以O(1)的时间复杂度查找元素对应的分值。</p><p>另一方面需要提供按照 score 来排序的功能，还需要能够指定 score 的范围来获取 value 列表的功能，这就需要另外一个结构「跳跃列表」。</p><p><a href="https://github.com/zaiyunduan123/Java-Interview/blob/master/image/redis-4.png"><img src="/2021/06/11/Redis%E5%8E%9F%E7%90%86/Redis%E5%8E%9F%E7%90%86%5Credis-4.png" alt="img"></a></p><p>图中只画了四层，Redis 的跳跃表共有 64 层，意味着最多可以容纳 2^64 次方个元素。每一个 kv 块对应的结构如下面的代码中的zslnode结构，kv header 也是这个结构，只不过 value 字段是 null 值——无效的，score 是 Double.MIN_VALUE，用来垫底的。kv 之间使用指针串起来形成了双向链表结构，它们是 有序 排列的，从小到大。不同的 kv 层高可能不一样，层数越高的 kv 越少。同一层的 kv 会使用指针串起来。每一个层元素的遍历都是从 kv header 出发。</p><h3 id="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"><a href="#为什么Redis选择使用跳表而不是红黑树来实现有序集合？" class="headerlink" title="为什么Redis选择使用跳表而不是红黑树来实现有序集合？"></a>为什么Redis选择使用跳表而不是红黑树来实现有序集合？</h3><p>Redis 中的有序集合(zset) 支持的操作：</p><ol><li>插入一个元素</li><li>删除一个元素</li><li>查找一个元素</li><li>有序输出所有元素</li><li><strong>按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</strong></li></ol><p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，<strong>按照区间来查找数据这个操作</strong>，<strong>红黑树的效率没有跳表高</strong>。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。</p><h2 id="Redis应用"><a href="#Redis应用" class="headerlink" title="Redis应用"></a>Redis应用</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>Redis为<strong>单进程单线程模式</strong>，采用<strong>队列模式</strong>将<strong>并发访问变成串行访问</strong>，且多客户端对Redis的连接并不存在竞争关系。redis的SETNX命令可以方便的实现分布式锁。</p><p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p><p>占坑一般是使用 <strong>setnx</strong>(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。</p><p>setNX（SET if Not eXists 如果不存在，则 SET）</p><ol><li>当 key <strong>不存在</strong>，将 key 的值设为 value 。</li><li>若给定的 key 已经<strong>存在</strong>，则 SETNX 不做任何动作。</li></ol><p><strong>如果一个持有锁的客户端失败或崩溃了不能释放锁，该怎么解决？</strong></p><p>如果一个客户端持有的锁超时了，任何客户端都可以检测超时并删除该锁，那么这里就会存在竞态关系，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C0操作超时了，但它还持有着锁，C1和C2读取lock.foo检查时间戳，先后发现超时了。 </span><br><span class="line">C1 发送DEL lock.foo </span><br><span class="line">C1 发送SETNX lock.foo 并且成功了。 </span><br><span class="line">C2 发送DEL lock.foo </span><br><span class="line">C2 发送SETNX lock.foo 并且成功了。 </span><br><span class="line">这样一来，C1，C2都拿到了锁！</span><br></pre></td></tr></table></figure><p>所以使用执行下面的命令解决上面问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSET lock.foo &lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure><p>通过<strong>GETSET</strong>，C1拿到的时间戳如果是<strong>超时的</strong>，那就说明<strong>中间锁超时</strong>并且中间<strong>没有被其他客户端抢先获得锁</strong>，因此C1拿到锁。 如果在C1之前，有个叫C2的客户端比C1快一步执行了上面的操作，那么C1拿到的时间戳是个未超时的值，这时C1没有如期获得锁，需要再次等待或重试。尽管C1没拿到锁，但它改写了C2设置的锁的超时值，不过这一点非常微小的误差带来的影响可以忽略不计。</p><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><p>延时队列可以通过 Redis 的 <strong>zset</strong>(有序列表) 来实现。我们将消息序列化成一个字符串作为 zset 的value，这个消息的<strong>到期处理时间</strong>作为<strong>score</strong>，然后用多个线程轮询 zset 获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。</p><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>Redis 提供了位图统计指令 bitcount 和位图查找指令 bitpos，bitcount 用来统计指定位置范围内 1 的个数，bitpos 用来查找指定范围内出现的第一个 0 或 1。 比如我们可以通过 bitcount 统计用户一共签到了多少天，通过 bitpos 指令查找用户从哪一天开始第一次签到。如果指定了范围参数[start, end]，就可以统计在某个时间范围内用户签到了多少天，用户自某天以后的哪天开始签到。</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 数据结构是 Redis 的高级数据结构，HyperLogLog 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是 0.81%，这样的精确度已经可以满足上面的 UV 统计需求了</p><h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>Gossip协议是一个通信协议，一种传播消息的方式，灵感来自于：瘟疫、社交网络等。使用Gossip协议的有：Redis Cluster、Consul、Apache Cassandra等。</p><p>Gossip协议基本思想就是：<strong>一个节点想要分享一些信息给网络中的其他的一些节点</strong>。于是，它周期性的随机选择一些节点，并把信息传递给这些节点。<strong>这些收到信息的节点接下来会做同样的事情</strong>，即把这些信息传递给其他一些随机选择的节点。一般而言，信息会周期性的传递给N个目标节点，而不只是一个。这个N被称为fanout（这个单词的本意是扇出）</p><p>Gossip协议的主要用途就是<strong>信息传播和扩散</strong>：即把一些发生的事件传播到全世界。它们也被用于数据库复制，信息扩散，集群成员身份确认，故障探测等</p><p>特点：</p><ol><li><strong>可扩展性</strong>：即使某条消息传播过程中丢失，它也不需要做任何补偿措施</li><li><strong>失败容错</strong>：因为一个节点会多次分享某个需要传播的信息，即使不能连通某个节点，其他被感染的节点也会尝试向这个节点传播信息。</li><li><strong>健壮性</strong>：没有任何扮演特殊角色的节点（比如leader等）。任何一个节点无论什么时候下线或者加入，并不会破坏整个系统的服务质量。</li></ol><h2 id="Redis单进程单线程方式"><a href="#Redis单进程单线程方式" class="headerlink" title="Redis单进程单线程方式"></a>Redis单进程单线程方式</h2><p>注意：这里我们一直在强调的单线程，只是在<strong>处理我们的网络请求的时候只有一个线程来处理</strong>，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程</p><p>因为Redis是<strong>基于内存</strong>的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器<strong>内存的大小</strong>或者<strong>网络带宽</strong>。既然单线程容易实现，而且CPU不会成为瓶颈，所以就采用单线程</p><h3 id="单进程单线程好处"><a href="#单进程单线程好处" class="headerlink" title="单进程单线程好处"></a>单进程单线程好处</h3><ol><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ol><h3 id="单进程单线程弊端"><a href="#单进程单线程弊端" class="headerlink" title="单进程单线程弊端"></a>单进程单线程弊端</h3><ol><li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li></ol><h3 id="其他一些优秀的开源软件采用的模型"><a href="#其他一些优秀的开源软件采用的模型" class="headerlink" title="其他一些优秀的开源软件采用的模型"></a>其他一些优秀的开源软件采用的模型</h3><ol><li>多进程单线程模型：Nginx （Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程））</li><li>单进程多线程模型：MySQL、Memcached、Oracle（ Windows版本）；</li></ol><h2 id="多路I-O复用模型"><a href="#多路I-O复用模型" class="headerlink" title="多路I/O复用模型"></a>多路I/O复用模型</h2><ol><li>多路I/O复用模型是利用 <strong>select、poll、epoll</strong> 可以<strong>同时监察多个流的 I/O 事件</strong>的能力，在<strong>空闲</strong>的时候，会把<strong>当前线程阻塞</strong>掉，当<strong>有一个或多个流有 I/O 事件</strong>时，就从阻塞态中<strong>唤醒</strong>，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</li><li>这里“<strong>多路</strong>”指的是<strong>多个网络连接</strong>，“<strong>复用</strong>”指的是<strong>复用同一个线程</strong>。采用多路 I/O 复用技术可以让<strong>单个线程高效的处理多个连接请求</strong>（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</li></ol><p>我们知道Redis是用”单线程-多路复用IO模型”来实现高性能的内存数据服务的，这种机制避免了使用锁，但是同时这种机制在进行sunion之类的比较耗时的命令时会使redis的并发下降。因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。而单一线程也只能用到一个CPU核心，所以可以在同一个多核的服务器中，可以启动多个实例，组成master-master或者master-slave的形式，耗时的读命令可以完全在slave进行。</p><h2 id="Redis常见的性能问题都有哪些？如何解决？"><a href="#Redis常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis常见的性能问题都有哪些？如何解决？"></a>Redis常见的性能问题都有哪些？如何解决？</h2><ol><li>Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</li><li>Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li><li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</li></ol><h2 id="Redis的内存优化"><a href="#Redis的内存优化" class="headerlink" title="Redis的内存优化"></a>Redis的内存优化</h2><ol><li>redisObject对象</li><li>缩减键值对象</li><li>共享对象池</li><li>字符串优化</li><li>编码优化</li><li>控制key的数量</li></ol><h2 id="为什么lua脚本结合Redis命令可以实现原子性？"><a href="#为什么lua脚本结合Redis命令可以实现原子性？" class="headerlink" title="为什么lua脚本结合Redis命令可以实现原子性？"></a>为什么lua脚本结合Redis命令可以实现原子性？</h2><p>Redis 提供了非常丰富的指令集，但是用户依然不满足，希望可以自定义扩充若干指令来完成一些特定领域的问题。Redis 为这样的用户场景提供了 lua 脚本支持，用户可以向服务器发送 lua 脚本来执行自定义动作，获取脚本的响应数据。Redis 服务器会单线程原子性执行 lua 脚本，保证 lua 脚本在处理的过程中不会被任意其它请求打断。</p><p>redis会为lua脚本执行<strong>创建伪客户端模拟客户端调用redis执行命令</strong>，伪客户端执行lua脚本是排他的，再加上redis是原子性的。</p><h2 id="Redis分布式锁会导致什么问题"><a href="#Redis分布式锁会导致什么问题" class="headerlink" title="Redis分布式锁会导致什么问题?"></a>Redis分布式锁会导致什么问题?</h2><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><p>业务逻辑执行太慢，比锁失效时间还长怎么办，redisson的WatchDog 会每10秒轮询，延长锁。</p><p>如果你很在乎高可用性，希望挂了一台 redis 完全不受影响，可以考虑 redlock。</p><h2 id="Redis有1000万个key，找出前缀为aaa的key的命令是什么？"><a href="#Redis有1000万个key，找出前缀为aaa的key的命令是什么？" class="headerlink" title="Redis有1000万个key，找出前缀为aaa的key的命令是什么？"></a>Redis有1000万个key，找出前缀为aaa的key的命令是什么？</h2><ul><li>SCAN cursor [MATCH pattern] [COUNT count],指令指定返回条数</li><li>SCAN 0 MATCH aaa* COUNT 5 表示从游标0开始查询aaa开头的key，每次返回5条，但是这个5条不一定，只是给Redis打了个招呼，具体返回数量看Redis心情。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis特点&quot;&gt;&lt;a href=&quot;#Redis特点&quot; class=&quot;headerlink&quot; title=&quot;Redis特点&quot;&gt;&lt;/a&gt;Redis特点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>zookeeper</title>
    <link href="https://cenkii.github.io/2021/06/11/zookeeper/"/>
    <id>https://cenkii.github.io/2021/06/11/zookeeper/</id>
    <published>2021-06-11T01:24:10.000Z</published>
    <updated>2021-06-11T05:16:15.419Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper 是一个开源的<strong>分布式协调服务</strong>。它是一个为<strong>分布式</strong>应用提供<strong>一致性</strong>服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p><p>ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p>Zookeeper 保证了如下分布式一致性特性：</p><ol><li>顺序一致性</li><li>原子性</li><li>单一视图</li><li>可靠性</li><li>实时性（最终一致性）</li></ol><p>客户端的<strong>读请求</strong>可以被集群中的<strong>任意一台机器处理</strong>，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于<strong>写请求</strong>，这些请求会<strong>同时发给其他 zookeeper 机器并且达成一致后</strong>，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p><p>有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper 最新的 zxid。</p><h1 id="ZooKeeper-设计目标"><a href="#ZooKeeper-设计目标" class="headerlink" title="ZooKeeper 设计目标"></a>ZooKeeper 设计目标</h1><h2 id="简单的数据模型"><a href="#简单的数据模型" class="headerlink" title="简单的数据模型"></a>简单的数据模型</h2><p>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。 名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，以 key/value 形式存储数据，这些类似于文件和目录。 与为存储设计的典型文件系统不同，ZooKeeper数据保存在<strong>内存</strong>中，这意味着ZooKeeper可以实现高吞吐量和低延迟。</p><p><img src="/2021/06/11/zookeeper/zookeeper%5Cimage-20210611093335509.png" alt="image-20210611093335509"></p><h2 id="可构建集群"><a href="#可构建集群" class="headerlink" title="可构建集群"></a>可构建集群</h2><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的。 客户端在使用 ZooKeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个TCP链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。</p><p>组成 ZooKeeper 服务的服务器都会在<strong>内存中</strong>维护当前的服务器<strong>状态</strong>，并且每台服务器之间都互相保持着通信。集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。</p><h2 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h2><p>对于来自客户端的每个<strong>更新请求</strong>，ZooKeeper 都会分配一个<strong>全局唯一的递增编号</strong>，这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。 这个编号也叫做时间戳——<strong>zxid</strong>（Zookeeper Transaction Id）</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</p><h1 id="ZooKeeper-提供了什么？"><a href="#ZooKeeper-提供了什么？" class="headerlink" title="ZooKeeper 提供了什么？"></a>ZooKeeper 提供了什么？</h1><ul><li>文件系统</li><li>通知机制</li></ul><h1 id="Zookeeper-文件系统"><a href="#Zookeeper-文件系统" class="headerlink" title="Zookeeper 文件系统"></a>Zookeeper 文件系统</h1><p>Zookeeper 提供一个<strong>多层级的节点命名空间</strong>（节点称为 znode）。与文件系统不同的是，这些节点都可以<strong>设置关联的数据</strong>，而文件系统中只有文件节点可以存放数据而目录节点不行。</p><p>Zookeeper 为了保证高吞吐和低延迟，在<strong>内存中</strong>维护了这个树状的目录结构，这种特性使得 Zookeeper <strong>不能用于存放大量的数据</strong>，每个节点的存放数据<strong>上限</strong>为<strong>1M</strong>。</p><h1 id="Zookeeper-怎么保证主从节点的状态同步？"><a href="#Zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="Zookeeper 怎么保证主从节点的状态同步？"></a>Zookeeper 怎么保证主从节点的状态同步？</h1><p>Zookeeper 的核心是<strong>原子广播机制</strong>，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 <strong>Zab 协议</strong>。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p><h2 id="恢复模式"><a href="#恢复模式" class="headerlink" title="恢复模式"></a>恢复模式</h2><p>当<strong>服务启动</strong>或者在<strong>领导者崩溃</strong>后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h2 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h2><p>一旦 <strong>leader 已经和多数的 follower 进行了状态同步后</strong>，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。</p><h1 id="四种类型的数据节点-Znode"><a href="#四种类型的数据节点-Znode" class="headerlink" title="四种类型的数据节点 Znode"></a>四种类型的数据节点 Znode</h1><h2 id="持久节点"><a href="#持久节点" class="headerlink" title="持久节点"></a>持久节点</h2><p>除非<strong>手动删除</strong>，否则节点一直存在于 Zookeeper 上</p><h2 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h2><p>临时节点的生命周期与<strong>客户端会话</strong>绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</p><h2 id="持久顺序节点"><a href="#持久顺序节点" class="headerlink" title="持久顺序节点"></a>持久顺序节点</h2><p>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由<strong>父节点</strong>维护的<strong>自增整型</strong>数字。</p><h2 id="临时顺序节点"><a href="#临时顺序节点" class="headerlink" title="临时顺序节点"></a>临时顺序节点</h2><p>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p><h1 id="Zookeeper-的典型应用场景"><a href="#Zookeeper-的典型应用场景" class="headerlink" title="Zookeeper 的典型应用场景"></a>Zookeeper 的典型应用场景</h1><p>Zookeeper 是一个典型的发布/订阅模式的分布式数据管理与协调框架，开发人员可以使用它来进行分布式数据的发布和订阅。</p><p>通过对 Zookeeper 中丰富的数据节点进行交叉使用，配合 Watcher 事件通知机制，可以非常方便的构建一系列分布式应用中年都会涉及的核心功能，如：</p><ol><li>数据发布/订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调/通知</li><li>集群管理</li><li>Master 选举</li><li>分布式锁</li><li>分布式队列</li></ol><h1 id="Zookeeper的通知机制"><a href="#Zookeeper的通知机制" class="headerlink" title="Zookeeper的通知机制"></a>Zookeeper的通知机制</h1><p>客户端会对某个 znode 建立一个 <strong>watcher</strong> 事件，当该 znode 发生<strong>变化</strong>时，这些客户端会收到 zookeeper 的<strong>通知</strong>，然后客户端可以根据 znode 变化来做出业务上的改变。</p><h1 id="Zookeeper的分布式锁实现方式"><a href="#Zookeeper的分布式锁实现方式" class="headerlink" title="Zookeeper的分布式锁实现方式"></a>Zookeeper的分布式锁实现方式</h1><p>在讲zk分布锁之前，先看下zookeeper中几个关于节点的有趣的性质：</p><ol><li>有序节点：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；zookeeper提供了一个<strong>可选的有序特性</strong>，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。</li><li>临时节点：客户端可以建立一个临时节点，在<strong>会话结束或者会话超时后</strong>，zookeeper会<strong>自动删除</strong>该节点。</li><li>事件监听：在<strong>读取数据</strong>时，我们可以同时对节点<strong>设置事件监听</strong>，当节点<strong>数据或结构变化</strong>时，zookeeper会通知客户端。当前zookeeper有如下四种事件： 1、节点创建；2、节点删除；3、节点数据修改；4、子节点变更。</li></ol><p>下面描述使用zookeeper实现分布式锁的算法流程，假设锁空间的根节点为/lock：</p><ol><li>客户端连接zookeeper，并在/lock下创建<strong>临时的且有序的子节点</strong>，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推。</li><li>客户端<strong>获取</strong>/lock下的<strong>子节点列表</strong>，<strong>判断</strong>自己创建的子节点<strong>是否</strong>为当前子节点列表中<strong>序号最小</strong>的子节点，如果<strong>是</strong>则认为<strong>获得锁</strong>，否则监听/lock的子节点变更消息，获得子节点变更通知后重复此步骤直至获得锁；</li><li>执行业务代码；</li><li>完成业务流程后，删除对应的子节点释放锁。</li></ol><h1 id="Zookeeper-采用的哪种分布式一致性协议-还有哪些分布式一致性协议"><a href="#Zookeeper-采用的哪种分布式一致性协议-还有哪些分布式一致性协议" class="headerlink" title="Zookeeper 采用的哪种分布式一致性协议? 还有哪些分布式一致性协议"></a>Zookeeper 采用的哪种分布式一致性协议? 还有哪些分布式一致性协议</h1><p>zab协议是zookeeper专门设计的<strong>支持崩溃恢复</strong>的原子广播协议。目的是实现分布式zoopkeeper各个节点数据一致性。</p><p>zab协议约定zk节点有<strong>两种角色leader和follower</strong>,zk客户端会随机的链接到 zookeeper 集群中的一个节点，如果是<strong>读请求</strong>，就<strong>直接</strong>从当前节点中<strong>读取数据</strong>；如果是<strong>写请求</strong>，那么节点就会向 <strong>Leader 提交事务</strong>，Leader 接收到事务提交，会<strong>广播该事务</strong>，只要<strong>超过半数</strong>节点<strong>写入成功</strong>，该事务就会被提交。</p><p>ZAB协议包括两种基本的模式：<strong>消息广播和崩溃恢复</strong>。</p><p>整个 Zookeeper 就是在这两个模式之间切换。 简而言之，当 <strong>Leader 服务可以正常使用</strong>，就进入<strong>消息广播</strong>模式，当 <strong>Leader 不可用</strong>时，则进入<strong>崩溃恢复模式</strong>。</p><p>以上其实大致经历了三个步骤：</p><ol><li>崩溃恢复：主要就是<strong>Leader选举</strong>过程。</li><li>数据同步：Leader服务器与其他服务器进行数据同步。</li><li>消息广播：Leader服务器将数据发送给其他服务器。</li></ol><p>支持崩溃恢复后数据准确性的就是数据同步了，数据同步基于事务的 ZXID 的唯一性来保证。通过 + 1 操作可以辨别事务的先后顺序。</p><h2 id="ZAD和Paxos算法的联系和区别"><a href="#ZAD和Paxos算法的联系和区别" class="headerlink" title="ZAD和Paxos算法的联系和区别"></a>ZAD和Paxos算法的联系和区别</h2><p>共同点：</p><ol><li>两者都存在一个类似于Leader进程的角色，由其负责协调多个Follow进程的运行。</li><li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交。</li><li>在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前Leader周期，在Paxos算法中，同样存在这样一个标识，只是名字变成了Ballot。 不同点：</li></ol><p>Paxos算法中，一个新的选举产生的主进程会进行两个阶段的工作</p><ol><li>读阶段，新的主进程会通过和所有其他进程进行通信的方式来搜集上一个主进程提出的提案，并将它们提交。</li><li>写阶段，当前主进程开始提出它自己的提案。</li><li>ZAB在Paxos基础上额外添加一个同步阶段。同步阶段之前，ZAB协议存在一个和Paxos读阶段类似的发现（Discovery）阶段</li></ol><p>同步阶段中，新的Leader会确保存在过半的Follower已经提交了之前Leader周期中的所有事务Proposal</p><ul><li>发现阶段的存在，确保所有进程都已经完成对之前所有事物Proposal的提交</li><li>ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如ZooKeeper，Paxos算法则是用于构建一个分布式的一致性状态机系统</li></ul><h1 id="集群中为什么要有主节点"><a href="#集群中为什么要有主节点" class="headerlink" title="集群中为什么要有主节点"></a>集群中为什么要有主节点</h1><p>在分布式环境中，有些业务逻辑<strong>只需要</strong>集群中的<strong>某一台机器进行执行</strong>，</p><p><strong>其他的机器可以共享</strong>这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点</p><h1 id="leader-选举过程"><a href="#leader-选举过程" class="headerlink" title="leader 选举过程"></a>leader 选举过程</h1><p>重要属性</p><ul><li>服务器 ID(myid)：编号越大在选举算法中权重越大</li><li>事务 ID(zxid)：值越大说明数据越新，权重越大</li><li>逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加</li></ul><p>有两种情况会发起Leader选举：</p><ol><li>服务器<strong>启动</strong>的时候</li><li>服务器运行的时候当<strong>Leader宕机</strong></li></ol><p>在讲解流程之前，先说明一下选举流程中涉及到的角色：</p><ul><li>LOOKING：寻找Leader状态，处于该状态需要进入选举流程（只有该节点才可以投票）</li><li>LEADING：领导者状态，处于该状态的节点说明是角色已经是Leader</li><li>FOLLOWING：跟随者状态，表示Leader已经选举出来，当前节点角色是follower</li><li>OBSERVER：观察者状态，表明当前节点角色是observer（该节点不参与竞选）</li></ul><p>三个核心选举原则：</p><ol><li>Zookeeper集群中只有<strong>超过半数</strong>以上的服务器启动，集群才能<strong>正常工作</strong>；</li><li>在集群正常工作之前，myid小的服务器给myid大的服务器投票，直到集群正常工作，选出Leader；</li><li>选出Leader之后，之前的服务器状态由Looking改变为Following，以后的服务器都是Follower。</li></ol><p>下面以一个简单的例子来说明整个选举的过程：</p><p>假设有五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是<strong>最新启动</strong>的，也就是<strong>没有历史数据</strong>，在存放数据量这一点上，都是一样的。</p><p>假设这些服务器从id1-5，依序启动：</p><p>因为一共5台服务器，只有超过半数以上，即最少启动3台服务器，集群才能正常工作。</p><p><strong>（1）服务器1启动，发起一次选举。</strong> 服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成；</p><p>服务器1状态保持为LOOKING；</p><p><strong>（2）服务器2启动，再发起一次选举。</strong></p><p>服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2；</p><p>此时服务器1票数0票，服务器2票数2票，不够半数以上（3票），选举无法完成；</p><p>服务器1，2状态保持LOOKING；</p><p><strong>（3）服务器3启动，发起一次选举。</strong></p><p>与上面过程一样，服务器1和2先投自己一票，然后因为服务器3id最大，两者更改选票投给为服务器3；</p><p>此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数（3票），服务器3当选Leader。</p><p>服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</p><p><strong>（4）服务器4启动，发起一次选举。</strong></p><p>此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。</p><p>此时服务器4服从多数，更改选票信息为服务器3；</p><p>服务器4并更改状态为FOLLOWING；</p><p><strong>（5）服务器5启动，同4一样投票给3，此时服务器3一共5票，服务器5为0票；</strong></p><p>服务器5并更改状态为FOLLOWING；</p><p><strong>（6）选举结果</strong></p><p>最终Leader是服务器3，状态为LEADING；</p><p>其余服务器是Follower，状态为FOLLOWING。</p><p><img src="/2021/06/11/zookeeper/zookeeper%5Cimage-20210611101748929.png" alt="image-20210611101748929"></p><h3 id="运行过程中的-leader-选举"><a href="#运行过程中的-leader-选举" class="headerlink" title="运行过程中的 leader 选举"></a>运行过程中的 leader 选举</h3><p>当集群中 leader 服务器出现宕机或者不可用情况时，整个集群无法对外提供服务，进入新一轮的 leader 选举。</p><ul><li>（1）变更状态。leader 挂后，其他<strong>非 Oberver</strong>服务器将自身服务器状态变更为 LOOKING。</li><li>（2）每个 server 发出一个投票。在运行期间，每个服务器上 zxid 可能不同。</li><li>（3）处理投票。规则同启动过程。</li><li>（4）统计投票。与启动过程相同。</li><li>（5）改变服务器状态。与启动过程相同。</li></ul><h1 id="Zookeeper与Eureka的区别"><a href="#Zookeeper与Eureka的区别" class="headerlink" title="Zookeeper与Eureka的区别"></a>Zookeeper与Eureka的区别</h1><h2 id="结构上"><a href="#结构上" class="headerlink" title="结构上"></a>结构上</h2><p>1、<strong>Zookeeper是主从架构</strong> 2、Eureka是点对点，节点都是<strong>平级的</strong></p><h2 id="高可用与强一致性"><a href="#高可用与强一致性" class="headerlink" title="高可用与强一致性"></a>高可用与强一致性</h2><p>1、Zookeeper当master挂了，会在30-120s进行leader选举，这点类似于redis的哨兵机制，在选举期间Zookeeper是不可用的，这么长时间不能进行服务注册，是无法忍受的，别说30s，5s都不能忍受。这时Zookeeper集群会瘫痪，这也是Zookeeper的CP，保持节点的一致性，牺牲了A高可用。而Eureka不会，这就是AP，牺牲了C一致性。</p><p>2、即使Eureka有部分挂掉，还有其他节点可以使用的，他们保持平级的关系，只不过信息有可能不一致。</p><p>当坏掉的服务恢复的时候，会自动加入到节点上，也是高可用的一种。然后退出自我保护机制，这也是应对网络异常的一种机制</p><h2 id="Eureka的自我保护机制"><a href="#Eureka的自我保护机制" class="headerlink" title="Eureka的自我保护机制"></a>Eureka的自我保护机制</h2><p>在默认配置中，Eureka Server在默认90s没有得到客户端的心跳，则注销该实例，但是往往因为微服务跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，但是因为网络分区故障时，Eureka Server注销服务实例则会让大部分微服务不可用，这很危险，因为服务明明没有问题。</p><p>为了解决这个问题，Eureka 有自我保护机制，通过在Eureka Server配置如下参数，可启动保护机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.server.enable-self-preservation=true</span><br></pre></td></tr></table></figure><p>如果在<strong>15分钟内超过85%的节点</strong>都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了<strong>网络故障</strong>，此时会出现以下几种情况：</p><ol><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li></ol><p>它的原理是，<strong>当Eureka Server节点在短时间内丢失过多的客户端时（可能发送了网络故障），那么这个节点将进入自我保护模式，不再注销任何微服务，当网络故障恢复后，该节点会自动退出自我保护模式</strong>。</p><p>自我保护模式的架构哲学是宁可放过一个，决不可错杀一千</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ZooKeeper 是一个开源的&lt;strong&gt;分布式协调服务&lt;/strong&gt;。它是一个为&lt;strong&gt;分布式&lt;/strong&gt;应用提供&lt;strong&gt;一致性&lt;/strong&gt;服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://cenkii.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>mybatis</title>
    <link href="https://cenkii.github.io/2021/06/10/mybatis/"/>
    <id>https://cenkii.github.io/2021/06/10/mybatis/</id>
    <published>2021-06-10T13:25:00.457Z</published>
    <updated>2021-06-10T13:26:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>1.约束文件  “<a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;">http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</a> 定义限制当前文件中的标签属性及顺序</p><p>2.mapper 根标签  </p><p>​    namespace命名空间唯一不为空（全限定名称）</p><p>​    mapper里可以有多个标签</p><p>3.select id方法的唯一标识，是一个自定义的字符串。一般使用方法的名称</p><p>​               resultType 执行SQL语句返回数据赋值的Java对象（全限定名称）</p><p>4.#{id} 占位符从java中传过来的数据</p><p>​      传入值为一个对象xml使用#{属性名}的形式</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--配置数据源创建connection对象--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--驱动的内容--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--数据库的地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--指定其他mapper文件的位置</span></span><br><span class="line"><span class="comment">找到其他mapper文件中的sql语句--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--路径起始为target/classes--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mybatis使用"><a href="#mybatis使用" class="headerlink" title="mybatis使用"></a>mybatis使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义主配置配置文件位置</span></span><br><span class="line">String resource = <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="comment">//getResourceAsStream读取主配置文件</span></span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="comment">//创建sqlSessionFactory对象</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"><span class="comment">//获取SqlSession对象</span></span><br><span class="line">SqlSession session = factory.openSession();</span><br><span class="line"><span class="comment">//指定要执行sql语句</span></span><br><span class="line"><span class="comment">//规范命名空间 + id 值</span></span><br><span class="line">String sql = <span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>+<span class="string">&quot;.&quot;</span>+<span class="string">&quot;selectBlog&quot;</span>;</span><br><span class="line"><span class="comment">//执行sql</span></span><br><span class="line">Blog blog = session。selectOne(sql);</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">session。close();</span><br></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>insert,update,delete需要提交</p><p>自动提交：sql语句执行即提交事务直接保存到数据库</p><p>手动提交(默认)：sql语句执行完毕手动调用提交事务，session.commit()</p><h3 id="重要对象"><a href="#重要对象" class="headerlink" title="重要对象"></a>重要对象</h3><h4 id="1-resource"><a href="#1-resource" class="headerlink" title="1.resource"></a>1.resource</h4><p>：用于读取主配置中的信息</p><h4 id="2-SqlSessionFactoryBuilder"><a href="#2-SqlSessionFactoryBuilder" class="headerlink" title="2.SqlSessionFactoryBuilder"></a>2.SqlSessionFactoryBuilder</h4><p>：用于创建SqlSessionFactory对象</p><h4 id="3-SqlSessionFactory"><a href="#3-SqlSessionFactory" class="headerlink" title="3.SqlSessionFactory"></a>3.SqlSessionFactory</h4><p>：重要对象</p><p>它是一个重量级对象，即创建这个对象需要使用较多的资源和时间。在项目中有一个就ok</p><p>SqlSessionFactory接口：作用SqlSession工厂用于创建SqlSession对象</p><p>SqlSessionFactory中的方法</p><p>openSession：获取默认的SqlSession对象</p><p>openSession(boolean):boolean表示是否自动提交事务，如果为false同上即为默认SqlSession</p><h4 id="4-SqlSession"><a href="#4-SqlSession" class="headerlink" title="4.SqlSession"></a>4.SqlSession</h4><p>接口对象，实现类DefaultSqlSession</p><p>提供执行sql语句的，以及提交回滚等方法</p><p>SqlSession不是线程安全的，使用步骤</p><p>1）方法内部执行sql之前先获取SqlSession对象</p><p>2）调用SqlSession执行sql</p><p>3）关闭SqlSession对象</p><h3 id="dao代理"><a href="#dao代理" class="headerlink" title="dao代理"></a>dao代理</h3><p>mybatis代理技术：由mybatis创建Dao接口实现类对象，完成对sql语句的执行。mybatis船舰的对象代替你的dao实现类功能。</p><p>要求：</p><p>mapper 的 namespace为dao的全限名称</p><p>标签是id方法的名称</p><p>实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">SqlSession session = factory.openSession();</span><br><span class="line">BlogDao blogDao = session.getMapper(BlogDao.class);</span><br><span class="line">等同于</span><br><span class="line">BlogDao blogDao = <span class="keyword">new</span> BlogDaoImpl();</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="parameterType"><a href="#parameterType" class="headerlink" title="parameterType"></a>parameterType</h4><p>parameterType：表示参数的类型，指定dao方法的形参数据类型。这个形参的数据类型是给mybatis的sql语句在数据赋值时使用的。用法PreparedStatement.setXXX(位置，值)</p><p>parameterType通常为全限定名称或别名</p><p>mybatis通过反射机制可以获取到dao参数类型，可以省略不写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">parameterType</span> = <span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--代码的具体执行方式为</span></span><br><span class="line"><span class="comment">PreparedStatement pst = conn.preparedStatement(&quot;select * from Blog where id = ?&quot;);</span></span><br><span class="line"><span class="comment">pst.setInt(1,1001);</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="一个简单类型参数"><a href="#一个简单类型参数" class="headerlink" title="一个简单类型参数"></a>一个简单类型参数</h4><p>当参数为简单类型参数且只有一个是，直接用#{任意字符}即可获取dao传过来的参数</p><h4 id="多个简单类型参数"><a href="#多个简单类型参数" class="headerlink" title="多个简单类型参数"></a>多个简单类型参数</h4><p>当有多个时，需要使用@Param(“name”)参数进行传参，在mapper中用#{name}获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByColumn</span><span class="params">(<span class="meta">@Param(&quot;column&quot;)</span> String column, <span class="meta">@Param(&quot;value&quot;)</span> String value)</span></span>;</span><br><span class="line"><span class="comment">//mapper中</span></span><br><span class="line"><span class="comment">//$&#123;column&#125;会直接替换为指定的字符，不做？处理</span></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span><br><span class="line">  &lt;select id=<span class="string">&quot;selectBlog&quot;</span> resultType=<span class="string">&quot;Blog&quot;</span> parameterType = <span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span><br><span class="line">    select * from user where $&#123;column&#125; = #&#123;value&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h4 id="一个对象做参数"><a href="#一个对象做参数" class="headerlink" title="一个对象做参数"></a>一个对象做参数</h4><p>一个对象做参数调用对象属性作为参数，mybatis会直接调用get方法获取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.someapp.model;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String hashedPassword;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getHashedPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHashedPassword</span><span class="params">(String hashedPassword)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashedPassword = hashedPassword;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.someapp.model.User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="按位置（了解）"><a href="#按位置（了解）" class="headerlink" title="按位置（了解）"></a>按位置（了解）</h4><p>#{arg0}，#{arg1}从左往右依次获取</p><h4 id="按map传参（了解）"><a href="#按map传参（了解）" class="headerlink" title="按map传参（了解）"></a>按map传参（了解）</h4><p>传入Map&lt;String,Object&gt; map,通过key值获取#{key}的值</p><h4 id="和"><a href="#和" class="headerlink" title="#和$"></a>#和$</h4><p>#{}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pst = conn.preparedStatement(<span class="string">&quot;select * from Blog where id = ?&quot;</span>);</span><br><span class="line">pst.setInt(<span class="number">1</span>,<span class="number">1001</span>);</span><br></pre></td></tr></table></figure><p>特点：</p><p>效率高，更安全，常作为列值使用</p><p>${}</p><p>表示字符串连接即直接连接 ${}里面的内容和sql语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement st = conn.createStatement(<span class="string">&quot;select * from Blog where id = ?&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用createStatement执行sql效率低</p><p>使用@param()进行传参，原样替换不带引号</p><p>使用字符串进行连接由sql注入风险</p><p>常用作表名列名</p><h4 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h4><h5 id="1-返回对象"><a href="#1-返回对象" class="headerlink" title="1.返回对象"></a>1.返回对象</h5><p>1、使用全限定名称</p><p>使用全限定名称，表示mybatis执行sql语句，把resultSet中的数据转换为指定对象。具体操作如下：</p><p>1.调用 类的 无参构造方法创建对象，使用反射创建对象</p><p>2.同名的列赋值给同名属性</p><p>3.如果返回值为list则将 对象放入list中</p><p>2、使用自定义别名</p><p>在mybatis主配置文件中使用typeAlias 声明别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml 中 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.someapp.model.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 方式二 </span></span><br><span class="line"><span class="comment">即将model下的类名作为别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">&quot;com.someapp.model&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- SQL 映射 XML 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-返回基本类型"><a href="#2-返回基本类型" class="headerlink" title="2.返回基本类型"></a>2.返回基本类型</h5><p>java.lang.xxx</p><h5 id="3-返回map"><a href="#3-返回map" class="headerlink" title="3.返回map"></a>3.返回map</h5><p>java.util.HashMap</p><p>列明会作为key</p><p>列值会做为value</p><h5 id="列名属性名不同"><a href="#列名属性名不同" class="headerlink" title="列名属性名不同"></a>列名属性名不同</h5><p>使用别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id as cid，name as cname from table</span><br></pre></td></tr></table></figure><h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>resultMap和resultType二选一</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--列名属性名一一对应--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--主键形式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--非主键形式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--列名属性名相同可以不用定义--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--解决列名属性名不同--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">  select user_id, user_name, hashed_password</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><p>方式一：在Java程序中组织好，传入到sql中（推荐使用）</p><p>方式二：在sql语句中组织like格式 where name like “%”  #{} “%” </p><h3 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h3><p>动态sql即：同一个dao方法根据不同条件表示不同的语句，主要where部分有变化</p><p>dao形参使用Java对象</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogLike&quot;</span></span><br><span class="line">     resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  &lt;<span class="keyword">if</span> test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> test=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>只有if无else</p><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogLike&quot;</span></span><br><span class="line">     resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;state != null&quot;</span>&gt;</span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectPostIn&quot;</span> resultType=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  &lt;foreach item=<span class="string">&quot;item&quot;</span> index=<span class="string">&quot;index&quot;</span> collection=<span class="string">&quot;list&quot;</span></span><br><span class="line">      open=<span class="string">&quot;(&quot;</span> separator=<span class="string">&quot;,&quot;</span> close=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/select</span><br></pre></td></tr></table></figure><p>如果list泛型为对象则 #{item.属性名}</p><h3 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h3><h4 id="1-主配置文件"><a href="#1-主配置文件" class="headerlink" title="1.主配置文件"></a>1.主配置文件</h4><p>提供mybatis的全局配置，包含日志、数据源、mapper文件的位置</p><h5 id="setting部分"><a href="#setting部分" class="headerlink" title="setting部分"></a>setting部分</h5><p>mybatis的全局设置，影响整个mybatis的运行</p><h5 id="typeAlias"><a href="#typeAlias" class="headerlink" title="typeAlias"></a>typeAlias</h5><p>设置别名，见上</p><h5 id="environments配置环境"><a href="#environments配置环境" class="headerlink" title="environments配置环境"></a>environments配置环境</h5><p>environments环境标签可以配置多个environment   default为其他environment id表示用哪个环境</p><p>environment表示：一个数据库的连接信息</p><p>​                        属性id：代表自定义的环境唯一标识符。</p><p>transactionManager：事务管理器</p><p>​                        属性type：事务管理器的类型</p><p>​                        属性值JDBC：使用connection，由mybatis自己完成事务的管理</p><p>​                                    MANAGED：管理，表示把事务处理交给容器来实现（提交回滚）</p><p>dataSource：数据源，创建的connection对象，连接数据库。</p><p>​                                        type数据源类型</p><p>​                                        pooled：mybatis会使用pooledDataSource类管理多个connection连接对象，使用连接池</p><p>​                                        unpooled：不使用连接池，先创建，后关闭，少用</p><p>​                                        JNDI：命名的事务和服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h5><p>使用mapper指定其他mapper文件位置</p><p>方式一</p><mapper resource="路径"><p>方式二</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="外部配置文件"><a href="#外部配置文件" class="headerlink" title="外部配置文件"></a>外部配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span> = <span class="string">&quot;jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">$&#123;&#125;形式使用</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a>PageHelper</h3><p>分页插件</p><h2 id="MyBatis介绍"><a href="#MyBatis介绍" class="headerlink" title="MyBatis介绍"></a>MyBatis介绍</h2><p>在介绍MyBatis之前先简单了解几个概念：ORM，JPA。</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM（Object-Relationship-Mapping）：是对象关系映射的意思，它是一种思想，是指将数据库中的每一行数据用对象的形式表现出来。</p><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>JPA（Java-Persistence-API）：是Java持久化接口的意思，它是JavaEE关于ORM思想的一套标准接口，仅仅是一套接口，不是具体的实现。</p><h3 id="MyBatis概念"><a href="#MyBatis概念" class="headerlink" title="MyBatis概念"></a>MyBatis概念</h3><p>MyBatis是一个实现了JPA规范的用来连接数据库并对其进行增删改查操作的开源框架 （就和传统的JDBC一样，就是个连接数据库的东西），其实，它底层就是一个JDBC封装的组件。MyBatis的前身是Ibatis，Ibatis创建与2002年最初为Apache下面的一个开源项目，2010迁移到google code下面并改名为MyBatis。</p><p>MyBatis虽然实现了JPA但是它并不是一个完完全全的ORM组件，而是一个基于SQL开发的半ORM组件。</p><p>而Hibernate是一个完完全全的ORM组件，它是完全基于对象来操作数据库中的记录，并不和MyBatis一样是一个假把式。</p><h3 id="MyBatis优点"><a href="#MyBatis优点" class="headerlink" title="MyBatis优点"></a>MyBatis优点</h3><ul><li>简单易学，容易上手（相比于Hibernate） —- 基于SQL编程</li><li>消除了JDBC大量冗余的代码，不需要手动开关连接</li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDB提供了可扩展性，所以只要这个数据库有针对Java的jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。</li><li>提供了很多第三方插件（分页插件 / 逆向工程）</li><li>能够与Spring很好的集成</li></ul><h2 id="MyBatis原理"><a href="#MyBatis原理" class="headerlink" title="MyBatis原理"></a>MyBatis原理</h2><p><strong>MyBatis完成2件事情</strong></p><ol><li>封装JDBC操作</li><li>利用反射打通Java类与SQL语句之间的相互转换</li></ol><p><strong>MyBatis的主要成员</strong></p><ol><li>Configuration MyBatis所有的配置信息都保存在Configuration对象之中，配置文件中的大部分配置都会存储到该类中</li><li>SqlSession 作为MyBatis工作的主要顶层API，表示和数据库交互时的会话，完成必要数据库增删改查功能</li><li>Executor MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护</li><li>StatementHandler 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数等</li><li>ParameterHandler 负责对用户传递的参数转换成JDBC Statement 所对应的数据类型</li><li>ResultSetHandler 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合</li><li>TypeHandler 负责java数据类型和jdbc数据类型(也可以说是数据表列类型)之间的映射和转换</li><li>MappedStatement MappedStatement维护一条select|update|delete|insert节点的封装</li><li>SqlSource 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li><li>BoundSql 表示动态生成的SQL语句以及相应的参数信息</li></ol><h3 id="MyBatis的设计思想"><a href="#MyBatis的设计思想" class="headerlink" title="MyBatis的设计思想"></a>MyBatis的设计思想</h3><p>如果让我们自己设计一个MyBatis，那么最核心的思想是什么呢？</p><p>答案：JDK动态代理和反射</p><p>MyBatis的作用就是<strong>调用一个Mapper接口的方法就相当于执行一条sql</strong></p><p>1、MyBatis在SqlSession为给Mapper接口通过动态代理实现一个代理 2、在代理方法里面通过反射获取接口名称、方法名称、参数，拿这些数据后执行Executor的jdbc与sql交互的方法（这个才是真正去执行sql） 3、执行sql的结果集通过反射设置到Bean对象里面返回</p><p>注意<strong>InvocationHandler</strong>接口，这是proxy代理实例的调用处理程序实现的一个接口</p><p>mapper映射器其实就是一个动态代理对象，进入到MapperMethod的方法就能找到SqlSession的删除、更新、查询、选择方法，从底层实现来说：通过动态代理技术，让接口跑起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMapperProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MySqlSession sqlSession;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMapperProxy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMapperProxy</span><span class="params">(MySqlSession sqlSession)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在代理方法里面通过反射获取接口名称、方法名称、参数，拿这些数据后执行Executor的jdbc与sql交互的方法（这个才是真正去执行sql）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String mapperClass = method.getDeclaringClass().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;mapperClass&quot;</span>+mapperClass);</span><br><span class="line">        <span class="keyword">if</span> (UserMapperXML.namespace.equals(mapperClass))&#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            String originsql = UserMapperXML.getMethodSql(methodName);</span><br><span class="line">            String formatSql = String.format(originsql,String.valueOf(args[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> sqlSession.selectOne(formatSql);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据命名空间，找出与mapper接口方法名相同的sql语句，然后交给sqlSession来执行。（这里用到反射）</p><h2 id="一级缓存和二级缓存"><a href="#一级缓存和二级缓存" class="headerlink" title="一级缓存和二级缓存"></a>一级缓存和二级缓存</h2><p>MyBatis提供查询缓存，用于减轻数据库压力，提高性能。MyBatis提供了一级缓存和二级缓存。</p><ol><li>一级缓存是SqlSession级别的缓存，每个SqlSession对象都有一个哈希表用于缓存数据，不同SqlSession对象之间缓存不共享。同一个SqlSession对象对象执行2遍相同的SQL查询，在第一次查询执行完毕后将结果缓存起来，这样第二遍查询就不用向数据库查询了，直接返回缓存结果即可。一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存，用户没有定制它的权利</li><li>二级缓存是Application应用级别的缓存，它的是生命周期很长，跟Application的声明周期一样，也就是说它的作用范围是整个Application应用。MyBatis默认是不开启二级缓存的，可以在配置文件中使用如下配置来开启二级缓存</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>MyBatis 的一级缓存与二级缓存，是针对短时间内重复查询而做的优化：</p><ul><li>一级缓存<ul><li>Mybatis 默认只是开启一级缓存，一级缓存只是相对于同一个 SqlSession 而言。</li><li>只有在参数和SQL完全一样的情况下，并且使用同一个 SqlSession 的情况下，Mybatis 才会将第一次的查询结果缓存起来，后续同一个SqlSession的再查询，就会命中缓存，而不是去直接查库</li></ul></li><li>二级缓存<ul><li>一级缓存对于使用不同的 SqlSession 并不会命中缓存，即一级缓存必须 SqlSession，参数与Sql必须完全一致</li><li>二级缓存需要手动配置，使得缓存在SqlSessionFactory层面上能够提供给各个Sql Session 共享</li><li>二级缓存能够对同样参数，同样Sql语句，当时不同 SqlSession的查询提供命中</li></ul></li></ul><h3 id="为什么不推荐使用二级缓存？"><a href="#为什么不推荐使用二级缓存？" class="headerlink" title="为什么不推荐使用二级缓存？"></a>为什么不推荐使用二级缓存？</h3><p>MyBatis 的二级缓存是和命名空间绑定的，所以通常情况下每一个 Mapper 映射文件都拥有 自己的二级缓存，不同 Mapper 的二级缓存互不影响。</p><p>在常见的数据库操作中，多表联合查询非常常见，由于关系型数据库的设计， 使得很多时候需要关联多个表才能获得想要的数据。在关联多表查询时肯定会将该查询放到某个命名空间下的映射文件中，这样一个多表的查询就会缓存在该命名空间的二级缓存中。涉及这些表的增、删、改操作通常不在一个映射文件中，它们 的命名空间不同， 因此当有数据变化时，多表查询的缓存未必会被清空，这种情况下就会产生脏数据。</p><h3 id="二级缓存的使用场景"><a href="#二级缓存的使用场景" class="headerlink" title="二级缓存的使用场景"></a>二级缓存的使用场景</h3><ol><li>以查询为主的应用中，只有尽可能少的增、删、改操作；</li><li>绝大多数以单表操作存在时，由于很少存在互相关联的情况，因此不会出现脏数据。</li></ol><h2 id="MyBatis使用的设计模式"><a href="#MyBatis使用的设计模式" class="headerlink" title="MyBatis使用的设计模式"></a>MyBatis使用的设计模式</h2><ol><li>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</li><li>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li><li>单例模式，例如ErrorContext和LogFactory；</li><li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li><li>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</li><li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li><li>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li><li>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li><li>迭代器模式，例如迭代器模式PropertyTokenizer；</li></ol><h2 id="MyBatis插件"><a href="#MyBatis插件" class="headerlink" title="MyBatis插件"></a>MyBatis插件</h2><p>Mybatis插件又称拦截器，Mybatis采用责任链模式，通过动态代理组织多个插件（拦截器），通过这些插件可以改变Mybatis的默认行为（诸如SQL重写之类的），MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的Mybatis四大接口方法调用包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</span><br><span class="line"></span><br><span class="line">ParameterHandler (getParameterObject, setParameters)</span><br><span class="line"></span><br><span class="line">ResultSetHandler (handleResultSets, handleOutputParameters)</span><br><span class="line"></span><br><span class="line">StatementHandler (prepare, parameterize, batch, update, query)</span><br></pre></td></tr></table></figure><p>总体概括为：</p><ol><li>拦截执行器的方法</li><li>拦截参数的处理</li><li>拦截结果集的处理</li><li>拦截SQL语法构建的处理</li></ol><h3 id="插件的构建"><a href="#插件的构建" class="headerlink" title="插件的构建"></a>插件的构建</h3><p>谈原理首先要知道StatementHandler，ParameterHandler，Result Handler都是代理，他们是Configuration创建，在创建过程中会调用interceptorChain.pluginAll()方法，为四大组件组装插件（再底层是通过Plugin.wrap(target,XX, new Plugin( interceptor))来来创建的）。</p><h3 id="插件链是何时构建的"><a href="#插件链是何时构建的" class="headerlink" title="插件链是何时构建的"></a>插件链是何时构建的</h3><p>在执行SqlSession的query或者update方法时，SqlSession会通过Configuration创建Executor代理，在创建过程中就调用interceptor的pluginAll方法组装插件。然后executor在调用doQuery（）方法的时候，也会调用Configuration的newStatementHandler方法创建StatemenHandler（和上面描述的一样，这个handler就是个代理，也是通过interceptorChain的pluginAll方法构建插件）</p><h3 id="插件如何执行"><a href="#插件如何执行" class="headerlink" title="插件如何执行"></a>插件如何执行</h3><p>以statementhandler的prepare方法的插件为例，正如前面所说，statementhandler是一个proxy，执行他的prepare方法，将调用invokeHandler的invoke方法，而invokeHandler就是Plugin.wrap(target, xxx, new Plugin(interceptor))中的第三个参数，所以很自然invokeHanlder的invoke的方法最终就会调用interceptor对象的intercept方法。</p><p>PageHelper分页的实现原来是在我们执行SQL语句之前动态的将SQL语句拼接了分页的语句，从而实现了从数据库中分页获取的过程。</p><h2 id="数据库预编译为什么能防止SQL注入呢？"><a href="#数据库预编译为什么能防止SQL注入呢？" class="headerlink" title="数据库预编译为什么能防止SQL注入呢？"></a>数据库预编译为什么能防止SQL注入呢？</h2><p>所谓SQL注入，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力。</p><p>因为SQL语句在程序运行前已经进行了预编译，在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库已参数化的形式进行查询，当运行时动态地把参数传给PreprareStatement时，<strong>即使参数里有敏感字符如 or ‘1=1’也数据库会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令</strong>，如此，就起到了SQL注入的作用了！</p><p>如果我们想防止SQL注入，理所当然地要在输入参数上下功夫。上面代码中黄色高亮即输入参数在SQL中拼接的部分，传入参数后，打印出执行的SQL语句，会看到SQL是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,title,author,content <span class="keyword">FROM</span> blog <span class="keyword">WHERE</span> id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>不管输入什么参数，打印出的SQL都是这样的。这是因为MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。</p></mapper>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mybatis&quot;&gt;&lt;a href=&quot;#mybatis&quot; class=&quot;headerlink&quot; title=&quot;mybatis&quot;&gt;&lt;/a&gt;mybatis&lt;/h2&gt;&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://cenkii.github.io/2021/05/04/docker/"/>
    <id>https://cenkii.github.io/2021/05/04/docker/</id>
    <published>2021-05-04T14:00:39.000Z</published>
    <updated>2021-05-08T03:21:54.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker出现背景"><a href="#docker出现背景" class="headerlink" title="docker出现背景"></a>docker出现背景</h2><p>实际生产过程中经常出现，代码在开发环境中可以跑通，但在运维环境中会出问题。docker技术通过将代码数据配置系统等进行整体打包，来解决经常出现的配置环境不兼容问题。他的理念是“一次封装，处处运行。”</p><h2 id="虚拟机与虚拟化技术"><a href="#虚拟机与虚拟化技术" class="headerlink" title="虚拟机与虚拟化技术"></a>虚拟机与虚拟化技术</h2><p>虚拟机是一种带环境安装的解决方案，它可以在一个系统中运行另一个系统（通过程序同时模拟硬件和软件）。虽然，虚拟机中的操作系统看上去和真实系统一样，但底层操作系统对他的感知只是一个文件不用可以立即删除，对它毫无影响。</p><p>它的缺点：</p><p>资源占用多    冗余步骤多    启动慢</p><p>虚拟化技术</p><p>Linux发展出另一种虚拟化技术，Linux容器（Linux Containers 缩写 LXC）</p><p>与上面相比，他不在模拟整个系统它只需要软件运行所需的资源和设置。</p><p>虚拟机更多面向硬件，docker面向软件层面。前者为分钟级，后者为秒级。</p><h2 id="三大要素"><a href="#三大要素" class="headerlink" title="三大要素"></a>三大要素</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像是用于创建 Docker 容器的模板，</p><p>他是轻量级的可执行安装文件包含必要的依赖环境等。</p><h4 id="加载原理"><a href="#加载原理" class="headerlink" title="加载原理"></a>加载原理</h4><p>由一层一层的文件系统组成（UnionFS）</p><p>bootfs包含：bootloader 和 kernel，bootloader 引导kernel，加载完成之后bootloader 将掌控权转交给kernel。</p><p>rootfs：是基于bootfs的文件系统是Linux的发行版（centos和ubantu等），包含/bin,/dev等标准目录</p><p>不同发行版本的rootfs 有差别但bootfs是一样的，因此docker可以和其他发行版共用bootfs，它自己只需要提供基本的rootfs就行了</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是独立运行的一个或一组应用，是镜像运行时的实体。</p><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><h4 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h4><p>用于容器的数据共享</p><p>docker run -it -v /宿主机绝对路径:/容器内目录  镜像名</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>集中存放镜像的地方</p><p>安装流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y epel-release</span><br><span class="line">[root@localhost ~]# yum install -y docker-io</span><br></pre></td></tr></table></figure><p>启动docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">centos6</span><br><span class="line">service docker start</span><br><span class="line">centos7</span><br><span class="line">systemctl start docker(也可以使用上面的指令，会重定向到这个指令)</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#列出本地镜像</span><br><span class="line">docker images [选项]</span><br><span class="line">#选项 -a：所有(包含中间层)  -q：只显示id  -digest：只显示摘要  -no-trunc：显示所有完整信息</span><br><span class="line"></span><br><span class="line">#从搜索docker hub上搜索</span><br><span class="line">docker search [选项] 名字</span><br><span class="line">#-s：限制<span class="built_in">start</span>数 -s <span class="number">30</span> 只显示<span class="number">30</span>以上的 -no-trunc：显示所有完整信息 </span><br><span class="line"></span><br><span class="line">#下载</span><br><span class="line">docker pull 名称</span><br><span class="line">#默认拉取最新版等价于</span><br><span class="line">docker pull 名称:latest</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">docker rmi 名称</span><br><span class="line">#删除多个</span><br><span class="line">docker rmi 名称 名称二</span><br><span class="line">#全删除</span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#新建并启动</span><br><span class="line">docker run image </span><br><span class="line">-d：守护式进程  </span><br><span class="line">-it：交互式进程</span><br><span class="line"></span><br><span class="line"># 启动容器</span><br><span class="line">docker <span class="built_in">start</span> 容器id</span><br><span class="line"></span><br><span class="line">#停止</span><br><span class="line">docker stop 容器id</span><br><span class="line">#强制停止</span><br><span class="line">docker kill 容器id</span><br><span class="line"></span><br><span class="line">#重启</span><br><span class="line">docker restart 容器id</span><br><span class="line"></span><br><span class="line">#显示所有运行容器</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line">#退出容器</span><br><span class="line"><span class="keyword">exit</span> 退出并停止</span><br><span class="line">ctrl + p + q 退出不停止</span><br><span class="line"></span><br><span class="line">退出后在进入</span><br><span class="line">docker attach 容器id</span><br><span class="line">在外面操作容器内</span><br><span class="line">docker exec -it 容器id</span><br><span class="line"></span><br><span class="line">#显示日志</span><br><span class="line">docker log 容器id</span><br><span class="line"></span><br><span class="line">#查看容器内进程</span><br><span class="line">docker top 容器id</span><br><span class="line"></span><br><span class="line">#查看容器内细节</span><br><span class="line">docker inspect 容器id</span><br><span class="line"></span><br><span class="line">#拷贝容器里的信息</span><br><span class="line">docker cp 容器id:路径 目标路径</span><br><span class="line"></span><br><span class="line">#将自己的镜像提交</span><br><span class="line">docker commit</span><br></pre></td></tr></table></figure><h2 id="Docker-Dockerfile"><a href="#Docker-Dockerfile" class="headerlink" title="Docker Dockerfile"></a>Docker Dockerfile</h2><h3 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h3><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><h4 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h4><p>FROM：定制的镜像都是基于 FROM 的镜像。<br>RUN：用于执行后面跟着的命令行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;] #指定容器数据卷</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><h4 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /mydocker/DockerFile -t cc/centos</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run...</span><br></pre></td></tr></table></figure><h4 id="volumes-from"><a href="#volumes-from" class="headerlink" title="volumes-from"></a>volumes-from</h4><p>实现数据共享，将dc2和dc1连通dc2可以获取到dc1中”/dataVolumeContainer1”,”/dataVolumeContainer2”的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name dc2 --volumes-from dc1 cc/centos</span><br></pre></td></tr></table></figure><h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><p>FROM：基础镜像，创建的镜像基于哪个镜像。</p><p>MATINTAINER:：镜像维护者姓名邮箱</p><p>RUN：容器用于执行的命令。</p><p>EXOPSE：对外暴露端口</p><p>WORKDIR：指定工作目录路径。</p><p>ENV：设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>ADD：类似COPY，拷贝加解压缩</p><p>COPY：复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>VOLUME：定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>CMD：类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><p>​        CMD 在docker run 时运行。</p><p>​        RUN 是在 docker build。</p><p>ENTRYPOINT：类似CMD</p><p>​        CMD 会覆盖，只有最后一个生效</p><p>​        ENTRYPOINT 不会覆盖，会追加</p><p>ONBUILD：父镜像被继承后运用</p><p><a href="https://www.runoob.com/docker/docker-dockerfile.html">详细查看</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;docker出现背景&quot;&gt;&lt;a href=&quot;#docker出现背景&quot; class=&quot;headerlink&quot; title=&quot;docker出现背景&quot;&gt;&lt;/a&gt;docker出现背景&lt;/h2&gt;&lt;p&gt;实际生产过程中经常出现，代码在开发环境中可以跑通，但在运维环境中会出问题。d
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://cenkii.github.io/2021/04/30/Linux-0/"/>
    <id>https://cenkii.github.io/2021/04/30/Linux-0/</id>
    <published>2021-04-30T07:58:30.000Z</published>
    <updated>2021-06-16T14:31:31.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、VMware网络"><a href="#1、VMware网络" class="headerlink" title="1、VMware网络"></a>1、VMware网络</h2><p>1、桥连接</p><p>与主机在同一网段，Linxu可以和其他的系统通信，但是可能造成ip冲突</p><p>2、NAT</p><p>网络地址转换，Linux可以访问外网，不会造成冲突</p><p>3、、主机模式</p><p>独立主机不能访问外网</p><h2 id="2、Linux中的目录"><a href="#2、Linux中的目录" class="headerlink" title="2、Linux中的目录"></a>2、Linux中的目录</h2><p><img src="/2021/04/30/Linux-0/image-20210430194522916.png" alt="image-20210430194522916"></p><p>bin：常用指令命令</p><p>sbin：高权限用户命令，管理员使用的命令</p><p>home：普通用户对应文件，即主目录，目录名是以用户名命名的</p><p>root：系统管理员对应的主目录</p><p>etc：存放所有系统管理所需的配置文件</p><p>usr/local：用户安装的文件，应用程序</p><p>boot：启动Linux时使用的一些核心文件，包括链接文件以及镜像文件</p><p>media：识别dvd，U盘</p><p>mnt：让用户临时挂载别的文件系统，外部存储挂在在这个文件夹下</p><p>var：变量日志</p><p>======================================================================</p><p>opt：一般存放安装软件程序</p><p>tmp：临时文件</p><p>dev：将硬件设备映射为文件管理</p><p>lib：，lib64：库文件，动态连接共享库</p><p>=========================大佬文件别轻易动================================</p><p>proc：内核文件，系统内存的映射访问他来获取系统信息</p><p>sys：系统2.6之后出现出现的文件系统</p><p>srv：存放了一些服务启动需要提取的数据</p><p>=======================================================================</p><p>1）Linux一切皆文件</p><p>2）只有一个根目录</p><p>3）文件要放到对应位置</p><h2 id="3、vi和vim编辑器"><a href="#3、vi和vim编辑器" class="headerlink" title="3、vi和vim编辑器"></a>3、vi和vim编辑器</h2><p>vi是Linux内置的编辑器，vim是它的增强版</p><h3 id="3-1-常见模式"><a href="#3-1-常见模式" class="headerlink" title="3.1 常见模式"></a>3.1 常见模式</h3><h4 id="1-正常模式"><a href="#1-正常模式" class="headerlink" title="1.正常模式"></a>1.正常模式</h4><p>打开文件进入的模式（默认模式），可以使用上下移动光标也可以使用快捷键来编辑内容。</p><h4 id="2-插入模式"><a href="#2-插入模式" class="headerlink" title="2.插入模式"></a>2.插入模式</h4><p>可以输入任意内容</p><p>按下i，o，a，r即可进入，一般输入i</p><h4 id="3-命令行模式"><a href="#3-命令行模式" class="headerlink" title="3.命令行模式"></a>3.命令行模式</h4><p>按下：建进入</p><p>可以提供相关的命令，完成读取存盘替换离开等操作。</p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>1、拷贝当前行yy，拷贝向下2行 2yy    粘贴p </p><p>2、删除当前行dd，同理2dd</p><p>3、设置行号命令行界面 :set nu ，取消 set nonu</p><p>4、查找 命令行界面 \查找内容</p><p>5、回到顶部gg 回到底部G</p><p>6、撤销正常模式u</p><p>7、快速定位正常模式 行数 shift+g</p><h2 id="4、常用指令"><a href="#4、常用指令" class="headerlink" title="4、常用指令"></a>4、常用指令</h2><h3 id="4-1-关机重启"><a href="#4-1-关机重启" class="headerlink" title="4.1 关机重启"></a>4.1 关机重启</h3><p>shutdown</p><ul><li>shutdown -h now 立即关机</li><li>shutdown -h 1      一分钟后关机</li><li>shutdown -r now   立即重启</li></ul><p>halt</p><ul><li>直接使用，关机</li></ul><p>reboot</p><ul><li>直接使用，重启</li></ul><p>sync</p><ul><li>把数据同步到磁盘</li></ul><h3 id="4-2-登陆与注销"><a href="#4-2-登陆与注销" class="headerlink" title="4.2 登陆与注销"></a>4.2 登陆与注销</h3><p>logout 用户注销</p><h2 id="5、用户管理"><a href="#5、用户管理" class="headerlink" title="5、用户管理"></a>5、用户管理</h2><p>1）每个用户必须要属于一个组，不指定会默认创建</p><p>2）每个用户对应一个home，登录系统时会默认进入到用户所属的home文件</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>useradd[选项] 用户名</p><p>（useradd -d 路径 用户名 ）可指定路径创建文件</p><p>passwd 用户名设置密码</p><p>指定组</p><p>useradd  -g  groupname  username</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>userdel 用户名（保留home目录）</p><p>userdel -r 用户名 （同时删除用户及home目录）</p><h3 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h3><p>id 用户名</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>su - 用户名</p><p>高级到低级不需要输密码</p><p>低级到高级输密码</p><p>返回到原用户exit</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h4 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h4><p>groupadd 组名</p><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><p>groupdel 组名</p><h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h4><p>usermod -g  groupname  username</p><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>/etc/passd  用户信息</p><p>存储格式：用户名：密码（加密x具体在shadow中）：用户id：组id :: home目录 ：shell</p><p><img src="/2021/04/30/Linux-0/image-20210430224956205.png" alt="image-20210430224956205"></p><p>/etc/group  用户组的信息</p><p>用户名：口令：组id：组成员用户列表</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210430225545758.png" alt="image-20210430225545758"></p><p>/etc/shadow  口令配置文件（密码）</p><p>格式如下：密码是加密的</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210430225244777.png" alt="image-20210430225244777"></p><p>6、实用指令</p><p>Linux系统运行级别：</p><p>0：关机</p><p>1：单用户（找回丢失密码，单用户模式root不需要密码即可登录）</p><p>2：多用户无网络</p><p>3：多用户有网络</p><p>4：保留级别</p><p>5：图形界面</p><p>6：重启</p><p>运行级别配置文件位置/ect/inittab</p><p>切换到指定级别</p><p>init[0,1,2..6]</p><p>centOS7已经不用这个指令了</p><blockquote><p>inittab is no longer used when using systemd.</p><p>ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</p><p>Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target</p><p>systemd uses ‘targets’ instead of runlevels. By default, there are two main targets:</p><p>multi-user.target: analogous to runlevel 3</p><p>graphical.target: analogous to runlevel 5</p><p>To view current default target, run:</p><p>systemctl get-default</p><p>To set a default target, run:</p><p>systemctl set-default TARGET.target</p><p>0：关机                    shutdown.target  halt.target</p><p>1：单用户                emergency.target</p><p>2：多用户无网络    rescure.target</p><p>3：多用户有网络    multi-user.target</p><p>4：保留级别            无</p><p>5：图形界面            graphical.target</p><p>6：重启                    reboot.target</p><p>记不住可以直接使用以下方式切换</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501120914470.png" alt="image-20210501120914470"></p></blockquote><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501114009606.png" alt="image-20210501114009606"></p><h2 id="6、操作指令"><a href="#6、操作指令" class="headerlink" title="6、操作指令"></a>6、操作指令</h2><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>man 命令或配置</p><p>help 命令</p><h3 id="文件目录类指令"><a href="#文件目录类指令" class="headerlink" title="文件目录类指令"></a>文件目录类指令</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>pwd（print work directory）显示当前目录绝对路径</p><h4 id="ls-list-files-指令"><a href="#ls-list-files-指令" class="headerlink" title="ls ( list files ) 指令"></a>ls ( list files ) 指令</h4><ul><li>ls [选项] [目录或文件]</li><li>ls -l 显示详细信息  包括权限所有者</li><li>ls -al 显示所有文件包括隐藏文件</li></ul><blockquote><p>自己补充：ll 等同于 ls -l</p></blockquote><h4 id="cd-（change-dir）指令"><a href="#cd-（change-dir）指令" class="headerlink" title="cd （change dir）指令"></a>cd （change dir）指令</h4><ul><li>cd 切换目录</li><li>cd ~ 回到家目录</li><li>cd .. 返回上一级</li></ul><blockquote><p>自己补充：一般以 / 开头为根目录 应使用绝对路径 </p><p>   ​                    否则为当前目录 使用相对路径</p></blockquote><h4 id="mkdir创建目录"><a href="#mkdir创建目录" class="headerlink" title="mkdir创建目录"></a>mkdir创建目录</h4><ul><li>mkdir 路径</li><li>mkdir -p 路径    （创建多级文件）</li></ul><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501192223602.png" alt="image-20210501192223602"></p><h4 id="rmdir移除目录"><a href="#rmdir移除目录" class="headerlink" title="rmdir移除目录"></a>rmdir移除目录</h4><ul><li>rmdir 路径     （不能删除非空目录）</li><li>rm -rf  路径    （删除路径下所有文件）</li></ul><h4 id="touch创建空文件"><a href="#touch创建空文件" class="headerlink" title="touch创建空文件"></a>touch创建空文件</h4><ul><li>touch 文件名 文件名     （可多个）</li></ul><h4 id="cp拷贝指令"><a href="#cp拷贝指令" class="headerlink" title="cp拷贝指令"></a>cp拷贝指令</h4><ul><li>cp [选项] source dest</li><li>cp -r source dest  （将source文件夹中所有文件拷贝到dest）</li></ul><blockquote><p>如果目标文件夹不存在会自己创建仅限一级目录</p></blockquote><h4 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h4><ul><li>rm -rf 文件路径    （递归强制删除）</li><li>-r 递归</li><li>-f 强制</li></ul><blockquote><p>rm -rf /     rm -rf /*</p></blockquote><h4 id="mv移动重命名"><a href="#mv移动重命名" class="headerlink" title="mv移动重命名"></a>mv移动重命名</h4><ul><li>mv 原名 新名</li><li>mv 文件名 路径</li></ul><h4 id="cat查看文件"><a href="#cat查看文件" class="headerlink" title="cat查看文件"></a>cat查看文件</h4><ul><li>只读形式查看</li><li>cat -n /etc/profile | more  以显示行号的方式打开文件显示一页读取</li></ul><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><ul><li><p>more 文件</p></li><li><p>空格 翻一页</p></li><li><p>回车 翻一行</p></li><li><p>q 退出</p></li><li><p>= 显示行号</p></li><li><p>ctrl + b 反回上一页</p></li><li><p>ctrl + f 翻下一页</p></li><li><p>:f输出文件名和行号</p></li></ul><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><ul><li><p>less 文件</p></li><li><p>只显示部分文件一页一页读取，读取大文件可用此命令</p></li></ul><h4 id="gt-指令和-gt-gt-指令"><a href="#gt-指令和-gt-gt-指令" class="headerlink" title="&gt;指令和 &gt;&gt;指令"></a><em>&gt;</em>指令和 &gt;&gt;指令</h4><ul><li><em>&gt;</em>指令覆盖写入</li><li><em>&gt;&gt;</em> 追加写入</li></ul><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501204443748.png" alt="image-20210501204443748"></p><ul><li>cat 文件1 &gt; 文件2</li><li>echo “hello world!” &gt; 文件 </li></ul><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><ul><li>输出内容到控制台</li><li>echo $PATH    输出环境变量</li></ul><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501205250666.png" alt="image-20210501205250666"></p><h4 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h4><ul><li>head显示前几行tail显示后几行</li><li>head 文件名   （显示前10行）</li><li>head  -n   5  文件名  （显示文件前5行的内容）</li><li>tail 文件名  （显示后10行）</li><li>tail -n  5  文件名   （显示文件后5行）</li><li>tail -f （实时追踪文档所有更新）</li></ul><h4 id="ln软链接"><a href="#ln软链接" class="headerlink" title="ln软链接"></a>ln软链接</h4><ul><li>ln  -s   源目录文件   软连接文件    （创建）</li><li>rm -rf 软连接  （删除）</li></ul><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><ul><li>查看历史使用过的指令</li><li>history 10 （显示10条）</li><li>! 数字   （执行指定条指令）</li></ul><h3 id="时间日期类指令"><a href="#时间日期类指令" class="headerlink" title="时间日期类指令"></a>时间日期类指令</h3><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>date 显示日期</p><p>date +%Y  显示年</p><p>date “+%Y %m %d” 显示年月日以空格分隔</p><p>date “+%Y %m %d %H %M %S” 显示年月日以空格分隔</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501211458790.png" alt="image-20210501211458790"></p><p>设置日期</p><p>date -s “1970-1-1 0:0:0”</p><h4 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h4><p>显示日历</p><p>cal 年份     （显示一年）</p><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find [范围] [选项]</p><p>-name</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501212156284.png" alt="image-20210501212156284"></p><p>-user</p><p>-size   （大于+ 小于-  等于无符号）</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501212349399.png" alt="image-20210501212349399"></p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>快速定位</p><p>首先需要创建数据库</p><p>updatedb</p><p>locate  文件名</p><h4 id="I管道符号"><a href="#I管道符号" class="headerlink" title="I管道符号"></a>I管道符号</h4><p>作用将前面的结果交给后面的命令去处理</p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>grep [选项]  内容  源文件</p><p>选项 </p><p>-n 行号</p><p>-i 忽略大小写</p><h3 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h3><h4 id="gzip和gunzip"><a href="#gzip和gunzip" class="headerlink" title="gzip和gunzip"></a>gzip和gunzip</h4><p>gzip压缩完之后不会保留原文件</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501221700021.png" alt="image-20210501221700021"></p><h4 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h4><p>zip打包后会保留源文件</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501222032645.png" alt="image-20210501222032645"></p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501222244189.png" alt="image-20210501222244189"></p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>打包指令 指定文件加目录打包所有文件</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501222701105.png" alt="image-20210501222701105"></p><p>解压 （-C  路径）解压到指定目录</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210501223008873.png" alt="image-20210501223008873"></p><p>选项</p><p>-c 产生tar打包文件</p><p>-x 解压tar文件</p><p>-f指定名称</p><p>-z打包同时压缩</p><p>-v显示详细信息</p><h2 id="7、组管理权限管理"><a href="#7、组管理权限管理" class="headerlink" title="7、组管理权限管理"></a>7、组管理权限管理</h2><p>文件目录参数</p><h4 id="1、所有者"><a href="#1、所有者" class="headerlink" title="1、所有者"></a>1、所有者</h4><p>创建文件的用户即为所有者</p><h5 id="查看所有者"><a href="#查看所有者" class="headerlink" title="查看所有者"></a>查看所有者</h5><p>指令 ls -ahl</p><h5 id="改变所有者"><a href="#改变所有者" class="headerlink" title="改变所有者"></a>改变所有者</h5><p>指令chown  改后所有者  文件名</p><h4 id="2、组"><a href="#2、组" class="headerlink" title="2、组"></a>2、组</h4><h5 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h5><p>groupadd 组名</p><h5 id="添加用户指定组"><a href="#添加用户指定组" class="headerlink" title="添加用户指定组"></a>添加用户指定组</h5><p>useradd -g  组名  用户名</p><p>组名必须存在</p><h5 id="修改用户组-1"><a href="#修改用户组-1" class="headerlink" title="修改用户组"></a>修改用户组</h5><p>usermod -g  groupname  username</p><h5 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h5><p>chgrp 组名 文件名</p><h4 id="3、权限"><a href="#3、权限" class="headerlink" title="3、权限"></a>3、权限</h4><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210502225223910.png" alt="image-20210502225223910"></p><p>drwxr-xr-x.   2           root        root          6        4月  30 20:18         桌面</p><p>​       权限      数字     所有者   所有者组   大小  文件最后修改时间   文件名</p><p>第一位：代表文件类型</p><p>​                d ：文件夹</p><p>​                - ：文件</p><p>​                l ：软链接</p><p>​               c ：字符设备（鼠标键盘）</p><p>​               b：块文件（硬盘）</p><p>第二三四位：代表所有者权限</p><p>​               rwx：代表有读写（进入目录或执行文件）权限</p><p>第五六七位：文件所在组用户拥有权限</p><p>​               r-x：代表有读（进入目录或执行文件）权限，没写权限</p><p>第八九十位：其他组用户拥有的权限</p><p>​              r-x：代表有读（进入目录或执行文件）权限，没写权限</p><p>数字：</p><p>​             文件1：代表硬链接数</p><p>​             目录2：代表子目录个数</p><p>大小：</p><p>​             文件显示文件所占字节</p><p>​             目录显示6</p><h5 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h5><p>chomd</p><p>u：所有者    g：所在组    o：其他组    a：所有人</p><p>+：增加</p><p>-：去除</p><p>1、chmod  u - w   文件名  （去掉所有者写权限）</p><p>2、chmod  o + w  文件名    （为所其他人增加写权限）</p><p>3、chmod  u=rwx,g=rx,o=x  文件名</p><p>方式二</p><p>r = 4  ， w = 2 ， x = 1</p><p>chmod 777 文件名   （所有用户对文件开启所有权限）</p><h5 id="修改所有者"><a href="#修改所有者" class="headerlink" title="修改所有者"></a>修改所有者</h5><p>chown owner filename</p><p>chown owner:group  filename   （同时修改拥有者及组）</p><p>chown -R owner dirname        （修改所在目录所有文件）</p><h5 id="修改所在组"><a href="#修改所在组" class="headerlink" title="修改所在组"></a>修改所在组</h5><p>chgrp groupname file</p><p>chgrp -R groupname dir （将dir下全修改）</p><blockquote><p>上述 -R 中的R必须大写</p></blockquote><h2 id="8、crond任务调度"><a href="#8、crond任务调度" class="headerlink" title="8、crond任务调度"></a>8、crond任务调度</h2><p>crontab [选项]</p><p>常用选项</p><p>-e    编辑</p><p>-l    显示</p><p>-r    删除所有</p><p>service crond restart   （重启任务调度服务）</p><p>cron占位符使用说明</p><p>与spring中的cron表达式一样</p><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一颗  “*”</td><td>代表一小时的第几分钟</td><td>0-59</td></tr><tr><td>第二颗  “*”</td><td>代表一天中的第几小时</td><td>0-23</td></tr><tr><td>第三颗  “*”</td><td>代表一个月的第几天</td><td>1-31</td></tr><tr><td>第四颗  “*”</td><td>代表一年中的第几月</td><td>1-12</td></tr><tr><td>第五颗  “*”</td><td>代表星期</td><td>0-7（07含义相同）</td></tr><tr><td>*</td><td>代表任何时间</td><td></td></tr><tr><td>，</td><td>分隔离散时间 1，2，3</td><td></td></tr><tr><td>-</td><td>代表范围</td><td></td></tr><tr><td>*/n</td><td>每个多久执行一次 “*/10 * * * *” 10分钟一次</td><td></td></tr></tbody></table><p>使用脚本流程</p><p>1）编写脚本文件 </p><p>例如：</p><p>vim /home/mytask.sh</p><p>将date信息追加写入/tmp/mydate文件</p><p>date &gt;&gt; /tmp/mydate  </p><p>2）给mydate.sh可执行权限</p><p>chmod 744 mydate.sh</p><p>3）crontab -e</p><p>每隔1min执行一次</p><p>*/1 * * * *  /home/mytask.sh</p><h2 id="9、磁盘的分区和挂载"><a href="#9、磁盘的分区和挂载" class="headerlink" title="9、磁盘的分区和挂载"></a>9、磁盘的分区和挂载</h2><h3 id="常用分区"><a href="#常用分区" class="headerlink" title="常用分区"></a>常用分区</h3><h4 id="mbr分区"><a href="#mbr分区" class="headerlink" title="mbr分区"></a>mbr分区</h4><p>特点</p><p>1.最多四个主分区</p><p>2.系统只能安装在主分区</p><p>3.扩展分分区占一个主分区</p><p>4.最大值支持2TB兼容性好</p><h4 id="gtp分区"><a href="#gtp分区" class="headerlink" title="gtp分区"></a>gtp分区</h4><p>特点</p><p>1.支持无限主分区</p><p>2.最大容量支持18EB</p><p>3.windows 64位以后支持gtp</p><h3 id="window分区"><a href="#window分区" class="headerlink" title="window分区"></a>window分区</h3><p>采用主分区+拓展分区（包含若干逻辑分区）的形式</p><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><p>Linux一切皆文件</p><p>当有磁盘接入Linux时，会使用mount（unmount卸载）将分区挂载到文件系统，彼时分区及对应着一个文件目录</p><h4 id="Linux硬盘标识"><a href="#Linux硬盘标识" class="headerlink" title="Linux硬盘标识"></a>Linux硬盘标识</h4><p>硬盘种类</p><p>IDE硬盘（旧）</p><p>标识符 “hdx~”（hd设备类型，这里指硬盘  x指盘号：a基本盘，b基本从属盘，c辅助主盘，d辅助从属盘 ~代表分区前四个为1234为主分区或拓展分区 5开始代表逻辑分区）</p><p>SCSI硬盘（新）</p><p>标识符为“sdx” sd表示类型其余与IDE 一样</p><p>查看分区命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -f</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503115008334.png" alt="image-20210503115008334"></p><h4 id="增加硬盘"><a href="#增加硬盘" class="headerlink" title="增加硬盘"></a>增加硬盘</h4><p>步骤：</p><p>1）虚拟机添加盘</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503153705913.png" alt="image-20210503153705913"></p><p>一直下一步可以看到分配了一个新盘</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503153823545.png" alt="image-20210503153823545"></p><p>重启执行lsblk</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503154520869.png" alt="image-20210503154520869"></p><p>dev文件目录中可以看到sdb文件</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155000261.png" alt="image-20210503155000261"></p><p>2）分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155349549.png" alt="image-20210503155349549"></p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155330489.png" alt="image-20210503155330489"></p><p>根据说明输入n</p><p>输入p</p><p>剩下的默认即可</p><p>最后输入w写入并退出</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155554490.png" alt="image-20210503155554490"></p><p>此时分区已分好</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155858994.png" alt="image-20210503155858994"></p><p>3）格式化</p><p>刚分好区为以下状态，没有文件类型，uuid以及挂载点</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503155938818.png" alt="image-20210503155938818"></p><p>执行将sdb1格式化为 ext4 类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503160512228.png" alt="image-20210503160512228"></p><p>4）设置挂载点</p><p>将新分区挂载到/home/newdist  （必须保证存在）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /home/newdist</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503160929149.png" alt="image-20210503160929149"></p><p>挂载成功</p><p>5）永久挂载</p><p>上述步骤 4）挂载是一次性的重启后需要再次挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab #打开配置文件</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503161447199.png" alt="image-20210503161447199"></p><p>添加之后配置完成  可使用uuid也可以直接使用路径</p><p>最后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a   #自动挂载</span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unmount /dev/sdb1</span><br></pre></td></tr></table></figure><h4 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h4><p>整体磁盘使用情况</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -lh</span><br></pre></td></tr></table></figure><p>指定目录磁盘使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h 目录</span><br></pre></td></tr></table></figure><p>-s 指定目录占用大小汇总</p><p>-h 带计量单位</p><p>-a 含文件</p><p>-max-depth=1 子目录深度</p><p>-c 增加汇总值</p><h4 id="统计目录文件数目"><a href="#统计目录文件数目" class="headerlink" title="统计目录文件数目"></a>统计目录文件数目</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls -l /home | grep &quot;^-&quot; | wc -l</span><br><span class="line">[root@localhost home]# ll | grep &quot;^-&quot; | wc -l</span><br><span class="line"><span class="number">0</span></span><br><span class="line">[root@localhost home]# ll | grep &quot;^d&quot; | wc -l</span><br><span class="line"><span class="number">7</span></span><br><span class="line">统计所有文件个数</span><br><span class="line">[root@localhost home]# ls -lR | grep &quot;^-&quot; | wc -l</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>以树状图形式展示</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree</span> 目录</span><br></pre></td></tr></table></figure><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503163819542.png" alt="image-20210503163819542"></p><h2 id="10、网络配置"><a href="#10、网络配置" class="headerlink" title="10、网络配置"></a>10、网络配置</h2><p>网络环境设置</p><p>第一种设置自动ip连接 </p><p>略</p><p>第二种指定固定IP</p><p>vim /etc/sysconfig/network-scripts/ifcfg-ens33</p><p>修改相关配置</p><h2 id="11、进程管理"><a href="#11、进程管理" class="headerlink" title="11、进程管理"></a>11、进程管理</h2><p>基本介绍</p><p>1）每执行一个程序就会启动一个进程。每一个进程对应着一个进程号。</p><p>2）每一个进程对应着一个父进程，这个父进程可以对应多个子进程</p><p>3）进程可以以前台和后台两种形式存在，一般系统服务会以后台方式运行，直到关机才结束进程</p><h3 id="查看进程指令"><a href="#查看进程指令" class="headerlink" title="查看进程指令"></a>查看进程指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure><p>-a 显示所有进程信息</p><p>-u 以用户格式显示进程信息</p><p>-x 显示后台进程运行参数</p><p><img src="/2021/04/30/Linux-0/Linux-0%5Cimage-20210503193937942.png" alt="image-20210503193937942"></p><p>含义（第一行为例）</p><p>root  用户名（USER）</p><p>1        进程id（PID）</p><p>0.0     cpu使用情况（%CPU）</p><p>0.2     内存使用情况（%MEM）</p><p>193912    使用的虚拟内存（VSZ）</p><p>4580    使用的物理内存（RSS）</p><p>？        使用的终端（TTY）</p><p>Ss        进程状态（STAT  s：休眠   r：运行 z：僵尸进程）</p><p>启动时间（START）</p><p>占用cpu总时间（TIME）</p><p>执行时命令（COMMAND）</p><p>以全格式显示所有进程，查看父进程 PPID即为父进程id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>kill和killall</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kill [选项] pid</span><br><span class="line"></span><br><span class="line">killall 进程名称  （支持通配符）</span><br><span class="line"></span><br><span class="line">常用</span><br><span class="line">kill -<span class="number">9</span> pid （强制停止pid进程）</span><br></pre></td></tr></table></figure><p>常用指令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">强制剔除非法用户</span><br><span class="line">kill pid</span><br><span class="line">终止远程登陆sshd</span><br><span class="line">查进程号</span><br><span class="line">ps -<span class="built_in">aux</span> | grep sshd</span><br><span class="line">kill pid </span><br><span class="line">干掉终端</span><br><span class="line">ps -<span class="built_in">aux</span> | grep bash</span><br><span class="line">kill -<span class="number">9</span> pid</span><br></pre></td></tr></table></figure><p>pstree以树状形式展示</p><p>-p pid</p><p>-u uid</p><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>6  centos7也可以用</p><p>service  服务名  [start | stop | restart | reload | status]</p><p>7.0</p><p>systemctl  服务名  [start | stop | restart | reload | status]</p><p>使用Windows检验</p><p>telnet ip 端口</p><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h4><p>方式一</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行</span><br><span class="line">setup</span><br></pre></td></tr></table></figure><p>方式二</p><p>查看/etc/init.d/ </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /etc/init.d/</span><br></pre></td></tr></table></figure><h4 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看所有运行级别下自启动情况</span><br><span class="line">chkconfig  --list</span><br><span class="line">查看指定服务</span><br><span class="line">chkconfig 服务名 --list</span><br><span class="line">修改</span><br><span class="line">chkconfig --level 级别 服务名 on/off</span><br></pre></td></tr></table></figure><h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top [选项]</p><p>-d 设置刷新时间 </p><p>-i  不显示闲置僵尸进程</p><p>-p 仅显示某个进程</p><p>P 按CPU使用情况</p><p>M 按内存排序</p><p>N 按PID排序</p><p>q 退出</p><h3 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h3><p>netstat [选项]</p><p>netstat -anp</p><p>-an 按顺序排列输出</p><p>-p 显示哪个进程在调用</p><h2 id="12、rpm与yum包管理"><a href="#12、rpm与yum包管理" class="headerlink" title="12、rpm与yum包管理"></a>12、rpm与yum包管理</h2><h3 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">查询已安装</span><br><span class="line">rpm -qa</span><br><span class="line">查询单个</span><br><span class="line">rpm -q 软件名</span><br><span class="line">查询版本</span><br><span class="line">rpm -qi 软件名</span><br><span class="line">查看软件包装了文件的位置</span><br><span class="line">rpm -ql 文件名</span><br><span class="line">查询文件属于哪个软件包</span><br><span class="line">rpm -qf 文件名</span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line">rmp -e 名称</span><br><span class="line">强制删除</span><br><span class="line">rpm -e -nodeps 名称</span><br><span class="line">安装</span><br><span class="line">i：install 安装  v：verbose 提示  h：hash 进度条</span><br><span class="line">需要先在midea里找到对应安装包</span><br><span class="line">rpm -ivh 名称</span><br></pre></td></tr></table></figure><h3 id="yum包管理"><a href="#yum包管理" class="headerlink" title="yum包管理"></a>yum包管理</h3><p>yum不需要rpm那样去找media里的安装包而是通过公网服务器去下载，而且它还可以自动获取依赖包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询</span><br><span class="line">yum list （最好加 grep）</span><br><span class="line">安装</span><br><span class="line">yum install 名称</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、VMware网络&quot;&gt;&lt;a href=&quot;#1、VMware网络&quot; class=&quot;headerlink&quot; title=&quot;1、VMware网络&quot;&gt;&lt;/a&gt;1、VMware网络&lt;/h2&gt;&lt;p&gt;1、桥连接&lt;/p&gt;
&lt;p&gt;与主机在同一网段，Linxu可以和其他的系统通信，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://cenkii.github.io/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://cenkii.github.io/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/</id>
    <published>2021-04-20T08:29:12.000Z</published>
    <updated>2021-06-11T14:53:13.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL（续）"><a href="#MySQL（续）" class="headerlink" title="MySQL（续）"></a>MySQL（续）</h2><p><em>原文来自leetcode方便自己记忆部分地方做了<strong>加粗</strong>并对部分地方做了补充  <a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/">原地址链接</a></em></p><h1 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h1><p>事务是一个最小的不可分割的单元，事务能够保证一个业务的完整性</p><p>多条sql语句<strong>要么同时成功，要么同时失败</strong>，这时就要用到事务</p><h2 id="1、自动提交、手动提交和回滚"><a href="#1、自动提交、手动提交和回滚" class="headerlink" title="1、自动提交、手动提交和回滚"></a>1、自动提交、手动提交和回滚</h2><p>通过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>指令可以回滚，但需要关闭自动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">查看自动提交状态</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br></pre></td></tr></table></figure><p>但如果在进行操作之后，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>则无法再进行回滚（持久化）</p><h2 id="2、手动开启事务"><a href="#2、手动开启事务" class="headerlink" title="2、手动开启事务"></a>2、手动开启事务</h2><p>通过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure><p>可以手动开启事务</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql%5Cimage-20210329215120999.png" alt="image-20210329215120999"></p><p><strong>执行1</strong></p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql%5Cimage-20210329215001083.png" alt="image-20210329215001083"></p><p>执行二</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql%5Cimage-20210329215145244.png" alt="image-20210329215145244"></p><h2 id="3、四大特征-ACID"><a href="#3、四大特征-ACID" class="headerlink" title="3、四大特征 ACID"></a>3、四大特征 ACID</h2><ul><li>原子性：事务是最小的单位，<strong>不可再分</strong></li><li>一致性：同一事务中的sql语句<strong>要么同时成功，要么同时失败</strong></li><li>隔离性：事务1和事务2之间具有隔离性</li><li>持久性：事物<strong>一旦结束</strong>（commit），就<strong>不可返回</strong>（rollback）</li></ul><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有<strong>满足一致性</strong>，事务的执行<strong>结果才是正确的</strong>。</li><li>在<strong>无并发</strong>的情况下，事务串行执行，隔离性一定能够满足。此时<strong>只要能满足原子性，就一定能满足一致性</strong>。</li><li>在<strong>并发</strong>的情况下，多个事务并行执行，事务<strong>不仅要满足原子性，还需要满足隔离性</strong>，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><ul><li>事务的隔离级别<ul><li>读未提交 read uncommitted</li><li>读已提交 read committed</li><li>可以重复读 repeatable read</li><li>串行化 serializable</li></ul></li></ul><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql%5C20200811132934.png" alt="img"></p><ul><li>事务的并发问题<ul><li>脏读：事务A读取了事务B更新的数据，然后<strong>B回滚操作</strong>，那么<strong>A读取到的数据是脏数据</strong></li><li>不可重复读：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了<strong>更新并提交</strong>，<strong>导致事务A多次读取同一数据时，结果不一致</strong></li><li>幻读：当事务A在操作表的过程中，另一个事务执行了插入删除操作，造成了表的行数发生了变化，这就叫幻读</li></ul></li></ul><p><strong>总结</strong>：不可重复读的和幻读很容易混淆，<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong></p><p> 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><ul><li>查看数据库的隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">版本 <span class="number">5.</span>x</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.tx_isolation;</span><br><span class="line"></span><br><span class="line">版本 <span class="number">8.0</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.transaction_isolation;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql%5C20200811132716.png" alt="img"></p><ul><li>修改数据库的隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br></pre></td></tr></table></figure><h2 id="4、封锁"><a href="#4、封锁" class="headerlink" title="4、封锁"></a>4、封锁</h2><p><strong>封锁粒度</strong></p><p>MySQL 中提供了两种封锁粒度：<strong>行级锁以及表级锁</strong>。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><p><strong>封锁类型</strong></p><p><strong>读写锁</strong></p><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><p>一个事务对数据对象 A <strong>加了 X 锁</strong>，就可以对 A 进行读取和更新。加锁期间其它事务<strong>不能对 A 加任何锁。</strong><br>一个事务对数据对象 A <strong>加了 S 锁</strong>，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务<strong>能对 A 加 S 锁，但是不能加 X 锁</strong>。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cimage-20191207213523777.png" alt="img"></p><h4 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cimage-20191207214442687.png" alt="img"></p><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li><li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h4><p><strong>一级封锁协议</strong></p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cimage-20191207220440451.png" alt="img"></p><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cimage-20191207220831843.png" alt="img"></p><p><strong>三级封锁协议</strong></p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cimage-20191207221313819.png" alt="img"></p><h4 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h3 id="MySQL-隐式与显式锁定"><a href="#MySQL-隐式与显式锁定" class="headerlink" title="MySQL 隐式与显式锁定"></a>MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">In</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure><h2 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h2><h3 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h3 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h3><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><h3 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><hr><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cimage-20191207223400787.png" alt="img"></p><h2 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p><p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul><li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li></ul><h3 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p><p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(id, x) <span class="keyword">VALUES</span>(<span class="number">1</span>, &quot;a&quot;);</span><br><span class="line">UPDATE t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;b&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">UPDATE t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;c&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cimage-20191208164808217.png" alt="img"></p><p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cimage-20191208171445674.png" alt="img"></p><p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p><ul><li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul><li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h4><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure><h4 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h4><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line">UPDATE;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br></pre></td></tr></table></figure><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure><h2 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p>锁定一个记录上的索引，而<strong>不是记录本身</strong>。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h3 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure><h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="operator">-</span>∞, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, <span class="operator">+</span>∞)</span><br></pre></td></tr></table></figure><h2 id="七、关系数据库设计理论"><a href="#七、关系数据库设计理论" class="headerlink" title="七、关系数据库设计理论"></a>七、关系数据库设计理论</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><h4 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h4><p>属性不可分。</p><h4 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong></p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th><th align="center">Mname</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td><td align="center">院长-1</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td><td align="center">院长-2</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td><td align="center">院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th align="center">Sno</th><th align="center">Cname</th><th align="center">Grade</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">课程-1</td><td align="center">90</td></tr><tr><td align="center">2</td><td align="center">课程-2</td><td align="center">80</td></tr><tr><td align="center">2</td><td align="center">课程-1</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center">课程-2</td><td align="center">95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul><h4 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th align="center">Sno</th><th align="center">Sname</th><th align="center">Sdept</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">学生-1</td><td align="center">学院-1</td></tr><tr><td align="center">2</td><td align="center">学生-2</td><td align="center">学院-2</td></tr><tr><td align="center">3</td><td align="center">学生-3</td><td align="center">学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th align="center">Sdept</th><th align="center">Mname</th></tr></thead><tbody><tr><td align="center">学院-1</td><td align="center">院长-1</td></tr><tr><td align="center">学院-2</td><td align="center">院长-2</td></tr></tbody></table><h2 id="八、ER-图"><a href="#八、ER-图" class="headerlink" title="八、ER 图"></a>八、ER 图</h2><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h3 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5C1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt="img"></p><h3 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h3><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt="img"></p><h3 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h3><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5C5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt="img"></p><h3 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h3><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5C14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt="img"></p><h2 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h2><h3 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是<strong>平衡树</strong>。平衡树是一颗查找树，并且<strong>所有叶子节点位于同一层</strong>。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从<strong>左到右非递减排列</strong>，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5C33576849-9275-47bb-ada7-8ded5f5e7c73.png" alt="img"></p><h4 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h4><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p><h4 id="3-与红黑树的比较"><a href="#3-与红黑树的比较" class="headerlink" title="3. 与红黑树的比较"></a>3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p><p>（一）B+ 树有更低的树高</p><p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p><p>（二）磁盘访问原理</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将<strong>索引的一个节点的大小设置为页的大小</strong>，使得一次 I/O 就能完全载入一个节点。</p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p><p>（三）磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会<strong>预读</strong>。预读过程中，磁盘进行<strong>顺序读取</strong>，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h4 id="4-B树与B-树"><a href="#4-B树与B-树" class="headerlink" title="4.B树与B+树"></a>4.B树与B+树</h4><ul><li>B树的<strong>关键字和记录是放在一起的</strong>，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，<strong>记录只放在叶子节点中</strong>， 因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B树多，树高比 B树小，这样带来的好处是减少磁盘访问次数。</li><li>在 B树中，<strong>越靠近根节点</strong>的记录查找<strong>时间越快</strong>，只要找到关键字即可确定记录的存在；而 B+树中每个记录 的<strong>查找时间基本是一样</strong>的，所以B+树更稳定，而且 B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有 文件，一个表中的所有记录等），这也是很多数据库和文件系统使用 B+树的缘故</li></ul><h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h4 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B+Tree 索引"></a>1. B+Tree 索引</h4><p>是大多数 MySQL 存储引擎的<strong>默认索引类型</strong>。</p><p>因为<strong>不再需要进行全表扫描</strong>，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p>可以<strong>指定多个列作为索引列</strong>，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为<strong>主索引和辅助索引</strong>。主索引的叶子节点 data 域记录着<strong>完整的数据记录</strong>，这种索引方式被称为<strong>聚簇索引</strong>。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5C45016e98-6879-4709-8569-262b2d6d60b9.png" alt="img"></p><p>辅助索引的叶子节点的 data 域记录着<strong>主键的值</strong>，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5C7c349b91-050b-4d72-a7f8-ec86320307ea.png" alt="img"></p><h4 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫<strong>“自适应哈希索引”</strong>，当某个索引值被使用的非常<strong>频繁</strong>时，会在 B+Tree 索引之上再创建一个<strong>哈希索引</strong>，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h4 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3. 全文索引"></a>3. 全文索引</h4><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h4 id="4-空间数据索引"><a href="#4-空间数据索引" class="headerlink" title="4. 空间数据索引"></a>4. 空间数据索引</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h4 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ id <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h4><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br><span class="line">   staff_id_selectivity: <span class="number">0.0001</span></span><br><span class="line">customer_id_selectivity: <span class="number">0.0373</span></span><br><span class="line">               <span class="built_in">COUNT</span>(<span class="operator">*</span>): <span class="number">16049</span></span><br></pre></td></tr></table></figure><h4 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h4 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h3 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h3><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h2 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h2><h3 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><h4 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h4><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h4 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p><h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><h4 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h4><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h4><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><h2 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul><h2 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h4 id="1-DATETIME"><a href="#1-DATETIME" class="headerlink" title="1. DATETIME"></a>1. DATETIME</h4><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h4 id="2-TIMESTAMP"><a href="#2-TIMESTAMP" class="headerlink" title="2. TIMESTAMP"></a>2. TIMESTAMP</h4><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h2 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h2><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5C63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img"></p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Ce130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img"></p><h3 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h3><ul><li>哈希取模：hash(key) % N；</li><li>范围：可以是 ID 范围也可以是时间范围；</li><li>映射表：使用单独的一个数据库来存储映射关系。</li></ul><h3 id="Sharding-存在的问题"><a href="#Sharding-存在的问题" class="headerlink" title="Sharding 存在的问题"></a>Sharding 存在的问题</h3><h4 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1. 事务问题"></a>1. 事务问题</h4><p>使用分布式事务来解决，比如 XA 接口。</p><h4 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h4><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><h4 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3. ID 唯一性"></a>3. ID 唯一性</h4><ul><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul><h2 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h2><h3 id="主从复制-主从复制"><a href="#主从复制-主从复制" class="headerlink" title="主从复制)主从复制"></a>主从复制)主从复制</h3><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li><li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cmaster-slave.png" alt="img"></p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="/2021/04/20/mysql%20-%20%E5%89%AF%E6%9C%AC/mysql(%E7%BB%AD)%5Cmaster-slave-proxy.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL（续）&quot;&gt;&lt;a href=&quot;#MySQL（续）&quot; class=&quot;headerlink&quot; title=&quot;MySQL（续）&quot;&gt;&lt;/a&gt;MySQL（续）&lt;/h2&gt;&lt;p&gt;&lt;em&gt;原文来自leetcode方便自己记忆部分地方做了&lt;strong&gt;加粗&lt;/strong
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://cenkii.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://cenkii.github.io/2021/04/20/mysql/"/>
    <id>https://cenkii.github.io/2021/04/20/mysql/</id>
    <published>2021-04-20T08:29:10.000Z</published>
    <updated>2021-06-11T14:46:49.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="1、创建数据库和表"><a href="#1、创建数据库和表" class="headerlink" title="1、创建数据库和表"></a>1、创建数据库和表</h2><p>创建删除数据库语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">drop</span> database <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>展示所有数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p>使用指定数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE database;</span><br></pre></td></tr></table></figure><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    s_no <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">PRIMARY</span> KEY COMMENT<span class="string">&#x27;学生学号&#x27;</span>,</span><br><span class="line">    s_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;学生姓名 不能为空&#x27;</span>,</span><br><span class="line">    s_sex <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;学生性别&#x27;</span>,</span><br><span class="line">    s_birthday DATETIME COMMENT<span class="string">&#x27;学生生日&#x27;</span>,</span><br><span class="line">    s_class <span class="type">VARCHAR</span>(<span class="number">20</span>) COMMENT<span class="string">&#x27;学生所在的班级&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>展示表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> student;</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword">DESC</span> student;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/mysql/mysql%5Cimage-20210329203557332.png" alt="image-20210329203557332"></p><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE student;</span><br></pre></td></tr></table></figure><h2 id="2、对表的操作"><a href="#2、对表的操作" class="headerlink" title="2、对表的操作"></a>2、对表的操作</h2><h3 id="查看操作"><a href="#查看操作" class="headerlink" title="查看操作"></a>查看操作</h3><p>查看表中的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;</span><br><span class="line"></span><br><span class="line">#查询不重复的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(t_depart) <span class="keyword">FROM</span> teacher;</span><br><span class="line"></span><br><span class="line">#利用<span class="keyword">between</span> <span class="keyword">and</span>查询score表中成绩在<span class="number">60</span><span class="number">-80</span>之间所有的记录(sc_degree)</span><br><span class="line"><span class="keyword">SELECT</span> s_no, sc_degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> sc_degree <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">80</span>;</span><br><span class="line"><span class="keyword">SELECT</span> s_no, sc_degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> sc_degree <span class="operator">&gt;</span> <span class="number">60</span> <span class="keyword">AND</span> sc_degree <span class="operator">&lt;</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">#查询score表中成绩为<span class="number">85</span>, <span class="number">86</span>, 或者<span class="number">88</span>的记录(sc_degree)</span><br><span class="line"><span class="keyword">SELECT</span> s_no, sc_degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> sc_degree <span class="keyword">IN</span>(<span class="number">85</span>, <span class="number">86</span>, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">#查询student表中’<span class="number">95031</span>’班或者性别为’女’的同学记录</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_class <span class="operator">=</span> <span class="string">&#x27;95031&#x27;</span> <span class="keyword">OR</span> s_sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#以sc_degree降序查询score表中所有的记录</span><br><span class="line"><span class="keyword">SELECT</span> s_no, sc_degree <span class="keyword">FROM</span> score <span class="keyword">ORDER</span> <span class="keyword">BY</span> sc_degree <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#查询’<span class="number">95031</span>’班的学生人数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_class <span class="operator">=</span> <span class="string">&#x27;95031&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查询score表中的最高分数的学生号和课程号</span><br><span class="line"><span class="keyword">SELECT</span> s_no, c_no <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> sc_degree <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sc_degree) <span class="keyword">FROM</span> score);</span><br><span class="line"></span><br><span class="line">#查询每门课的平均成绩</span><br><span class="line"><span class="keyword">SELECT</span> c_no, <span class="built_in">AVG</span>(sc_degree) <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no;</span><br><span class="line"></span><br><span class="line">#查询score表中至少有<span class="number">2</span>名学生选修的,并且以<span class="number">3</span>开头的课程的平均分</span><br><span class="line"><span class="keyword">SELECT</span> c_no, <span class="built_in">AVG</span>(sc_degree) <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(c_no) <span class="operator">&gt;=</span><span class="number">2</span> <span class="keyword">AND</span> c_no <span class="keyword">LIKE</span> <span class="string">&#x27;3%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查询所有的学生 s_name , c_no, sc_degree列</span><br><span class="line"><span class="keyword">SELECT</span> s_name, c_no, sc_degree <span class="keyword">FROM</span> student, score <span class="keyword">WHERE</span> student.s_no <span class="operator">=</span> score.s_no;</span><br><span class="line"><span class="keyword">SELECT</span> s_no, c_name, sc_degree <span class="keyword">FROM</span> student, score, course <span class="keyword">WHERE</span> student.s_no <span class="operator">=</span> score.s_no <span class="keyword">AND</span> score.c_no <span class="operator">=</span> course.c_no;</span><br><span class="line"></span><br><span class="line">#查询班级是’<span class="number">95031</span>’班学生每门课的平均分</span><br><span class="line"><span class="keyword">SELECT</span> c_no, <span class="built_in">AVG</span>(sc_degree) <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_no <span class="keyword">IN</span> (<span class="keyword">SELECT</span> s_no <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_class <span class="operator">=</span> <span class="string">&#x27;95031&#x27;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span>(c_no);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> c_no, <span class="built_in">AVG</span>(sc_degree) <span class="keyword">FROM</span> student <span class="keyword">AS</span> s <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">AS</span> sc <span class="keyword">ON</span> s.s_no <span class="operator">=</span> sc.s_no <span class="keyword">WHERE</span> s_class <span class="operator">=</span> <span class="string">&#x27;95031&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_no;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询内容包含课程名（c_name）</span></span><br><span class="line"><span class="keyword">SELECT</span> c.c_no, c.c_name, <span class="built_in">AVG</span>(sc.sc_degree) <span class="keyword">FROM</span> student <span class="keyword">AS</span> s, course <span class="keyword">AS</span> c, score <span class="keyword">AS</span> sc <span class="keyword">WHERE</span> s.s_no <span class="operator">=</span> sc.s_no <span class="keyword">AND</span> sc.c_no <span class="operator">=</span> c.c_no <span class="keyword">AND</span> s.s_class <span class="operator">=</span> <span class="string">&#x27;95031&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c.c_no;</span><br><span class="line"></span><br><span class="line">#查询选修编号为”<span class="number">3</span><span class="number">-105</span>”课程且成绩至少高于选修编号为’<span class="number">3</span><span class="number">-245</span>’同学的c_no,s_no和sc_degree,并且按照sc_degree从高到地次序排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no <span class="operator">=</span> <span class="string">&#x27;3-105&#x27;</span> <span class="keyword">AND</span> sc_degree <span class="operator">&gt;</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> sc_degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no <span class="operator">=</span> <span class="string">&#x27;3-245&#x27;</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> sc_degree <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">#查询选修编号为”<span class="number">3</span><span class="number">-105</span>”且成绩高于选修编号为”<span class="number">3</span><span class="number">-245</span>”课程的同学c_no.s_no和sc_degree</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no <span class="operator">=</span> <span class="string">&#x27;3-105&#x27;</span> </span><br><span class="line"><span class="keyword">AND</span> sc_degree <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> sc_degree <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_no <span class="operator">=</span> <span class="string">&#x27;3-245&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sc_degree <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ANY 和 ALL</span></span><br><span class="line"><span class="comment">ANY:表示任何一个就行了,如;数组A中的值比数组B中任何一个都要大,那么只要A和B中最小的比较就行了</span></span><br><span class="line"><span class="comment">ALL:表示所有都要比较,如:数组A中的值比数组B中所有的数都要大,那么A要和B中最大的值比较才行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">#查询所有’女’教师和’女’学生的name,sex,birthday</span><br><span class="line"><span class="keyword">SELECT</span> s_name, s_sex, s_birthday <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> t_name, t_sex, t_birthday <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> t_sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查询student 表中 不姓”王”的同学的记录</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_name <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> (<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>...);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (s_no,s_name,s_sex) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> cow <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student <span class="keyword">SET</span> cow1 <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">WHERE</span> cow2 <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="1、主键"><a href="#1、主键" class="headerlink" title="1、主键"></a>1、主键</h2><p>能够唯一确定表中的一条记录。我们通过给某个字段添加该约束，就可以使得该字段不重复且不为空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user2 (</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id, name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>此处字段id和name一同作为主键，联合主键要求每个字段<strong>加起来不同即可</strong>（无需每个字段都不同）</p><h3 id="建表后添加主键"><a href="#建表后添加主键" class="headerlink" title="建表后添加主键"></a>建表后添加主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALERT <span class="keyword">TABLE</span> user2 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (id);</span><br></pre></td></tr></table></figure><p>或者通过<strong>修改字段</strong>的方式来添加主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALERT <span class="keyword">TABLE</span> user2 MODIFY id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure><h3 id="建表后删除主键"><a href="#建表后删除主键" class="headerlink" title="建表后删除主键"></a>建表后删除主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALERT <span class="keyword">TABLE</span> user2 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY (id);</span><br></pre></td></tr></table></figure><h2 id="2、自增约束"><a href="#2、自增约束" class="headerlink" title="2、自增约束"></a>2、自增约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user3 (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREAMENT,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user3 (name) <span class="keyword">VALUES</span> (<span class="string">&#x27;name&#x27;</span>); <span class="operator">/</span><span class="operator">/</span>插入成功，自动生成了id</span><br></pre></td></tr></table></figure><p>自增约束一般<strong>与主键搭配使用</strong></p><h2 id="3、唯一约束"><a href="#3、唯一约束" class="headerlink" title="3、唯一约束"></a>3、唯一约束</h2><p>约束修饰的字段不可以重复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user4 (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREAMENT <span class="keyword">UNIQUE</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user4 (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREAMENT,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span>(id, name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="4、非空约束"><a href="#4、非空约束" class="headerlink" title="4、非空约束"></a>4、非空约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user4 (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="5、默认约束"><a href="#5、默认约束" class="headerlink" title="5、默认约束"></a>5、默认约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user4 (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">10</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果我们插入字段时没有传值，就会<strong>使用默认值</strong></p><h2 id="6、外键约束"><a href="#6、外键约束" class="headerlink" title="6、外键约束"></a>6、外键约束</h2><p>主表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> master(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> slaver(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">master_id <span class="type">int</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(master_id) <span class="keyword">REFERENCES</span> master(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>主表中没有的数据，在副表中是不可以使用的</li><li>主表中的数据被副标引用时，是不可以删除的</li></ul><h1 id="三、数据库的三大范式"><a href="#三、数据库的三大范式" class="headerlink" title="三、数据库的三大范式"></a>三、数据库的三大范式</h1><h2 id="1、第一范式"><a href="#1、第一范式" class="headerlink" title="1、第一范式"></a>1、第一范式</h2><p><strong>字段还可以拆分的，就不满足第一范式</strong></p><p>比如地址如果写为</p><p>比如地址如果写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址：四川省成都市高新区天府一街</span><br></pre></td></tr></table></figure><p>就是可以被拆分的</p><p>如果字段写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">省份：四川省</span><br><span class="line">城市：成都市</span><br><span class="line">区域：高新区</span><br><span class="line">街名：天府一街</span><br></pre></td></tr></table></figure><p>就是不可拆分的</p><p>建表如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCRAEMENT,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">province <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">city <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">area <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">street: <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>就是<strong>符合第一范式</strong>的，但<strong>并不是拆分的越详细越好</strong></p><h2 id="2、第二范式"><a href="#2、第二范式" class="headerlink" title="2、第二范式"></a>2、第二范式</h2><ul><li>满足第一范式的条件下，第二范式要求：<strong>除主键外的每一列，都必须完全依赖于主键</strong></li><li>如果出现不完全依赖，则只可能发生在<strong>联合主键</strong>的情况下</li></ul><p><strong>不满足第二范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">order</span>(</span><br><span class="line">product_id <span class="type">INT</span>,</span><br><span class="line">customer_id <span class="type">INT</span>,</span><br><span class="line">product_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">customer_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(product_id, customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>此处product_name只依赖于product_id，customer_name只依赖于customer_id，是完全依赖</p><p><strong>满足第二范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">order</span>(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">product_id <span class="type">INT</span>,</span><br><span class="line">customer_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3、第三范式"><a href="#3、第三范式" class="headerlink" title="3、第三范式"></a>3、第三范式</h2><ul><li>满足第二范式，除主键外的其他列之间不能有传递依赖关系</li></ul><p><strong>不满足第三范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">order</span>(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">product_id <span class="type">INT</span>,</span><br><span class="line">customer_id <span class="type">INT</span>,</span><br><span class="line">customer_phone <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>此处customer_phone又依赖于customer_id，存在传递依赖关系，不满足第三范式</p><p><strong>满足第三范式的例子</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">order</span>(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">product_id <span class="type">INT</span>,</span><br><span class="line">customer_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    phone <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="五、连接查询"><a href="#五、连接查询" class="headerlink" title="五、连接查询"></a>五、连接查询</h1><p>建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person (</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">card_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> card (</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> card <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;饭卡&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> card <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;建行卡&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> card <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">&#x27;工商卡&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> card <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="string">&#x27;农行卡&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> card <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="string">&#x27;邮政卡&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><strong>没有创建外键时，可以使用内外查询将两个表的内容合并在一起查询</strong></p><h2 id="1、内连接"><a href="#1、内连接" class="headerlink" title="1、内连接"></a>1、内连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">AS</span> p <span class="keyword">INNER</span> <span class="keyword">JOIN</span> card  <span class="keyword">AS</span> c <span class="keyword">ON</span> p.card_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/mysql/mysql%5Cimage-20210329213159962.png" alt="image-20210329213159962"></p><p><strong>内联查询：两张表通过某个字段合并起来，查询出相关数据</strong></p><h2 id="2、外连接"><a href="#2、外连接" class="headerlink" title="2、外连接"></a>2、外连接</h2><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ...</span><br><span class="line">或</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">AS</span> p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> card <span class="keyword">AS</span> c <span class="keyword">ON</span> p.card_id <span class="operator">=</span> c.id;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">AS</span> p <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> card <span class="keyword">AS</span> c <span class="keyword">ON</span> p.card_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/mysql/mysql%5Cimage-20210329214309504.png" alt="image-20210329214309504"></p><p><strong>左外连接：</strong></p><ul><li>会把左表里的所有数据都取出来</li><li>对于右表，如果有数据就取出，如果没有就为空</li></ul><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ...</span><br><span class="line">或</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">AS</span> p <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> card <span class="keyword">AS</span> c <span class="keyword">ON</span> p.card_id <span class="operator">=</span> c.id;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">AS</span> p <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> card <span class="keyword">AS</span> c <span class="keyword">ON</span> p.card_id <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/mysql/mysql%5Cimage-20210329214433405.png" alt="image-20210329214433405"></p><p><strong>右外连接</strong></p><ul><li>会把右表中的所有数据都取出来</li><li>对于左表，如果有数据就取出，如果没有就为空</li></ul><h2 id="3、三种连接的图解"><a href="#3、三种连接的图解" class="headerlink" title="3、三种连接的图解"></a>3、三种连接的图解</h2><p><strong>内连接</strong></p><p><img src="/2021/04/20/mysql/mysql%5C20200810200025.png" alt="img"></p><p><strong>左连接</strong></p><p><img src="/2021/04/20/mysql/mysql%5C20200810200040.png" alt="img"></p><p><strong>右连接</strong></p><p><img src="/2021/04/20/mysql/mysql%5C20200810200104.png" alt="img"></p><h1 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h1><p>事务是一个最小的不可分割的单元，事务能够保证一个业务的完整性</p><p>多条sql语句<strong>要么同时成功，要么同时失败</strong>，这时就要用到事务</p><h2 id="1、自动提交、手动提交和回滚"><a href="#1、自动提交、手动提交和回滚" class="headerlink" title="1、自动提交、手动提交和回滚"></a>1、自动提交、手动提交和回滚</h2><p>通过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>指令可以回滚，但需要关闭自动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">查看自动提交状态</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br></pre></td></tr></table></figure><p>但如果在进行操作之后，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure><p>则无法再进行回滚（持久化）</p><h2 id="2、手动开启事务"><a href="#2、手动开启事务" class="headerlink" title="2、手动开启事务"></a>2、手动开启事务</h2><p>通过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure><p>可以手动开启事务</p><p><img src="/2021/04/20/mysql/mysql%5Cimage-20210329215120999.png" alt="image-20210329215120999"></p><p><strong>执行1</strong></p><p><img src="/2021/04/20/mysql/mysql%5Cimage-20210329215001083.png" alt="image-20210329215001083"></p><p>执行二</p><p><img src="/2021/04/20/mysql/mysql%5Cimage-20210329215145244.png" alt="image-20210329215145244"></p><h2 id="3、四大特征-ACID"><a href="#3、四大特征-ACID" class="headerlink" title="3、四大特征 ACID"></a>3、四大特征 ACID</h2><ul><li>原子性：事务是最小的单位，<strong>不可再分</strong></li><li>一致性：同一事务中的sql语句<strong>要么同时成功，要么同时失败</strong></li><li>隔离性：事务1和事务2之间具有隔离性</li><li>持久性：事物<strong>一旦结束</strong>（commit），就<strong>不可返回</strong>（rollback）</li></ul><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><ul><li>事务的隔离级别<ul><li>读未提交 read uncommitted</li><li>读已提交 read committed</li><li>可以重复读 repeatable read</li><li>串行化 serializable</li></ul></li></ul><p><img src="/2021/04/20/mysql/mysql%5C20200811132934.png" alt="img"></p><ul><li>事务的并发问题<ul><li>脏读：事务A读取了事务B更新的数据，然后<strong>B回滚操作</strong>，那么<strong>A读取到的数据是脏数据</strong></li><li>不可重复读：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了<strong>更新并提交</strong>，<strong>导致事务A多次读取同一数据时，结果不一致</strong></li><li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读</li></ul></li></ul><p><strong>总结</strong>：不可重复读的和幻读很容易混淆，<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong></p><p> 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><ul><li>查看数据库的隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">版本 <span class="number">5.</span>x</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.tx_isolation;</span><br><span class="line"></span><br><span class="line">版本 <span class="number">8.0</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.transaction_isolation;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/mysql/mysql%5C20200811132716.png" alt="img"></p><ul><li>修改数据库的隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h2&gt;&lt;h2 id=&quot;1、创建数据库和表&quot;&gt;&lt;a href=&quot;#1、创建数据库和表&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://cenkii.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="https://cenkii.github.io/2021/04/16/nginx/"/>
    <id>https://cenkii.github.io/2021/04/16/nginx/</id>
    <published>2021-04-16T13:29:10.000Z</published>
    <updated>2021-06-11T14:32:08.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是Nginx"><a href="#1、什么是Nginx" class="headerlink" title="1、什么是Nginx"></a><strong>1、什么是Nginx</strong></h2><p>Nginx是是一个高性能的<strong>HTTP和反向代理web服务器</strong>，同时它也支持电子邮件代理（它也是一个IMAP/POP3/SMTP服务器）。Nginx在BSD-like 协议下发行。其特点是占有内存少，并发能力强。</p><h2 id="2、Nginx-特点"><a href="#2、Nginx-特点" class="headerlink" title="2、Nginx 特点"></a>2、Nginx 特点</h2><ul><li>高并发、高性能；</li><li>模块化架构使得它的扩展性非常好；</li><li>异步非阻塞的事件驱动模型；</li><li>高可靠性，相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器；</li><li>热部署、平滑升级；</li><li>完全开源，生态繁荣；</li></ul><h2 id="3、Nginx-应用场景"><a href="#3、Nginx-应用场景" class="headerlink" title="3、Nginx 应用场景"></a>3、Nginx 应用场景</h2><p>Nginx 的最重要的几个使用场景：</p><ol><li>静态资源服务，通过本地文件系统提供服务；</li><li>反向代理服务，延伸出包括缓存、负载均衡等；</li><li><code>API</code> 服务， <code>OpenResty</code> ；</li></ol><blockquote><p><code>OpenResty</code> 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p></blockquote><p>1、反向代理与正向代理</p><p>反向代理</p><p><strong>反向代理</strong>（Reverse Proxy）方式是指以代理服务器来<strong>接受</strong>internet上的<strong>连接请求</strong>，然后将请求<strong>转发</strong>给内部网络上的服务器，并将从<strong>服务器</strong>上得到的<strong>结果返回</strong>给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p>反向代理是<strong>为服务端服务</strong>的，<strong>对服务端透明</strong>，服务端知道自己的消息来自是代理服务器，但客户端不知道自己请求的是代理服务器。</p><p>反向代理中的服务器下图通常为作同一件事的服务器。</p><p><img src="/2021/04/16/nginx/C:%5CUsers%5C%E9%99%88%E7%90%AA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210417140926967.png" alt="image-20210417140926967"></p><p>正向代理</p><p><strong>正向代理</strong>是一个位于<strong>客户端和原始服务器(origin server)之间</strong>的服务器，为了从原始服务器取得内容，<strong>客户端</strong>向代理<strong>发送</strong>一个请求并指定目标(原始服务器)，然后<strong>代理向原始服务器转交</strong>请求并将获得的内容<strong>返回给客户端</strong>。</p><p>正向代理为<strong>客户端服务</strong>,对于<strong>客户端是透明</strong>，对于服务端是不透明的，服务端不知道请求是来自用户还是代理。</p><p>正向代理下图中的服务器A和B通常为作用不同的服务器。</p><p><img src="/2021/04/16/nginx/C:%5CUsers%5C%E9%99%88%E7%90%AA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210417140829956.png" alt="image-20210417140829956"></p><h2 id="四、Nginx下载及安装"><a href="#四、Nginx下载及安装" class="headerlink" title="四、Nginx下载及安装"></a>四、Nginx下载及安装</h2><p>官方网址： <a href="http://nginx.org/">http://nginx.org/</a></p><p><img src="/2021/04/16/nginx/C:%5CUsers%5C%E9%99%88%E7%90%AA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210417141909305.png" alt="image-20210417141909305"></p><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><p>也可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure><p>五、、使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-152-249-centos ~]# rpm \-ql nginx</span><br><span class="line">/etc/logrotate.d/nginx</span><br><span class="line">/etc/nginx/fastcgi.conf</span><br><span class="line">/etc/nginx/fastcgi.conf.default</span><br><span class="line">/etc/nginx/fastcgi_params</span><br><span class="line">/etc/nginx/fastcgi_params.default</span><br><span class="line">/etc/nginx/koi-utf</span><br><span class="line">/etc/nginx/koi-win</span><br><span class="line">/etc/nginx/mime.types</span><br><span class="line">/etc/nginx/mime.types.default</span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line">/etc/nginx/nginx.conf.default</span><br><span class="line">/etc/nginx/scgi_params</span><br><span class="line">/etc/nginx/scgi_params.default</span><br><span class="line">/etc/nginx/uwsgi_params</span><br><span class="line">/etc/nginx/uwsgi_params.default</span><br><span class="line">/etc/nginx/win-utf</span><br><span class="line">/usr/bin/nginx-upgrade</span><br><span class="line">/usr/lib/systemd/system/nginx.service</span><br><span class="line">/usr/lib64/nginx/modules</span><br><span class="line">/usr/sbin/nginx</span><br><span class="line">/usr/share/doc/nginx-1.16.1</span><br><span class="line">/usr/share/doc/nginx-1.16.1/CHANGES</span><br><span class="line">/usr/share/doc/nginx-1.16.1/README</span><br><span class="line">/usr/share/doc/nginx-1.16.1/README.dynamic</span><br><span class="line">/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10</span><br><span class="line">/usr/share/licenses/nginx-1.16.1</span><br><span class="line">/usr/share/licenses/nginx-1.16.1/LICENSE</span><br><span class="line">/usr/share/man/man3/nginx.3pm.gz</span><br><span class="line">/usr/share/man/man8/nginx-upgrade.8.gz</span><br><span class="line">/usr/share/man/man8/nginx.8.gz</span><br><span class="line">/usr/share/nginx/html/404.html</span><br><span class="line">/usr/share/nginx/html/50x.html</span><br><span class="line">/usr/share/nginx/html/en-US</span><br><span class="line">/usr/share/nginx/html/icons</span><br><span class="line">/usr/share/nginx/html/icons/poweredby.png</span><br><span class="line">/usr/share/nginx/html/img</span><br><span class="line">/usr/share/nginx/html/index.html</span><br><span class="line">/usr/share/nginx/html/nginx-logo.png</span><br><span class="line">/usr/share/nginx/html/poweredby.png</span><br><span class="line">/usr/share/vim/vimfiles/ftdetect/nginx.vim</span><br><span class="line">/usr/share/vim/vimfiles/ftplugin/nginx.vim</span><br><span class="line">/usr/share/vim/vimfiles/indent/nginx.vim</span><br><span class="line">/usr/share/vim/vimfiles/syntax/nginx.vim</span><br><span class="line">/var/lib/nginx</span><br><span class="line">/var/lib/nginx/tmp</span><br><span class="line">/var/log/nginx</span><br><span class="line">[root@VM-152-249-centos ~]# </span><br></pre></td></tr></table></figure><h2 id="我们为什么选择Nginx？"><a href="#我们为什么选择Nginx？" class="headerlink" title="我们为什么选择Nginx？"></a>我们为什么选择Nginx？</h2><h3 id="1-IO多路复用epoll"><a href="#1-IO多路复用epoll" class="headerlink" title="1. IO多路复用epoll"></a>1. IO多路复用epoll</h3><h3 id="2-轻量级"><a href="#2-轻量级" class="headerlink" title="2. 轻量级"></a>2. 轻量级</h3><ul><li>功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式添加</li><li>代码模块化 - 更适合二次开发，如阿里巴巴Tengine</li></ul><h3 id="3-CPU亲和"><a href="#3-CPU亲和" class="headerlink" title="3. CPU亲和"></a>3. CPU亲和</h3><p>把CPU核心和<strong>Nginx工作进程</strong>绑定，把每个<strong>worker进程</strong>固定在一个<strong>CPU上</strong>执行，减少切换CPU的cache miss，从而提高性能。</p><h3 id="4-sendfile"><a href="#4-sendfile" class="headerlink" title="4. sendfile"></a>4. sendfile</h3><p>sendfile: 设置为on表示启动<strong>高效传输文件</strong>的模式。</p><p>sendfile可以让Nginx在传输文件时直接在<strong>磁盘和tcp socket</strong>之间传输数据。如果这个参数不开启，会先在<strong>用户空间</strong>（Nginx进程空间）申请一个<strong>buffer</strong>，用read函数把数据从磁盘读到cache，再从cache读取到用户空间的buffer，再用write函数把数据从用户空间的buffer写入到内核的buffer，最后到tcp socket。开启这个参数后可以让数据<strong>不用经过用户buffer</strong>。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Nginx由<strong>内核和模块</strong>组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过<strong>查找配置文件将客户端请求映射到一个location block</strong>（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。</p><p>Nginx的模块从结构上分为核心模块、基础模块和第三方模块：</p><ol><li>核心模块：HTTP模块、EVENT模块和MAIL模块</li><li>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块</li><li>第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块</li></ol><p>用户根据自己的需要开发的模块都属于第三方模块。正是有了这么多模块的支撑，Nginx的功能才会如此强大。</p><p>Nginx的模块从功能上分为如下三类：</p><ul><li>Handlers（处理器模块）。此类模块<strong>直接处理请求</strong>，并进行<strong>输出内容和修改headers信息</strong>等操作。Handlers处理器模块一般只能有一个。</li><li>Filters （过滤器模块）。此类模块主要对<strong>其他处理器模块输出</strong>的内容进行<strong>修改</strong>操作，最后由Nginx输出。</li><li>Proxies （代理类模块）。此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与<strong>后端一些服务</strong>比如FastCGI等进行<strong>交互</strong>，实现服务代理和负载均衡等功能。</li></ul><p>Nginx内置模块</p><ul><li>http_auth_basic_module HTTP基本认证</li><li>http_stub_status_module 状态信息</li><li>http_gzip_module 压缩资源</li><li>http_gzip_static_module 支持.gz资源</li><li>http_sub_module 字符串替换</li><li>http_addition_module 追加内容</li><li>http_realip_module 获取实际IP</li><li>http_image_filter_module 图片处理</li><li>http_geoip_module 支持GeoIP</li><li>http_auth_request_module 第三方auth支持</li><li>http_flv_module 流媒体点播</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="1、静态资源WEB服务"><a href="#1、静态资源WEB服务" class="headerlink" title="1、静态资源WEB服务"></a>1、静态资源WEB服务</h3><p>nginx静态资源配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">配置域：http、server、<span class="attribute">location</span></span><br><span class="line"><span class="comment">#文件高速读取</span></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="attribute">sendfile</span>   <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在 sendfile 开启的情况下，开启 tcp_nopush 提高网络包传输效率</span></span><br><span class="line"><span class="comment">#tcp_nopush 将文件一次性一起传输给客户端，就好像你有十个包裹，快递员一次送一个，来回十趟，开启后，快递员讲等待你十个包裹都派件，一趟一起送给你</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">sendfile</span>   <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#tcp_nodelay 开启实时传输，传输方式与 tcp_nopush 相反，追求实时性，但是它只有在长连接下才生效</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">sendfile</span>   <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将访问的文件压缩传输 （减少文件资源大小，提高传输速度）</span></span><br><span class="line"><span class="comment">#当访问内容以gif或jpg结尾的资源时</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg)$</span> &#123;</span><br><span class="line">   <span class="attribute">gzip</span> <span class="literal">on</span>; <span class="comment">#开启</span></span><br><span class="line">   <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>; <span class="comment">#服务器传输版本</span></span><br><span class="line">   <span class="attribute">gzip_comp_level</span> <span class="number">2</span>; <span class="comment">#压缩比，越高压缩越多，压缩越高可能会消耗服务器性能</span></span><br><span class="line">   <span class="attribute">gzip_types</span>   text/plain application/javascript application/x-javascript text/javascript text/css application/xml application/xml+rss image/jpeg image/gif image/png;     <span class="comment">#压缩文件类型</span></span><br><span class="line">   <span class="attribute">root</span> /opt/app/code;     <span class="comment">#对应目录（去该目录下寻找对应文件）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接访问已压缩文件</span></span><br><span class="line"><span class="comment">#当访问路径以download开头时，如www.baidu.com/download/test.img</span></span><br><span class="line"><span class="comment">#去/opt/app/code目录下寻找test.img.gz文件，返回到前端时已是可以浏览的img文件</span></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ load^/download</span> &#123;</span><br><span class="line">   <span class="attribute">gzip_static</span> <span class="literal">on</span> <span class="comment">#开启;</span></span><br><span class="line">   tcp_nopush <span class="literal">on</span>;</span><br><span class="line">   <span class="attribute">root</span> /opt/app/code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、浏览器缓存"><a href="#2、浏览器缓存" class="headerlink" title="2、浏览器缓存"></a>2、浏览器缓存</h3><p>HTTP协议定义的缓存机制（如：Expires; Cache-control等 ） 减少服务端的消耗，降低延迟</p><p>1.浏览器无缓存</p><p>浏览器请求 -&gt; 无缓存 -&gt; 请求WEB服务器 -&gt; 请求相应 -&gt; 呈现</p><p>在呈现阶段会根据缓存的设置在浏览器中生成缓存</p><p>2.浏览器有缓存</p><p>浏览器请求 -&gt; 有缓存 -&gt; 校验本地缓存时间是否过期 -&gt; 没有过期 -&gt; 呈现</p><p>若过期从新请求WEB服务器</p><p>3.语法配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(html|htm)$</span> &#123;</span><br><span class="line">   <span class="attribute">expires</span> <span class="number">12h</span>;    <span class="comment">#缓存12小时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器响应静态文件时，请求头信息会带上 etag 和 last_modified_since 2个标签值，浏览器下次去请求时，头信息发送这两个标签，服务器检测文件有没有发生变化，如无,直接头信息返 etag 和last_modified_since，状态码为 304 ，浏览器知道内容无改变,于是直接调用本地缓存，这个过程也请求了服务，但是传着的内容极少</p><h3 id="3、跨站访问"><a href="#3、跨站访问" class="headerlink" title="3、跨站访问"></a>3、跨站访问</h3><p>为什么浏览器禁止跨站访问？</p><ul><li>不安全，容易出现CSRF攻击</li></ul><p>为什么还需要nginx打开跨域访问？</p><ul><li>nginx配置文件通过使用add_header指令来设置response header。使用ngx_http_headers_module中的add_header 指令，在响应头中添加允许跨域。</li></ul><p>开发nginx跨站访问设置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(html|htm)$</span> &#123;</span><br><span class="line">     <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">     <span class="attribute">add_header</span> Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</span><br><span class="line">     <span class="comment">#Access-Control-Allow-Credentials true #允许cookie跨域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在响应中指定 Access-Control-Allow-Credentials 为 true 时，Access-Control-Allow-Origin 不能指定为 *，需要设置为允许访问的域名，比如<a href="http://abc.com/">http://abc.com</a></p><h3 id="4、防盗链"><a href="#4、防盗链" class="headerlink" title="4、防盗链"></a>4、防盗链</h3><p>目的：防止服务器内的<strong>静态资源</strong>被其他网站所<strong>套用</strong></p><p>防盗链设置思路：<strong>区别</strong>哪些请求是<strong>非正常的用户请求</strong></p><h4 id="基于http-refer防盗链配置模块"><a href="#基于http-refer防盗链配置模块" class="headerlink" title="基于http_refer防盗链配置模块"></a>基于http_refer防盗链配置模块</h4><p>当浏览器向web服务器发送请求的时候，一般会在<strong>头信息中带上Referer字段</strong>，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。基于头信息的Referer字段，nginx识别指定的Referer，在客户端请求时，通过匹配referer头域与配置，对于指定放行，对于其他referer视为盗链。</p><p>nginx模块ngx_http_referer_module通常用于阻挡来源非法的域名请。</p><h4 id="valid-referers"><a href="#valid-referers" class="headerlink" title="valid_referers"></a>valid_referers</h4><p>valid_referers配置项是属于ngx_http_referer_module模块传送门{:target=”_blank”}</p><blockquote><p>Syntax: valid_referers none | blocked | server_names | string …; Default: — Context: server, location</p></blockquote><p>示例配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(jpg|gif|png)$</span> &#123;</span><br><span class="line"><span class="attribute">root</span>  /opt/app/code/images;</span><br><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line"></span><br><span class="line"><span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> <span class="number">116.62.113.218</span> walidream.com;</span><br><span class="line"><span class="attribute">if</span> ($invalid_referer) &#123;</span><br><span class="line"><span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许116.62.113.218 walidream.com访问服务器图片</p><p>因为HTTPReferer头信息是可以通过程序来伪装生成的，所以通过Referer信息防盗链并非100%可靠，但是，它能够限制大部分的盗链</p><h3 id="5、HTTP代理服务"><a href="#5、HTTP代理服务" class="headerlink" title="5、HTTP代理服务"></a>5、HTTP代理服务</h3><p>代理区别</p><ul><li><strong>正向</strong>代理代理的对象是<strong>客户端</strong></li><li><strong>反向</strong>代理代理的对象是<strong>服务端</strong></li></ul><p>反向代理</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="attribute">proxy_pass</span> URL</span><br><span class="line">默认：——</span><br><span class="line">位置：loaction</span><br><span class="line"></span><br><span class="line"><span class="comment">#代理端口</span></span><br><span class="line"><span class="comment">#场景：服务器80端口开放，8080端口对外关闭，客户端需要访问到8080</span></span><br><span class="line"><span class="comment">#在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走</span></span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> default;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr; <span class="comment">#获取客户端真实IP</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">30</span>; <span class="comment">#超时时间</span></span><br><span class="line">        <span class="attribute">proxy_send_timeout</span> <span class="number">60</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">        <span class="attribute">proxy_buffering</span> <span class="literal">on</span>; <span class="comment">#开启缓冲区,减少磁盘io</span></span><br><span class="line">        <span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">128k</span>;</span><br><span class="line">        <span class="attribute">proxy_busy_buffers_size</span> <span class="number">256k</span>;</span><br><span class="line">        <span class="attribute">proxy_max_temp_file_size</span> <span class="number">256k</span>; <span class="comment">#当超过内存允许储蓄大小，存到文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、什么是Nginx&quot;&gt;&lt;a href=&quot;#1、什么是Nginx&quot; class=&quot;headerlink&quot; title=&quot;1、什么是Nginx&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、什么是Nginx&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Nginx是是一个高性能的&lt;strong&gt;
      
    
    </summary>
    
    
    
      <category term="Nginx" scheme="https://cenkii.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://cenkii.github.io/2021/04/08/Java-IO/"/>
    <id>https://cenkii.github.io/2021/04/08/Java-IO/</id>
    <published>2021-04-08T06:39:18.000Z</published>
    <updated>2021-06-16T14:30:58.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、IO-介绍"><a href="#一、IO-介绍" class="headerlink" title="一、IO 介绍"></a>一、IO 介绍</h1><p>IO即：Input/Output的缩写。 IO 操作模块在 Java 开始之初推出的是BIO，BIO 是 BlockingIO 的缩写，顾名思义就是阻塞 IO 的意思。</p><p>BIO 位于传统的 <a href="http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的优点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</p><h2 id="1-1-IO类型"><a href="#1-1-IO类型" class="headerlink" title="1.1 IO类型"></a>1.1 IO类型</h2><p>传统的 IO 大致可以分为4种类型：</p><ul><li>InputStream、OutputStream 基于<strong>字节操作</strong>的 IO</li><li>Writer、Reader 基于<strong>字符操作</strong>的 IO</li><li>File 基于<strong>磁盘操作</strong>的 IO</li><li>Socket 基于<strong>网络操作</strong>的 IO（Scoket 很多时候人们也把它归为 同步阻塞 IO ,因为网络通讯同样是 IO 行为。)</li></ul><h2 id="1-2-IO使用"><a href="#1-2-IO使用" class="headerlink" title="1.2 IO使用"></a>1.2 IO使用</h2><h3 id="1-2-1-InputStream-使用"><a href="#1-2-1-InputStream-使用" class="headerlink" title="1.2.1 InputStream 使用"></a>1.2.1 InputStream 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">inputStream.read(bytes);</span><br><span class="line">String str = <span class="keyword">new</span> String(bytes, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure><h3 id="1-2-2-OutputStream-使用"><a href="#1-2-2-OutputStream-使用" class="headerlink" title="1.2.2 OutputStream 使用"></a>1.2.2 OutputStream 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\test.txt&quot;</span>,<span class="keyword">true</span>); <span class="comment">// 参数二，表示是否追加，true=追加</span></span><br><span class="line">outputStream.write(<span class="string">&quot;Hello World OutputStream&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">outputStream.close();</span><br></pre></td></tr></table></figure><h3 id="1-2-3-Writer-使用"><a href="#1-2-3-Writer-使用" class="headerlink" title="1.2.3 Writer 使用"></a>1.2.3 Writer 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\test.txt&quot;</span>,<span class="keyword">true</span>); <span class="comment">// 参数二，是否追加文件，true=追加</span></span><br><span class="line">writer.append(<span class="string">&quot;hello world write&quot;</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><h3 id="1-2-4-Reader-使用"><a href="#1-2-4-Reader-使用" class="headerlink" title="1.2.4 Reader 使用"></a>1.2.4 Reader 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">StringBuffer bf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">String str;</span><br><span class="line"><span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bf.append(str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">bufferedReader.close();</span><br><span class="line">reader.close();</span><br><span class="line">System.out.println(bf.toString());</span><br></pre></td></tr></table></figure><p>字节流与字符流</p><p>InputStream、OutputStream 属于字节流操作。在源码中它使用byte b[]数组进行操作</p><p>Writer、Reader属于字符流操作在源码中使用char cbuf[]进行操作</p><h1 id="二、NIO"><a href="#二、NIO" class="headerlink" title="二、NIO"></a>二、NIO</h1><p>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建<strong>多路复用的、同步非阻塞 IO</strong> 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</p><h2 id="1-NIO与BIO"><a href="#1-NIO与BIO" class="headerlink" title="1 NIO与BIO"></a>1 NIO与BIO</h2><p>1、面向流和缓冲区</p><p>传统IO在传输数据时，根据输入输出的不同需要分别建立不同的链接，而且传输的数据是以流的形式在链接上进行传输的</p><p>就像自来水要通过水管将自来水厂和家连接起来一样</p><p><img src="/2021/04/08/Java-IO/20201109084453.png" alt></p><p><strong>NIO</strong></p><p>NIO在传输数据时，会在输入输出端之间建立<strong>通道</strong>，然后将数据放入到<strong>缓冲区</strong>中。缓冲区通过通道来传输数据</p><p>相当于在中间建了座水塔，自来水厂将水放入水塔，缓冲区就像水塔</p><p><img src="/2021/04/08/Java-IO/20201109085054.png" alt></p><h2 id="2-NIO的结构"><a href="#2-NIO的结构" class="headerlink" title="2 NIO的结构"></a>2 NIO的结构</h2><p>Java NIO 由以下几个核心部分组成：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。但<strong>Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互</strong>。</p><p><img src="/2021/04/08/Java-IO/image-20210410210258710.png" alt="image-20210410210258710"></p><h4 id="1、图解"><a href="#1、图解" class="headerlink" title="1、图解"></a>1、图解</h4><p>应用程序进行读写操作调用函数时，<strong>底层调用的操作系统提供给用户的读写API</strong>，调用这些API时会生成对应的指令，CPU则会执行这些指令。在计算机刚出现的那段时间，<strong>所有读写请求的指令都有CPU去执行</strong>，过多的读写请求会导致CPU无法去执行其他命令，从而CPU的利用率降低</p><p><img src="/2021/04/08/Java-IO/20201109153039.png" alt="img"></p><p>后来，<strong>DMA</strong>(Direct Memory Access，直接存储器访问)出现了。当IO请求传到计算机底层时，<strong>DMA会向CPU请求，让DMA去处理这些IO操作</strong>，从而可以让CPU去执行其他指令。DMA处理IO操作时，会请求获取总线的使用权。<strong>当IO请求过多时，会导致大量总线用于处理IO请求，从而降低效率</strong></p><p><img src="/2021/04/08/Java-IO/20201109153439.png" alt="img"></p><p>于是便有了<strong>Channel(通道)</strong>，Channel相当于一个<strong>专门用于IO操作的独立处理器</strong>，它具有独立处理IO请求的能力，当有IO请求时，它会自行处理这些IO请求</p><p><img src="/2021/04/08/Java-IO/20201109154113.png" alt="img"></p><h4 id="2、Java-Channel"><a href="#2、Java-Channel" class="headerlink" title="2、Java Channel"></a>2、Java Channel</h4><h5 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h5><p><img src="/2021/04/08/Java-IO/20201109154803.png" alt="img"></p><ul><li>FileChannel   从文件中读写数据。</li><li>DatagramChannel   能通过UDP读写网络中的数据。</li><li>SocketChannel   能通过TCP读写网络中的数据。</li><li>ServerSocketChannel  可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ul><h5 id="获得通道的方法"><a href="#获得通道的方法" class="headerlink" title="获得通道的方法"></a>获得通道的方法</h5><p>获取通道的一种方式是对支持通道的<strong>对象调用getChannel() 方法</strong>。支持通道的类如下：</p><ul><li>FileInputStream</li><li>FileOutputStream</li><li>RandomAccessFile</li><li>DatagramSocket</li><li>Socket</li><li>ServerSocket</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 本地通道</span></span><br><span class="line">      FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      FileChannel channel1 = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">      FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      FileChannel channel2 = fileOutputStream.getChannel();</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 网络通道</span></span><br><span class="line">      Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">      SocketChannel channel3 = socket.getChannel();</span><br><span class="line">      </span><br><span class="line">      ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">      ServerSocketChannel channel4 = serverSocket.getChannel();</span><br><span class="line"></span><br><span class="line">      DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">      DatagramChannel channel5 = datagramSocket.getChannel();</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 最后要关闭通道</span></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也可以通过通道的静态方法open()来获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   FileChannel open = FileChannel.open(Paths.get(<span class="string">&quot;&quot;</span>));</span><br><span class="line">   </span><br><span class="line">   SocketChannel open1 = SocketChannel.open();</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getChannel-非直接缓冲区"><a href="#getChannel-非直接缓冲区" class="headerlink" title="getChannel()+非直接缓冲区"></a>getChannel()+非直接缓冲区</h5><ul><li>getChannel()获得通道</li><li>allocate()获得<strong>非直接缓冲区</strong></li></ul><p>通过非直接缓冲区读写数据，需要通过通道来传输缓冲区里的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">      FileOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 获得通道</span></span><br><span class="line">      FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">      FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 利用 try-catch-finally 保证关闭</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>);</span><br><span class="line">         os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获得通道</span></span><br><span class="line">         inChannel = is.getChannel();</span><br><span class="line">         outChannel = os.getChannel();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获得缓冲区，用于在通道中传输数据</span></span><br><span class="line">         ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 循环将字节数据放入到buffer中，然后写入磁盘中</span></span><br><span class="line">         <span class="keyword">while</span> (inChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 切换模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            outChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               inChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               outChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图片读取后，被写入到了指定位置</strong></p><p><img src="/2021/04/08/Java-IO/20201109211055.png" alt="img"></p><h5 id="open-直接缓冲区"><a href="#open-直接缓冲区" class="headerlink" title="open()+直接缓冲区"></a>open()+直接缓冲区</h5><ul><li>通过open获得通道</li><li>通过FileChannel.map()获取直接缓冲区</li></ul><p>使用直接缓冲区时，无需通过通道来传输数据，直接将数据放在缓冲区内即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 通过open()方法来获得通道</span></span><br><span class="line">      FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.jpg&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// outChannel需要为 READ WRITE CREATE模式</span></span><br><span class="line">      <span class="comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span></span><br><span class="line">      <span class="comment">// CREATE是因为要创建新的文件</span></span><br><span class="line">      FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\3.jpg&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获得直接缓冲区</span></span><br><span class="line">      MappedByteBuffer inMapBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">      MappedByteBuffer outMapBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inMapBuf.limit()];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 因为是直接缓冲区，可以直接将数据放入到内存映射文件，无需通过通道传输</span></span><br><span class="line">      inMapBuf.get(bytes);</span><br><span class="line">      outMapBuf.put(bytes);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭缓冲区，这里没有用try-catch-finally</span></span><br><span class="line">      inChannel.close();</span><br><span class="line">      outChannel.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果，图片被创建</strong></p><p><img src="/2021/04/08/Java-IO/20201109214801.png" alt="img"></p><h5 id="通道间直接传输"><a href="#通道间直接传输" class="headerlink" title="通道间直接传输"></a>通道间直接传输</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelToChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">// 通过open()方法来获得通道</span></span><br><span class="line">   FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\1.mp4&quot;</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// outChannel需要为 READ WRITE CREATE模式</span></span><br><span class="line">   <span class="comment">// READ WRITE是因为后面获取直接缓冲区时模式为READ_WRITE模式</span></span><br><span class="line">   <span class="comment">// CREATE是因为要创建新的文件</span></span><br><span class="line">   FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;F:\\JDKLearning\\src\\main\\NIO\\day1\\4.mp4&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 通道间直接传输</span></span><br><span class="line">   inChannel.transferTo(<span class="number">0</span>, inChannel.size(), outChannel);</span><br><span class="line">   <span class="comment">// 对应的还有transferFrom</span></span><br><span class="line">   <span class="comment">// outChannel.transferFrom(inChannel, 0, inChannel.size());</span></span><br><span class="line"></span><br><span class="line">   inChannel.close();</span><br><span class="line">   outChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="直接缓冲区VS非直接缓冲区"><a href="#直接缓冲区VS非直接缓冲区" class="headerlink" title="直接缓冲区VS非直接缓冲区"></a>直接缓冲区VS非直接缓冲区</h5><p><strong>效率</strong></p><p>读取一个MP4文件，通过二者花费时间的多少来判定执行的速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getChannel() + 非直接缓冲区耗时</span></span><br><span class="line"><span class="number">708</span></span><br><span class="line"><span class="comment">// open() + 直接缓冲区耗时</span></span><br><span class="line"><span class="number">115</span></span><br><span class="line"><span class="comment">// channel transferTo channel耗时</span></span><br><span class="line"><span class="number">47</span></span><br></pre></td></tr></table></figure><p><strong>内存占用</strong></p><p>直接缓冲区的读写速度虽然很快，但是会占用很多很多内存空间。如果文件过大，会使得计算机运行速度变慢</p><h4 id="3、分散和聚集"><a href="#3、分散和聚集" class="headerlink" title="3、分散和聚集"></a>3、分散和聚集</h4><h5 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h5><p>分散读取（Scattering Reads）是指<strong>从Channel 中读取的数据“分散”到多个Buffer 中</strong></p><p><strong>注意</strong>：按照缓冲区的<strong>顺序</strong>，从Channel 中读取的数据依次将 Buffer 填满</p><p><img src="/2021/04/08/Java-IO/20201111082427.png" alt="img"></p><h5 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h5><p>聚集写入（Gathering Writes）是指将<strong>多个Buffer 中的数据“聚集”到Channel</strong></p><p>按照缓冲区的<strong>顺序</strong>，写入position 和limit 之间的数据到Channel</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201111082547.png" alt="img"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划.txt&quot;</span>);</span><br><span class="line">      FileOutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:\\JDKLearning\\src\\main\\nio\\day2\\计划2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">      FileChannel inChannel = is.getChannel();</span><br><span class="line">      FileChannel outChannel = os.getChannel();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获得多个缓冲区，并且放入到缓冲区数组中</span></span><br><span class="line">      ByteBuffer byteBuffer1 = ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">      ByteBuffer byteBuffer2 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      ByteBuffer[] byteBuffers = &#123;byteBuffer1, byteBuffer2&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 分散读取</span></span><br><span class="line">      inChannel.read(byteBuffers);</span><br><span class="line">      </span><br><span class="line">      byteBuffer1.flip();</span><br><span class="line">      byteBuffer2.flip();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 聚集写入</span></span><br><span class="line">      outChannel.write(byteBuffers);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/08/Java-IO/20201111083219.png" alt="img"></p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h4 id="1、缓冲区类型"><a href="#1、缓冲区类型" class="headerlink" title="1、缓冲区类型"></a>1、缓冲区类型</h4><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(<strong>boolean 除外</strong>) ，有以下Buffer 常用子类</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p><strong>各种类型的缓冲区中，都有一个对应类型的数组</strong>，如</p><p>ByteBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br></pre></td></tr></table></figure><p>继承关系</p><p><img src="/2021/04/08/Java-IO/20201109091555.png" alt></p><h4 id="2、获取缓冲区"><a href="#2、获取缓冲区" class="headerlink" title="2、获取缓冲区"></a>2、获取缓冲区</h4><p>通过<strong>allocate方法</strong>可以获取一个对应缓冲区的对象，它是缓冲区类的一个静态方法</p><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个容量大小为1024字节的字节缓冲区</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h4 id="3、核心属性"><a href="#3、核心属性" class="headerlink" title="3、核心属性"></a>3、核心属性</h4><p>缓冲区的父类Buffer中有几个核心属性，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure><ul><li>capacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</li><li>limit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong>。在写模式下他表示最多能写多少数据，等于capacity。在读模式下，表示最多读多少，它的值等于写模式下的position</li><li>position：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong>，在写数据时总是指向下一个可插入地方，最大值为capacity – 1。当读模式下会置为0，读一次移一次。</li><li>mark：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><p><img src="/2021/04/08/Java-IO/image-20210410203524736.png" alt="image-20210410203524736"></p><h4 id="4、核心方法"><a href="#4、核心方法" class="headerlink" title="4、核心方法"></a>4、核心方法</h4><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h5><ul><li>put()方法可以将一个数据放入到缓冲区中。</li><li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity = limit ，为缓冲区容量的值。</li></ul><h5 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h5><ul><li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 / 读-&gt;写</li><li>进行该操作后<ul><li>如果是写模式-&gt;读模式，position = 0 ， limit 指向最后一个元素的下一个位置，即写的position ，capacity不变</li><li>如果是读-&gt;写，则恢复为put()方法中的值</li></ul></li></ul><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><ul><li>get()方法会读取缓冲区中的一个值</li><li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li></ul><h5 id="ewind-方法"><a href="#ewind-方法" class="headerlink" title="ewind()方法"></a>ewind()方法</h5><ul><li>该方法<strong>只能在读模式下使用</strong></li><li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li></ul><h5 id="clean-方法"><a href="#clean-方法" class="headerlink" title="clean()方法"></a>clean()方法</h5><ul><li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position = 0, capacity = limit</li><li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li></ul><h5 id="mark-和reset-方法"><a href="#mark-和reset-方法" class="headerlink" title="mark()和reset()方法"></a>mark()和reset()方法</h5><ul><li>mark()方法会将postion的值保存到mark属性中</li><li>reset()方法会将position的值改为mark中保存的值</li></ul><h4 id="5、非直接缓冲区和直接缓冲区"><a href="#5、非直接缓冲区和直接缓冲区" class="headerlink" title="5、非直接缓冲区和直接缓冲区"></a>5、非直接缓冲区和直接缓冲区</h4><h5 id="非直接缓冲区"><a href="#非直接缓冲区" class="headerlink" title="非直接缓冲区"></a>非直接缓冲区</h5><p>通过<strong>allocate()</strong>方法获取的缓冲区都是非直接缓冲区。这些缓冲区是建立在JVM<strong>堆内存</strong>之中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆内存中开辟空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;        <span class="comment">// package-private</span></span><br><span class="line">    <span class="comment">// new byte[cap] 创建数组，在堆内存中开辟空间</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    hb = new byte[cap];</span></span><br><span class="line"><span class="comment">    offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/08/Java-IO/20201109151057.png" alt="img"></p><p>通过非直接缓冲区，想要将数据写入到物理磁盘中，或者是从物理磁盘读取数据。<strong>都需要经过JVM和操作系统</strong>，数据在两个地址空间中传输时，会<strong>copy</strong>一份保存在对方的空间中。所以相对于直接缓冲区的读取效率较低</p><h5 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h5><p><strong>只有ByteBuffer可以获得直接缓冲区</strong>，通过allocateDirect()获取的缓冲区为直接缓冲区，这些缓冲区是建立在<strong>物理内存</strong>之中的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 申请物理内存</span></span><br><span class="line"><span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/08/Java-IO/20201109151520.png" alt="img"></p><p>直接缓冲区通过在操作系统和JVM之间创建<strong>物理内存映射文件</strong>加快缓冲区数据读/写入物理磁盘的速度。放到物理内存映射文件中的数据就不归应用程序控制了，操作系统会自动将物理内存映射文件中的数据写入到物理内存中</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><h5 id="阻塞式网络通信"><a href="#阻塞式网络通信" class="headerlink" title="阻塞式网络通信"></a>阻塞式网络通信</h5><p>传统的IO 流都是阻塞式的。也就是说，当一个线程调用read() 或write() 时，<strong>该线程被阻塞</strong>，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>因此，在完成网络通信进行IO 操作时，由于线程会阻塞，所以<strong>服务器端必须为每个客户端都提供一个独立的线程进行处理</strong>，当服务器端需要处理大量客户端时，<strong>性能急剧下降</strong></p><p>也就是说，服务器在等待IO准备就绪的期间，<strong>线程处于阻塞状态</strong>，若为单线程，等待期间CPU未执行任何任务，效率降低。所以需要开启多个线程，当某些线程因为等待IO准备就绪时，CPU可以去执行其他线程中的任务。但是线程的创建、切换与销毁的开销也是不小的。当大量的任务到来时，服务器性能也急剧下降。</p><p><img src="/2021/04/08/Java-IO/20201111090126.png" alt="img"></p><h5 id="非阻塞式网络通信"><a href="#非阻塞式网络通信" class="headerlink" title="非阻塞式网络通信"></a>非阻塞式网络通信</h5><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，<strong>若没有数据可用时，该线程可以进行其他任务</strong>。线程通常将非阻塞IO 的空闲时间用于在其他通道上执行IO 操作，所以<strong>单独的线程可以管理多个输入和输出通道</strong></p><p>因此，NIO 可以让服务器端<strong>使用一个或有限几个线程来同时处理连接到服务器端的所有客户端</strong></p><p><img src="/2021/04/08/Java-IO/20201112165417.png" alt="img"></p><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>选择器（Selector）是<strong>SelectableChannle</strong> 对象的多路复用器，Selector 可以同时监控多个SelectableChannel 的IO 状况，也就是说，利用Selector 可使一个单独的线程管理多个Channel。<strong>Selector 是非阻塞IO 的核心</strong></p><p><img src="/2021/04/08/Java-IO/20201112163633.png" alt="img"></p><p><strong>选择器的创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p><strong>绑定选择器</strong></p><p>通过调用通道的register方法可以绑定选择器，register方法有两个参数</p><ul><li><p>Selector：即绑定哪个选择器</p></li><li><p>ops：监听事件类型。ops有4个值可以选择，为<strong>SelectionKey</strong>的静态属性</p><p><img src="/2021/04/08/Java-IO/20201112164022.png" alt="img"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让选择器监听一种状态</span></span><br><span class="line">myChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="comment">// 让选择器监听多种状态</span></span><br><span class="line">myChannel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><p><strong>SelectionKey</strong></p><p><strong>表示SelectableChannel 和Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。</p><h1 id="三、AIO"><a href="#三、AIO" class="headerlink" title="三、AIO"></a>三、AIO</h1><p>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、IO-介绍&quot;&gt;&lt;a href=&quot;#一、IO-介绍&quot; class=&quot;headerlink&quot; title=&quot;一、IO 介绍&quot;&gt;&lt;/a&gt;一、IO 介绍&lt;/h1&gt;&lt;p&gt;IO即：Input/Output的缩写。 IO 操作模块在 Java 开始之初推出的是BIO，BIO
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://cenkii.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://cenkii.github.io/2021/04/07/%E5%8F%8D%E5%B0%84/"/>
    <id>https://cenkii.github.io/2021/04/07/%E5%8F%8D%E5%B0%84/</id>
    <published>2021-04-07T13:05:32.000Z</published>
    <updated>2021-04-07T13:06:47.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h1><p>java代码在计算机中经历的三个阶段：</p><p><img src="/2021/04/07/%E5%8F%8D%E5%B0%84/%E5%8F%8D%E5%B0%84%5Cimage-20210406222824534.png" alt="image-20210406222824534"></p><p>从person.class到第二阶段的过程就是反射</p><h2 id="获取class对象的方式"><a href="#获取class对象的方式" class="headerlink" title="获取class对象的方式"></a>获取class对象的方式</h2><p>第一阶段获取方式</p><p>Class.forName(“全路径类名”)</p><p>将字节码文件加载进内存，返回class对象</p><p>第二阶段获取方式</p><p>类名.class</p><p>第三阶段获取方式</p><p>对象.getClass()  getClass() 是Object类中定义以下方法</p><h3 id="关于class类"><a href="#关于class类" class="headerlink" title="关于class类"></a>关于class类</h3><p>通过Object类中的getClass() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>可以看到该方法的返回值就是Class类，<strong>Class类是反射的源头</strong></p><ul><li>Class本身也是一个类</li><li>Class对象<strong>只能由系统建立对象</strong></li><li>一个加载的类在<strong>JVM中只会有一个Class实例</strong></li><li>一个Class对象对应的是一个 加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class可以完整地得到一个类中的<strong>所有被加载的结构</strong></li><li><strong>Class类是Reflection的根源</strong>，针对任何你想动态加载、运行的类，唯有先获得相应的对象</li></ul><h4 id="拥有class对象的数据类型"><a href="#拥有class对象的数据类型" class="headerlink" title="拥有class对象的数据类型"></a>拥有class对象的数据类型</h4><p>class：外部类、内部内、静态内部类等</p><p>interface：接口</p><p>[]：数组c</p><p>enum：枚举</p><p>annotation：注解@interface</p><p>primitive type：基本数据类型</p><p>void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Class c1 = Object.class;</span><br><span class="line">      Class c2 = Collection.class;</span><br><span class="line">      Class c3 = <span class="keyword">int</span>[].class;</span><br><span class="line">      Class c4 = ElementType.class;</span><br><span class="line">      Class c5 = SuppressWarnings.class;</span><br><span class="line">      Class c6 = Integer.class;</span><br><span class="line">      Class c7 = <span class="keyword">void</span>.class;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>成员变量Field的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException, ClassNotFoundException </span>&#123;</span><br><span class="line">      Class personClass = Person.class</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得所有public修饰的属性成员变量</span></span><br><span class="line">      Field[] fields = personClass.getFields();</span><br><span class="line">      Field field = personClass.getField(<span class="string">&quot;name&quot;</span>);<span class="comment">//获取单个</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得所有属性不考虑修饰符</span></span><br><span class="line">      Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得指定属性 不考虑修饰符</span></span><br><span class="line">      Field name = personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取a的值需要创建一个对象</span></span><br><span class="line">      <span class="comment">//value即为属性a的值</span></span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      Object value = field.get(person);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//设置a的值</span></span><br><span class="line">      field.set(person,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//暴力反射，忽略修饰符直接访问</span></span><br><span class="line">      name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      Object value2 = name.get(p);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException, ClassNotFoundException </span>&#123;</span><br><span class="line">      Class personClass = Person.class</span><br><span class="line">      <span class="comment">//无参构造</span></span><br><span class="line">      Person person = (Person) constructor.newInstance();</span><br><span class="line">  <span class="comment">//有参构造</span></span><br><span class="line">      Constructor constructor = personClass.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">  Person person1 = (Person) constructor.newInstance(<span class="string">&quot;123&quot;</span>, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test3</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException, ClassNotFoundException </span>&#123;</span><br><span class="line">      Class personClass = Person.class</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得所有公有方法</span></span><br><span class="line">      Method[] methods = personClass.getMethods();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得所有方法</span></span><br><span class="line">      Method[] declaredMethods = personClass.getDeclaredMethods();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获得指定方法（对象名，实参类型列表）</span></span><br><span class="line">      Method say = personClass.getDeclaredMethod(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">      Person p = <span class="keyword">new</span> Person();</span><br><span class="line">      <span class="comment">//执行方法</span></span><br><span class="line">      say.invoke(p);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射：框架设计的灵魂&quot;&gt;&lt;a href=&quot;#反射：框架设计的灵魂&quot; class=&quot;headerlink&quot; title=&quot;反射：框架设计的灵魂&quot;&gt;&lt;/a&gt;反射：框架设计的灵魂&lt;/h1&gt;&lt;p&gt;java代码在计算机中经历的三个阶段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://cenkii.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://cenkii.github.io/2021/04/07/JVM/"/>
    <id>https://cenkii.github.io/2021/04/07/JVM/</id>
    <published>2021-04-07T12:47:35.000Z</published>
    <updated>2021-05-29T14:50:47.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1、JVM"><a href="#1、JVM" class="headerlink" title="1、JVM"></a>1、JVM</h2><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3 id="3-JVM-JRE-JDK关系"><a href="#3-JVM-JRE-JDK关系" class="headerlink" title="3. JVM JRE JDK关系"></a>3. JVM JRE JDK关系</h3><p><img src="/2021/04/07/JVM/jvmjvmjrejdk.png" alt="img"></p><h3 id="4-整体结构"><a href="#4-整体结构" class="headerlink" title="4. 整体结构"></a>4. 整体结构</h3><p><img src="/2021/04/07/JVM/zhengti.png" alt="img"></p><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>没有内存溢出</li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li><li>栈帧包括局部变量表，返回地址，锁记录，操作数栈</li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li><li>jconsole 和 jvisualvm</li></ul></li></ul><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="/2021/04/07/JVM/heap.png" alt="img"></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">F:\<span class="title">JAVA</span>\<span class="title">JDK8</span>.0\<span class="title">bin</span>&gt;<span class="title">javac</span> <span class="title">F</span>:\<span class="title">Main.java</span></span></span><br></pre></td></tr></table></figure><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v F:\Main.class</span><br></pre></td></tr></table></figure></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><img src="/2021/04/07/JVM/JVM%5Cimage-20210529221717152.png" alt="image-20210529221717152"></p></li><li><p>常量池</p><p><img src="/2021/04/07/JVM/JVM%5Cimage-20210529221849788.png" alt="image-20210529221849788"></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，<strong>#号的内容需要在常量池中查找</strong>）</p><p><img src="/2021/04/07/JVM/JVM%5Cimage-20210529222020252.png" alt="image-20210529222020252"></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是<em>.class文件中的，当该*</em>类被加载以后<strong>，它的常量池信息就会</strong>放入运行时常量池<strong>，并把里面的</strong>符号地址变为真实地址**</li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;a&quot;</span>; </span><br><span class="line">        String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String ab = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String a</span></span><br><span class="line"><span class="number">2</span>: astore_1</span><br><span class="line"><span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String b</span></span><br><span class="line"><span class="number">5</span>: astore_2</span><br><span class="line"><span class="number">6</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String ab</span></span><br><span class="line"><span class="number">8</span>: astore_3</span><br><span class="line"><span class="number">9</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String ab = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">//拼接字符串对象来创建新的字符串</span></span><br><span class="line">        String ab2 = a+b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">     Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String a</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String b</span></span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         <span class="number">6</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String ab</span></span><br><span class="line">         <span class="number">8</span>: astore_3</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">new</span>           #<span class="number">5</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">        <span class="number">12</span>: dup</span><br><span class="line">        <span class="number">13</span>: invokespecial #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span></span><br><span class="line">;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">20</span>: aload_2</span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span></span><br><span class="line">;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">24</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span></span><br><span class="line">ing;</span><br><span class="line">        <span class="number">27</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">29</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String ab = &quot;ab&quot;;</span><br><span class="line">String ab2 = a+b;</span><br><span class="line">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br><span class="line">System.out.println(ab == ab2);</span><br></pre></td></tr></table></figure><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String ab = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String ab2 = a+b;</span><br><span class="line">        <span class="comment">//使用拼接字符串的方法创建字符串</span></span><br><span class="line">        String ab3 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      Code:</span><br><span class="line">      stack=2, locals=6, args_size=1</span><br><span class="line">         0: ldc           #2                  // String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  // String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  // String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br><span class="line">;)Ljava/lang/StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String</span><br><span class="line">;)Ljava/lang/StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        //ab3初始化时直接从串池中获取字符串</span><br><span class="line">        29: ldc           #4                  // String ab</span><br><span class="line">        31: astore        5</span><br><span class="line">        33: return</span><br></pre></td></tr></table></figure><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line">        String st2 = str.intern();</span><br><span class="line">        <span class="comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class="line">        String str3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class="line">        System.out.println(str == st2);</span><br><span class="line">        System.out.println(str == str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span></span><br><span class="line">        String str3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span></span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span></span><br><span class="line">        String str2 = str.intern();</span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        System.out.println(str == str2);</span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        System.out.println(str == str3);</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">        System.out.println(str2 == str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><a href><img src="/2021/04/07/JVM/20200608150715.png" alt="img"></a></p><p><strong>使用了DirectBuffer</strong></p><p><a href><img src="/2021/04/07/JVM/20200608150736.png" alt="img"></a></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过ByteBuffer申请<span class="number">1</span>M的直接内存</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ByteBuffer allocateDirect(int capacity) &#123;</span><br><span class="line">    return new DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DirectByteBuffer类</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(int cap) &#123;   // package-private</span><br><span class="line">   </span><br><span class="line">    super(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    int ps = Bits.pageSize();</span><br><span class="line">    long size = Math.max(<span class="number">1</span>L, (long)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    long base = <span class="number">0</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); //申请内存</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        throw x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (byte) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        // Round up to page boundary</span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br><span class="line">    att = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void clean() &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(this)) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               this.thunk.run(); //调用run方法</span><br><span class="line">           &#125; catch (final Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                   public Void run() &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != null) &#123;</span><br><span class="line">                           (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.<span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">                       return null;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>对应对象的run方法</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        // Paranoia</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); //释放直接内存中占用的内存</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><a href><img src="/2021/04/07/JVM/20200608150750.png" alt="img"></a></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><a href><img src="/2021/04/07/JVM/20200608150800.png" alt="img"></a></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> _4M = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref= <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4M]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> _4M = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">        ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref= <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4M]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历引用队列，如果有元素，则移除</span></span><br><span class="line">        Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span>(poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">            list.remove(poll);</span><br><span class="line">            <span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><a href><img src="/2021/04/07/JVM/20200608150813.png" alt="img"></a></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><a href><img src="/2021/04/07/JVM/20200608150827.png" alt="img"></a></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><a href><img src="/2021/04/07/JVM/20200608150842.png" alt="img"></a></p><p><img src="/2021/04/07/JVM/20200608150856.png" alt="img"></p><p><img src="/2021/04/07/JVM/20200608150907.png" alt="img"></p><p><a href><img src="/2021/04/07/JVM/20200608150919.png" alt="img"></a></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><a href><img src="/2021/04/07/JVM/20200608150931.png" alt="img"></a></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><a href><img src="/2021/04/07/JVM/20200608150939.png" alt="img"></a></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><a href><img src="/2021/04/07/JVM/20200608150946.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/20200608150955.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/20200608151002.png" alt="img"></a></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><a href><img src="/2021/04/07/JVM/20200608151010.png" alt="img"></a></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><a href><img src="/2021/04/07/JVM/20200608151018.png" alt="img"></a></p><p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151027.png" alt="img"></a></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151039.png" alt="img"></a></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151052.png" alt="img"></a></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><a href><img src="/2021/04/07/JVM/20200909201212.png" alt="img"></a></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><a href><img src="/2021/04/07/JVM/20200608151100.png" alt="img"></a></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><a href><img src="/2021/04/07/JVM/20200608151109.png" alt="img"></a></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151119.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/20200608151129.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/20200608151140.png" alt="img"></a></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151150.png" alt="img"></a></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><a href><img src="/2021/04/07/JVM/20200608151201.png" alt="img"></a></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151211.png" alt="img"></a></p><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151222.png" alt="img"></a></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><p><a href><img src="/2021/04/07/JVM/20200608151229.png" alt="img"></a></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151239.png" alt="img"></a></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><a href><img src="/2021/04/07/JVM/20200608151249.png" alt="img"></a></p><h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p>查看虚拟机参数命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;F:\JAVA\JDK8.<span class="number">0</span>\bin\java&quot; -XX:+PrintFlagsFinal -version | <span class="built_in">findstr</span> &quot;GC&quot;</span><br></pre></td></tr></table></figure><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li>CMS G1 ZGC  互联网低延迟</li><li>ParallelGC  科学运算</li><li>Zing （虚拟机）超低延迟</li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li>新生代的特点<ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li>新生代内存越大越好么？<ul><li>不是<ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li>新生代内存设置为内容纳 <em>[并发量(请求-响应)]</em> 的数据为宜</li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><ul><li>内存越大越好</li><li>先尝试调优新生代</li></ul><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><a href><img src="/2021/04/07/JVM/20200608151300.png" alt="img"></a></p><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>java终端中，执行javac X:…\XXX.java</li></ul><p><a href><img src="/2021/04/07/JVM/20200910155135.png" alt="img"></a></p><p>以下是字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u4             magic;</span><br><span class="line">u2             minor_version;    </span><br><span class="line">u2             major_version;    </span><br><span class="line">u2             constant_pool_count;    </span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];    </span><br><span class="line">u2             access_flags;    </span><br><span class="line">u2             this_class;    </span><br><span class="line">u2             super_class;   </span><br><span class="line">u2             interfaces_count;    </span><br><span class="line">u2             interfaces[interfaces_count];   </span><br><span class="line">u2             fields_count;    </span><br><span class="line">field_info     fields[fields_count];   </span><br><span class="line">u2             methods_count;    </span><br><span class="line">method_info    methods[methods_count];    </span><br><span class="line">u2             attributes_count;    </span><br><span class="line">attribute_info attributes[attributes_count];</span><br></pre></td></tr></table></figure><h4 id="1-1魔数"><a href="#1-1魔数" class="headerlink" title="1.1魔数"></a>1.1魔数</h4><p>u4 magic</p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="1-2版本"><a href="#1-2版本" class="headerlink" title="1.2版本"></a>1.2版本</h4><p>u2 minor_version;</p><p>u2 major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p><p>34H = 52，代表JDK8</p><h4 id="1-3常量池"><a href="#1-3常量池" class="headerlink" title="1.3常量池"></a>1.3常量池</h4><p>长度</p><p>0000000 ca fe ba be 00 00 00 34 <strong>00 23</strong> 0a 00 06 00 15 09</p><p>内容</p><p>0000000 ca fe ba be 00 00 00 34 00 23 <strong>0a 00 06 00 15</strong> 09</p><p>类型+长度+内容</p><p>可参考</p><p><a href="https://docs.oracle.com/javase/specsjvms/se8/htmljvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specsjvms/se8/htmljvms-6.html#jvms-6.5</a></p><h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/main.class</span><br><span class="line">  Last modified <span class="number">2021</span>-<span class="number">5</span>-<span class="number">29</span>; size <span class="number">407</span> bytes</span><br><span class="line">  MD5 checksum 40f2fa6c8c7e18e1f402c80e1e9efb5c</span><br><span class="line">  Compiled from <span class="string">&quot;main.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">   #1 </span>= Methodref          #<span class="number">6.</span>#<span class="number">15</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">16.</span>#<span class="number">17</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">18</span>            <span class="comment">// Hello World!</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">19.</span>#<span class="number">20</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">11</span>            <span class="comment">// main</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">21</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               main</span><br><span class="line">  #<span class="number">12</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">13</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">14</span> = Utf8               main.java</span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">16</span> = Class              #<span class="number">22</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">23</span>:#<span class="number">24</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               Hello World!</span><br><span class="line">  #<span class="number">19</span> = Class              #<span class="number">25</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">26</span>:#<span class="number">27</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">22</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">23</span> = Utf8               out</span><br><span class="line">  #<span class="number">24</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">25</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">26</span> = Utf8               println</span><br><span class="line">  #<span class="number">27</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World!</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">4</span>: <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;main.java&quot;</span></span><br></pre></td></tr></table></figure><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_1</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;        </span><br><span class="line">        <span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;        </span><br><span class="line">        <span class="keyword">int</span> c = a + b;        </span><br><span class="line">        System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151317.png" alt="img"></a></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151325.png" alt="img"></a></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong></p><ul><li><p>将一个 byte 压入操作数栈</p><p>（其长度会补齐 4 个字节），类似的指令还有</p><ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈</li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151336.png" alt="img"></a></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br></pre></td></tr></table></figure><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151346.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151412.png" alt="img"></a></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151421.png" alt="img"></a></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151432.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151441.png" alt="img"></a></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151450.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151459.png" alt="img"></a></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151508.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151523.png" alt="img"></a></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151547.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151555.png" alt="img"></a></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151605.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151613.png" alt="img"></a></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151624.png" alt="img"></a></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p><p>生成新的栈帧（分配 locals、stack等）</p><p>传递参数，执行新栈帧中的字节码</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151632.png" alt="img"></a></p><p>执行完毕，弹出栈帧</p><p>清除 main 操作数栈内容</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200608151640.png" alt="img"></a></p><p><strong>return</strong> 完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x); <span class="comment">//接过为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span> <span class="comment">//操作数栈分配2个空间，局部变量表分配3个空间</span></span><br><span class="line">        <span class="number">0</span>: iconst_0 <span class="comment">//准备一个常数0</span></span><br><span class="line">        <span class="number">1</span>: istore_1 <span class="comment">//将常数0放入局部变量表的1号槽位 i=0</span></span><br><span class="line">        <span class="number">2</span>: iconst_0 <span class="comment">//准备一个常数0</span></span><br><span class="line">        <span class="number">3</span>: istore_2 <span class="comment">//将常数0放入局部变量的2号槽位 x=0   </span></span><br><span class="line">        <span class="number">4</span>: iload_1      <span class="comment">//将局部变量表1号槽位的数放入操作数栈中</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">10</span> <span class="comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span></span><br><span class="line">        <span class="number">7</span>: if_icmpge     <span class="number">21</span> <span class="comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span></span><br><span class="line">       <span class="number">10</span>: iload_2      <span class="comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span></span><br><span class="line">       <span class="number">11</span>: iinc          <span class="number">2</span>, <span class="number">1</span>   <span class="comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span></span><br><span class="line">       <span class="number">14</span>: istore_2 <span class="comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span></span><br><span class="line">       <span class="number">15</span>: iinc          <span class="number">1</span>, <span class="number">1</span> <span class="comment">//1号槽位的值自增1</span></span><br><span class="line">       <span class="number">18</span>: goto          <span class="number">4</span> <span class="comment">//跳转到第4条指令</span></span><br><span class="line">       <span class="number">21</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">24</span>: iload_2</span><br><span class="line">       <span class="number">25</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">       <span class="number">28</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(i); <span class="comment">//结果为30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">7</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">        <span class="number">10</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">12</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo4</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo4 d = <span class="keyword">new</span> Demo4(<span class="string">&quot;s3&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(d.a);</span><br><span class="line">        System.out.println(d.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">4</span>: aload_0</span><br><span class="line">        <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String s1</span></span><br><span class="line">        <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">10</span>: aload_0</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">16</span>: aload_0</span><br><span class="line">       <span class="number">17</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">19</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">22</span>: aload_0</span><br><span class="line">       <span class="number">23</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String s2</span></span><br><span class="line">       <span class="number">25</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="comment">//原始构造方法在最后执行</span></span><br><span class="line">       <span class="number">28</span>: aload_0</span><br><span class="line">       <span class="number">29</span>: aload_1</span><br><span class="line">       <span class="number">30</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">33</span>: aload_0</span><br><span class="line">       <span class="number">34</span>: iload_2</span><br><span class="line">       <span class="number">35</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">38</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo5 demo5 = <span class="keyword">new</span> Demo5();</span><br><span class="line">        demo5.test1();</span><br><span class="line">        demo5.test2();</span><br><span class="line">        demo5.test3();</span><br><span class="line">        Demo5.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class comjvm/Demo5 </span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method test1:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">        <span class="number">13</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method test2:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method test3:()V</span></span><br><span class="line">        <span class="number">20</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li><li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">12</span></span><br><span class="line">        <span class="number">8</span>: astore_2</span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_1</span><br><span class="line">       <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">     <span class="comment">//多出来一个异常表</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">19</span></span><br><span class="line">        <span class="number">8</span>: astore_2</span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_1</span><br><span class="line">       <span class="number">12</span>: goto          <span class="number">19</span></span><br><span class="line">       <span class="number">15</span>: astore_2</span><br><span class="line">       <span class="number">16</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">18</span>: istore_1</span><br><span class="line">       <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/ArithmeticException</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">15</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="comment">//try块</span></span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="comment">//try块执行完后，会执行finally    </span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">30</span></span><br><span class="line">        <span class="number">7</span>: istore_1</span><br><span class="line">        <span class="number">8</span>: goto          <span class="number">27</span></span><br><span class="line">       <span class="comment">//catch块     </span></span><br><span class="line">       <span class="number">11</span>: astore_2 <span class="comment">//异常信息放入局部变量表的2号槽位</span></span><br><span class="line">       <span class="number">12</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">14</span>: istore_1</span><br><span class="line">       <span class="comment">//catch块执行完后，会执行finally        </span></span><br><span class="line">       <span class="number">15</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">17</span>: istore_1</span><br><span class="line">       <span class="number">18</span>: goto          <span class="number">27</span></span><br><span class="line">       <span class="comment">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span></span><br><span class="line">       <span class="number">21</span>: astore_3</span><br><span class="line">       <span class="number">22</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">24</span>: istore_1</span><br><span class="line">       <span class="number">25</span>: aload_3</span><br><span class="line">       <span class="number">26</span>: athrow  <span class="comment">//抛出异常</span></span><br><span class="line">       <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">11</span>   Class java/lang/Exception</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">21</span>   any</span><br><span class="line">           <span class="number">11</span>    <span class="number">15</span>    <span class="number">21</span>   any</span><br></pre></td></tr></table></figure><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = Demo3.test();</span><br><span class="line">        <span class="comment">//结果为20</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: iload_0</span><br><span class="line">        <span class="number">4</span>: istore_1  <span class="comment">//暂存返回值</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0</span><br><span class="line">        <span class="number">8</span>: iload_0</span><br><span class="line">        <span class="number">9</span>: ireturn  <span class="comment">//ireturn会返回操作数栈顶的整型值20</span></span><br><span class="line">       <span class="comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span></span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: iload_0</span><br><span class="line">       <span class="number">15</span>: ireturn  <span class="comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">0</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br></pre></td></tr></table></figure><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = Demo3.test();</span><br><span class="line">      <span class="comment">//最终结果为20</span></span><br><span class="line">      System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         i = <span class="number">10</span>;</span><br><span class="line">         <span class="comment">//这里应该会抛出异常</span></span><br><span class="line">         i = i/<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         i = <span class="number">20</span>;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = Demo4.test();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0 <span class="comment">//赋值给i 10</span></span><br><span class="line">        <span class="number">3</span>: iload_0  <span class="comment">//加载到操作数栈顶</span></span><br><span class="line">        <span class="number">4</span>: istore_1 <span class="comment">//加载到局部变量表的1号位置</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0 <span class="comment">//赋值给i 20</span></span><br><span class="line">        <span class="number">8</span>: iload_1 <span class="comment">//加载局部变量表1号位置的数10到操作数栈</span></span><br><span class="line">        <span class="number">9</span>: ireturn <span class="comment">//返回操作数栈顶元素 10</span></span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: aload_2 <span class="comment">//加载异常</span></span><br><span class="line">       <span class="number">15</span>: athrow <span class="comment">//抛出异常</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br></pre></td></tr></table></figure><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_1</span><br><span class="line">        <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class comjvm/Lock</span></span><br><span class="line">        <span class="number">6</span>: dup <span class="comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span></span><br><span class="line">        <span class="number">7</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method com/nyimajvm/day06/Lock.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">10</span>: astore_2 <span class="comment">//剩下的一份放到局部变量表的2号位置</span></span><br><span class="line">       <span class="number">11</span>: aload_2 <span class="comment">//加载到操作数栈</span></span><br><span class="line">       <span class="number">12</span>: dup <span class="comment">//复制一份，放到操作数栈，用于加锁时消耗</span></span><br><span class="line">       <span class="number">13</span>: astore_3 <span class="comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span></span><br><span class="line">       <span class="number">14</span>: monitorenter <span class="comment">//加锁</span></span><br><span class="line">       <span class="comment">//锁住后代码块中的操作    </span></span><br><span class="line">       <span class="number">15</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">18</span>: iload_1</span><br><span class="line">       <span class="number">19</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">       <span class="comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span></span><br><span class="line">       <span class="number">22</span>: aload_3    </span><br><span class="line">       <span class="number">23</span>: monitorexit <span class="comment">//解锁</span></span><br><span class="line">       <span class="number">24</span>: goto          <span class="number">34</span></span><br><span class="line">       <span class="comment">//异常操作    </span></span><br><span class="line">       <span class="number">27</span>: astore        <span class="number">4</span></span><br><span class="line">       <span class="number">29</span>: aload_3</span><br><span class="line">       <span class="number">30</span>: monitorexit <span class="comment">//解锁</span></span><br><span class="line">       <span class="number">31</span>: aload         <span class="number">4</span></span><br><span class="line">       <span class="number">33</span>: athrow</span><br><span class="line">       <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line">     <span class="comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           <span class="number">15</span>    <span class="number">24</span>    <span class="number">27</span>   any</span><br><span class="line">           <span class="number">27</span>    <span class="number">31</span>    <span class="number">27</span>   any</span><br></pre></td></tr></table></figure><h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <em>.java 源码编译为 <em>.class 字节码的过程中，</em></em>自动生成<strong>和</strong>转换**的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译期优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个无参构造器是java编译器帮我们加上的</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Candy1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot; &lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Integer x = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> y = x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换过程如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//基本类型赋值给包装类型，称为装箱</span></span><br><span class="line">      Integer x = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//包装类型赋值给基本类型，称谓拆箱</span></span><br><span class="line">      <span class="keyword">int</span> y = x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      list.add(<span class="number">10</span>);</span><br><span class="line">      Integer x = list.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/util/ArrayList</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">      <span class="number">11</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">      <span class="comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span></span><br><span class="line">      <span class="number">14</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line"></span><br><span class="line">      <span class="number">19</span>: pop</span><br><span class="line">      <span class="number">20</span>: aload_1</span><br><span class="line">      <span class="number">21</span>: iconst_0</span><br><span class="line">      <span class="comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span></span><br><span class="line">      <span class="number">22</span>: invokeinterface #<span class="number">6</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span></span><br><span class="line"><span class="comment">//这里进行了类型转换，将Object转换成了Integer</span></span><br><span class="line">      <span class="number">27</span>: checkcast     #<span class="number">7</span>                  <span class="comment">// class java/lang/Integer</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      <span class="number">31</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>所以调用get函数取值时，有一个类型转换的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = (Integer) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = (Integer) list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//将args赋值给arr，可以看出String...实际就是String[] </span></span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Demo4 &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String[] arr = args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      foo(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组赋初值的简化写法也是一种语法糖。</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会帮我们转换为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Demo5 &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = arr[i];</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果是集合使用foreach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Demo5 &#123;&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">//获得该集合的迭代器</span></span><br><span class="line">      Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">         Integer x = iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&quot;world&quot;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译器中执行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Demo6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">//通过字符串的hashCode+value来判断是否匹配</span></span><br><span class="line">      <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">         <span class="comment">//hello的hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">99162322</span> :</span><br><span class="line">            <span class="comment">//再次比较，因为字符串的hashCode有可能相等</span></span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">//world的hashCode</span></span><br><span class="line">         <span class="keyword">case</span> <span class="number">11331880</span> :</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">               x = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//用第二个switch在进行输出判断</span></span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">         <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器中执行的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span></span><br><span class="line"><span class="comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span></span><br><span class="line"><span class="comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span></span><br><span class="line"><span class="comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;</span><br><span class="line">      <span class="comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span></span><br><span class="line">         map[SEX.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SEX sex = SEX.MALE;</span><br><span class="line">      <span class="comment">//将对应位置枚举元素的值赋给x，用于case操作</span></span><br><span class="line">      <span class="keyword">int</span> x = $MAP.map[sex.ordinal()];</span><br><span class="line">      <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;man&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;woman&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEX</span> </span>&#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;   </span><br><span class="line">   <span class="comment">//对应枚举类中的元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> &#123;       </span><br><span class="line">        <span class="comment">//调用构造函数，传入枚举元素的值及ordinal</span></span><br><span class="line">        MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);    </span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);   </span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//调用父类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;  </span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//用额外创建的类来创建匿名内部类对象</span></span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Demo8$<span class="number">1</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个额外的类，实现了Runnable接口</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果匿名内部类中引用了<strong>局部变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">//多创建了一个变量</span></span><br><span class="line">   <span class="keyword">int</span> val$x;</span><br><span class="line">   <span class="comment">//变为了有参构造器</span></span><br><span class="line">   <span class="keyword">public</span> Demo8$<span class="number">1</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">      <span class="keyword">this</span>.val$x = x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(val$x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li><p>将类的字节码载入</p><p>方法区</p><p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p><ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p></li><li><p>加载和链接可能是<strong>交替运行</strong>的</p></li></ul><p><a href><img src="/2021/04/07/JVM/JVM%5C20200611205050.png" alt="img"></a></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">      ClassLoader loader = Demo1.class.getClassLoader();</span><br><span class="line">      <span class="comment">//只加载不解析</span></span><br><span class="line">      Class&lt;?&gt; c = loader.loadClass(<span class="string">&quot;com.nyima.JVM.day8.C&quot;</span>);</span><br><span class="line">      <span class="comment">//用于阻塞主线程</span></span><br><span class="line">      System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">   D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><ul><li>打开HSDB</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp F:\JAVA\JDK8<span class="number">.0</span>\lib\sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><a href="20200611221703.png"><img src="/2021/04/07/JVM/JVM%5C20200611221703.png" alt="img"></a></p><ul><li>定位需要的进程</li></ul><p><a href><img src="/2021/04/07/JVM/JVM%5C20200611221857.png" alt="img"></a></p><p><a href><img src="/2021/04/07/JVM/JVM%5C20200611222029.png" alt="img"></a></p><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><a href><img src="/2021/04/07/JVM/JVM%5C20200611223153.png" alt="img"></a></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><a href="20200611230658.png"><img src="/2021/04/07/JVM/JVM%5C20200611230658.png" alt="img"></a></p><ul><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p><ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><p><a href="20200611223441.png"><img src="/2021/04/07/JVM/JVM%5C20200611223441.png" alt="img"></a></p></li></ul><p><a href="img/20200613104723.png"><img src="/2021/04/07/JVM/JVM%5C20200613104723.png" alt="img"></a></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><p><strong>注意</strong></p><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><p><a href><img src="/2021/04/07/JVM/JVM%5C20201118204542.png" alt="img"></a></p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p><p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先查找该类是否已经被该类加载器加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">//如果没有被加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//看是否被启动类加载器加载过</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">//捕获异常，但不做任何处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span></span><br><span class="line">                <span class="comment">//然后让应用类加载器去找classpath下找该类</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录时间</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul><li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul><li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li></ul></li><li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul><li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li></ul></li><li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul><li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li></ul></li></ul><h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术，降低GC次数</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// to do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong></p><p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add4</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3, <span class="keyword">int</span> x4)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//这里调用了add2方法</span></span><br><span class="line">        <span class="keyword">return</span> add2(x1, x2) + add2(x3, x4);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> x1 + x2;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法调用被替换后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add4</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3, <span class="keyword">int</span> x4)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//被替换为了方法本身</span></span><br><span class="line">        <span class="keyword">return</span> x1 + x2 + x3 + x4;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">      Method foo = Demo3.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=<span class="number">16</span>; i++) &#123;</span><br><span class="line">         foo.invoke(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span></span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href><img src="/2021/04/07/JVM/JVM%5C20200614133554.png" alt="img"></a></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span></span><br><span class="line">    <span class="comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">            <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ReflectionFactory.inflationThreshold()方法的返回值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> inflationThreshold = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><a href><img src="/2021/04/07/JVM/20200614135011.png" alt="img"></a></p><h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障。与1中内存模型不同。</p><h2 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h2><p>原子性在学习线程时讲过，下面来个例子简单回顾一下： 问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？ </p><h2 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h2><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操 作。 例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">iadd <span class="comment">// 加法</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure><p>对i–而言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i <span class="comment">// 获取静态变量i的值</span></span><br><span class="line">iconst_1 <span class="comment">// 准备常量1</span></span><br><span class="line">isub <span class="comment">// 减法</span></span><br><span class="line">putstatic i <span class="comment">// 将修改后的值存入静态变量i</span></span><br></pre></td></tr></table></figure><p><img src="/2021/04/07/JVM/jmm.png" alt="img"></p><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic i <span class="comment">// 线程1-获取静态变量i的值 线程内i=0</span></span><br><span class="line">iconst_1 <span class="comment">// 线程1-准备常量1</span></span><br><span class="line">iadd <span class="comment">// 线程1-自增 线程内i=1</span></span><br><span class="line">putstatic i <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span></span><br><span class="line">getstatic i <span class="comment">// 线程1-获取静态变量i的值 线程内i=1</span></span><br><span class="line">iconst_1 <span class="comment">// 线程1-准备常量1</span></span><br><span class="line">isub <span class="comment">// 线程1-自减 线程内i=0</span></span><br><span class="line">putstatic i <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=0</span></span><br></pre></td></tr></table></figure><p>但多线程下这 8 行代码可能交错运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic i <span class="comment">// 线程1-获取静态变量i的值 线程内i=0</span></span><br><span class="line">getstatic i <span class="comment">// 线程2-获取静态变量i的值 线程内i=0</span></span><br><span class="line">iconst_1 <span class="comment">// 线程1-准备常量1</span></span><br><span class="line">iadd <span class="comment">// 线程1-自增 线程内i=1</span></span><br><span class="line">putstatic i <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span></span><br><span class="line">iconst_1 <span class="comment">// 线程2-准备常量1</span></span><br><span class="line">isub <span class="comment">// 线程2-自减 线程内i=-1</span></span><br><span class="line">putstatic i <span class="comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span></span><br></pre></td></tr></table></figure><p>出现正数的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic i <span class="comment">// 线程1-获取静态变量i的值 线程内i=0</span></span><br><span class="line">getstatic i <span class="comment">// 线程2-获取静态变量i的值 线程内i=0</span></span><br><span class="line">iconst_1 <span class="comment">// 线程1-准备常量1</span></span><br><span class="line">iadd <span class="comment">// 线程1-自增 线程内i=1</span></span><br><span class="line">iconst_1 <span class="comment">// 线程2-准备常量1</span></span><br><span class="line">isub <span class="comment">// 线程2-自减 线程内i=-1</span></span><br><span class="line">putstatic i <span class="comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span></span><br><span class="line">putstatic i <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;h2 id=&quot;1、JVM&quot;&gt;&lt;a href=&quot;#1、JVM&quot; class=&quot;headerlink&quot; title=&quot;1、JVM&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://cenkii.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>GloVe</title>
    <link href="https://cenkii.github.io/2020/10/05/GloVe/"/>
    <id>https://cenkii.github.io/2020/10/05/GloVe/</id>
    <published>2020-10-05T12:40:34.000Z</published>
    <updated>2020-10-11T13:54:37.624Z</updated>
    
    <content type="html"><![CDATA[<p>对于word2vec和fast text而言，它们只考虑了局部的词信息。而GloVe是一个基于全局词频统计（count-based &amp; overall statistics）的词表征（word representation）工具。</p><h3 id="1、GloVe的实现步骤"><a href="#1、GloVe的实现步骤" class="headerlink" title="1、GloVe的实现步骤"></a>1、GloVe的实现步骤</h3><p>GloVe主要分以下几步1. 统计共现矩阵 2. 训练词向量</p><p>1.共现矩阵</p><p>举个例子：</p><ul><li>i love you</li><li>you love he</li><li>he love me</li></ul><p>设滑动窗口为2时，可以得到以下字典</p><p>{“i love”,”love you”,“you love”,”love he”,”he love”,”love me”}</p><p>共现矩阵如下：</p><table><thead><tr><th></th><th>i</th><th>you</th><th>he</th><th>love</th><th>me</th></tr></thead><tbody><tr><td>i</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>you</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>he</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>love</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>me</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>一般而言，这个次数的最小单位是1，但是GloVe不这么认为：它根据两个单词在上下文窗口的距离d，提出了一个衰减函数（decreasing weighting）：deacy= 1/d 用于计算权重，也就是说<strong>距离越远的两个单词所占总计数（total count）的权重越小。</strong></p><p>2.词向量训练</p><p>构建词向量（Word Vector）和共现矩阵（Co-ocurrence Matrix）之间的近似关系，论文的作者提出以下的公式可以近似地表达两者之间的关系：<br>$$<br>w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} = \log(X_{ij}) \tag{1}<br>$$<br>其中，<strong>wi和wj是我们最终要求解的词向量；</strong>bi和bj分别是两个词向量的bias term。</p><p>进一步构造loss函数如下：<br>$$<br>J = \sum_{i,j=1}^{V} f(X_{ij})(w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} – \log(X_{ij}) )^2 \tag{2}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于word2vec和fast text而言，它们只考虑了局部的词信息。而GloVe是一个基于全局词频统计（count-based &amp;amp; overall statistics）的词表征（word representation）工具。&lt;/p&gt;
&lt;h3 id=&quot;1、Glo
      
    
    </summary>
    
    
    
      <category term="nlp" scheme="https://cenkii.github.io/tags/nlp/"/>
    
  </entry>
  
  <entry>
    <title>FastText</title>
    <link href="https://cenkii.github.io/2020/10/02/FastText/"/>
    <id>https://cenkii.github.io/2020/10/02/FastText/</id>
    <published>2020-10-02T14:42:51.000Z</published>
    <updated>2020-10-05T09:47:22.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、fasttext"><a href="#1、fasttext" class="headerlink" title="1、fasttext"></a>1、fasttext</h3><p>fasttext是Facebook于2016年开源的一个词向量计算和文本分类工具，在学术上并没有太大创新。它的结构与word2vec中的CBOW类似。与其不同的是在CBOW模型中把每个单词当作一个原子看待没有考虑单词内部的形态特征，例如对于两个很相近的单词book和books，我们会用两个向量表示。而fasttext提出了子词嵌⼊(subword embedding)的⽅法，从而试图将构词信息即内部结构和形成⽅式引⼊word2vec中的CBOW。</p><span id="more"></span><h3 id="2、子词嵌入"><a href="#2、子词嵌入" class="headerlink" title="2、子词嵌入"></a>2、子词嵌入</h3><p>fasttext提出了子词嵌⼊(subword embedding)的⽅法，那么怎么实现子词嵌入呢？</p><p>fasttext使用了字符级别的n-grams来表示一个单词。</p><p>例如：对于book和books而言用3-gram表示可以写为</p><p>book : “&lt;bo”,”boo”,”ook”,”ok&gt;”</p><p>books : “&lt;bo”,”boo”,”ook”,”oks”,”ks&gt;”</p><p>其中，&lt;表示前缀，&gt;表示后缀。</p><p>1、对于低频词生成的词向量效果会更好。因为它们的n-gram可以和其它词共享。</p><p>2、对于训练词库之外的单词，仍然可以构建它们的词向量。我们可以叠加它们的字符级n-gram向量。</p><h3 id="3、fasttext架构"><a href="#3、fasttext架构" class="headerlink" title="3、fasttext架构"></a>3、fasttext架构</h3><p><img src="/2020/10/02/FastText/v2-7f38f23e98ee89d21fd16e34d5f07d69_r.png" alt></p><p>和CBOW一样，fastText模型也只有三层：输入层、隐含层、输出层（Hierarchical Softmax），输入都是多个经向量表示的单词，输出都是一个特定的target，隐含层都是对多个词向量的叠加平均。不同的是，CBOW的输入是目标单词的上下文，fastText的输入是多个单词及其n-gram特征，这些特征用来表示单个文档；CBOW的输入单词被onehot编码过，fastText的输入特征是被embedding过；CBOW的输出是目标词汇的概率，fastText的输出是文档对应的类标。fastText在输入时，将单词的字符级别的n-gram向量作为额外的特征；在输出时，fastText采用了分层Softmax，大大降低了模型训练时间。</p><p>fastText的核心思想就是：将整篇文档的词及n-gram向量叠加平均得到文档向量，然后使用文档向量做softmax多分类。</p><p>fasttext分类效果较好原因主要有两点：</p><p>1、使用词embedding而非词本身作为特征。</p><p>2、字符级n-gram特征的引入对分类效果会有一些提升 。</p><h3 id="4-fastText与Word2Vec的异同"><a href="#4-fastText与Word2Vec的异同" class="headerlink" title="4. fastText与Word2Vec的异同"></a>4. fastText与Word2Vec的异同</h3><p><strong>相同点</strong>：</p><ul><li>图模型结构很像，都是采用embedding向量的形式，得到word的隐向量表达。</li><li>都采用很多相似的优化方法，比如使用Hierarchical softmax优化训练和预测中的打分速度。</li></ul><p>之前一直不明白fasttext用层次softmax时叶子节点是啥，CBOW很清楚，它的叶子节点是词和词频，后来看了源码才知道，其实fasttext叶子节点里是类标和类标的频数。</p><table><thead><tr><th></th><th>Word2Vec</th><th>fastText</th></tr></thead><tbody><tr><td>输入</td><td>one-hot形式的单词的向量</td><td>embedding过的单词的词向量和n-gram向量</td></tr><tr><td>输出</td><td>对应的是每一个term,计算某term概率最大</td><td>对应的是分类的标签。</td></tr></tbody></table><p><strong>本质不同，体现在softmax的使用：</strong></p><p>word2vec的目的是得到词向量，该词向量最终是在输入层得到的，输出层对应的h-softmax也会生成一系列的向量，但是最终都被抛弃，不会使用。</p><p>fastText则充分利用了h-softmax的分类功能，遍历分类树的所有叶节点，找到概率最大的label</p><p><strong>fastText优点</strong>：</p><ol><li><strong>适合大型数据+高效的训练速度</strong>：能够训练模型“在使用标准多核CPU的情况下10分钟内处理超过10亿个词汇”</li><li><strong>支持多语言表达</strong>：利用其语言形态结构，fastText能够被设计用来支持包括英语、德语、西班牙语、法语以及捷克语等多种语言。FastText的性能要比时下流行的word2vec工具明显好上不少，也比其他目前最先进的词态词汇表征要好。</li><li><strong>专注于文本分类</strong>，在许多标准问题上实现当下最好的表现（例如文本倾向性分析或标签预测）。</li></ol><h3 id="5、简单实现fastText"><a href="#5、简单实现fastText" class="headerlink" title="5、简单实现fastText"></a>5、简单实现fastText</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vocab_size = <span class="number">30000</span> <span class="comment">#词表大小</span></span><br><span class="line">embedding_dim = <span class="number">128</span> <span class="comment">#embedding层向量长度</span></span><br><span class="line">sent_length = <span class="number">256</span> <span class="comment">#句子长度，如果长度不够补pad，否则截取到sent_length</span></span><br><span class="line">class_num = <span class="number">10</span> <span class="comment">#类别数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_fasttext</span>(<span class="params">vocab_size,embedding_dim,sent_length,class_num</span>):</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(tf.keras.layers.Embedding(vocab_size,embedding_dim,input_length=sent_length))</span><br><span class="line">    model.add(tf.keras.layers.GlobalAveragePooling1D())</span><br><span class="line">    model.add(tf.keras.layers.Dense(class_num,activation=<span class="string">&#x27;softmax&#x27;</span>))</span><br><span class="line">    model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,optimizer=<span class="string">&#x27;SGD&#x27;</span>,metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">model = build_fasttext(vocab_size,embedding_dim,sent_length,class_num)</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">Model: <span class="string">&quot;sequential_1&quot;</span></span><br><span class="line">_________________________________________________________________</span><br><span class="line">Layer (<span class="built_in">type</span>)                 Output Shape              Param <span class="comment">#   </span></span><br><span class="line">=================================================================</span><br><span class="line">embedding (Embedding)        (<span class="literal">None</span>, <span class="number">256</span>, <span class="number">128</span>)          <span class="number">3840000</span>   </span><br><span class="line">_________________________________________________________________</span><br><span class="line">global_average_pooling1d (Gl (<span class="literal">None</span>, <span class="number">128</span>)               <span class="number">0</span>         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense (Dense)                (<span class="literal">None</span>, <span class="number">10</span>)                <span class="number">1290</span>      </span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">3</span>,<span class="number">841</span>,<span class="number">290</span></span><br><span class="line">Trainable params: <span class="number">3</span>,<span class="number">841</span>,<span class="number">290</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br><span class="line">_________________________________________________________________</span><br></pre></td></tr></table></figure><ol><li><p><strong>输入层（embedding层）</strong>。Embedding层的输入是一个batch的句子，每个句子由一个词汇索引序列构成。Embedding层将每个单词映射成embedding_dim维的向量。于是：input_shape=(batch_size, sent_length), output_shape=(batch_size,sent_length, embedding_dim)；</p></li><li><p><strong>隐含层（投影层）</strong>。投影层对一个文档中所有单词的向量进行叠加平均。这层的input_shape是Embedding层的output_shape，这层的output_shape=( batch_size, embedding_dim)；</p></li><li><p><strong>输出层（softmax层）</strong>。真实的fastText这层是Hierarchical Softmax，因为keras原生并没有支持Hierarchical Softmax，所以这里用Softmax代替。这层指定了class_num，对于一篇文档，输出层会产生class_num个概率值，分别表示此文档属于当前类的可能性。这层的output_shape=(batch_size, class_num)</p></li><li><p><strong>指定损失函数、优化器类型、评价指标，编译模型</strong>。损失函数我们设置为categorical_crossentropy，它就是我们上面所说的softmax回归的损失函数；优化器我们设置为SGD，表示随机梯度下降优化器；评价指标选择accuracy，表示精度。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、fasttext&quot;&gt;&lt;a href=&quot;#1、fasttext&quot; class=&quot;headerlink&quot; title=&quot;1、fasttext&quot;&gt;&lt;/a&gt;1、fasttext&lt;/h3&gt;&lt;p&gt;fasttext是Facebook于2016年开源的一个词向量计算和文本分类工具，在学术上并没有太大创新。它的结构与word2vec中的CBOW类似。与其不同的是在CBOW模型中把每个单词当作一个原子看待没有考虑单词内部的形态特征，例如对于两个很相近的单词book和books，我们会用两个向量表示。而fasttext提出了子词嵌⼊(subword embedding)的⽅法，从而试图将构词信息即内部结构和形成⽅式引⼊word2vec中的CBOW。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nlp" scheme="https://cenkii.github.io/tags/nlp/"/>
    
      <category term="深度学习，机器学习" scheme="https://cenkii.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>词嵌入</title>
    <link href="https://cenkii.github.io/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/"/>
    <id>https://cenkii.github.io/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/</id>
    <published>2020-09-20T02:59:28.000Z</published>
    <updated>2021-05-09T14:46:51.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h2><p>计算机在处理数据时需要先将词用数字向量的形式表示，而把词映射为向量的技术即为词嵌入。</p><h3 id="1、one-hot-编码"><a href="#1、one-hot-编码" class="headerlink" title="1、one hot 编码"></a>1、one hot 编码</h3><p>one hot编码即独热向量编码，他有两个特征：</p><p>1、向量由01组成</p><p>2、向量长度等于字典长度</p><span id="more"></span><p>例如：字典为   {我们，今天，昨天，去，爬山，游泳，又}</p><p>”今天“  对应的向量编码为  [0,1,0,0,0,0,0]</p><p>同理“我们”：[1,0,0,0,0,0,0]</p><p>对于onehot编码有以下缺点：</p><p>1、每个向量长度和字典长度一样，所以随着语料数增多，字典长度增加，会产生一个高维稀疏的矩阵</p><p>2、不能保留词与词之间的关系，例如“苹果”可能有两个意思，但他们的独热码向量是一样的</p><h3 id="2、词袋模型"><a href="#2、词袋模型" class="headerlink" title="2、词袋模型"></a>2、词袋模型</h3><p>将单词编码转换为句子编码，要用到词袋模型(Bag-of-words model)，即一个句子可以看作用一个袋子装着这些词的方式表现，这种表现方式不考虑文法以及词的顺序，有两种方式表示：</p><p>1、Boolean Representation</p><p>即只记录词是否在句子里出现，1为出现0为没出现</p><p>例如：我们/今天/去/游泳/又/去/爬山。</p><p>可表示为[1,1,0,1,1,1,1]</p><p>2、Count-based Representation</p><p>即记录每个词在句子里面出现的次数</p><p>例如：我们/今天/去/游泳/又/去/爬山。</p><p>可表示为[1,1,0,2,1,1,1]</p><p>词袋模型有以下缺点：</p><p>1、词向量化后，词与词之间是有大小关系的，不一定词出现的越多，权重越大。</p><p>2、没有考虑文法以及词的顺序</p><h3 id="3、TF-IDF"><a href="#3、TF-IDF" class="headerlink" title="3、TF-IDF"></a>3、TF-IDF</h3><p><em>TF-IDF</em>（term frequency–inverse document frequency）是一种用于信息检索与数据挖掘的常用加权技术。TF是词频(Term Frequency)，IDF是逆文本频率指数(Inverse Document Frequency)。<br>$$<br>TF = \frac{n}{N}<br>$$</p><blockquote><p>n:词语出现的次数     N:该文件的总词语数</p></blockquote><p>$$<br>IDF = log(\frac{D}{d+1})<br>$$</p><blockquote><p>D:语料为文档总数      d:为包含词语的文档总数（为避免为0所以+1）</p></blockquote><p>$$<br>TF-IDF = TF*IDF<br>$$</p><p>在<em>TF-IDF</em>中字词的重要性随着它某个文档中出现的次数而增加，但随着在语料库中总文件数量的增加而减小。</p><p>但它的缺点还是没有将词语词之间的关系表现出来。</p><h3 id="4、n-gram模型"><a href="#4、n-gram模型" class="headerlink" title="4、n-gram模型"></a>4、n-gram模型</h3><p>n-gram模型中n即为一个窗口，即把n个词作为一组处理，然后向后移动，再取另外一组词，如此，生成字典，编码得到结果。</p><p>例如：我们/今天/去/游泳/又/去/爬山。</p><p>​            我们/今天/去/爬山。</p><p>以2-gram构造字典{“我们 今天”：1，“今天 去”：2，“去 游泳”：3，“游泳 又”：4，“又 去”：5，“去 爬山”：6}</p><p>两句的向量为：</p><p>[1,1,1,1,1,1]</p><p>[1,1,0,0,0,1]</p><p>n-gram模型考虑了词语词之间的顺序，但是随着语料数的增加，词表会越来越大。</p><h3 id="5-分布式表示"><a href="#5-分布式表示" class="headerlink" title="5.分布式表示"></a>5.分布式表示</h3><h4 id="5-1-NNLM"><a href="#5-1-NNLM" class="headerlink" title="5.1 NNLM"></a>5.1 NNLM</h4><p>NNLN即 (Neural Network Language model)，神经网络语言模型。</p><p>来源于  <a href="https://jmlr.org/papers/volume3/bengio03a/bengio03a.pdf">https://jmlr.org/papers/volume3/bengio03a/bengio03a.pdf</a></p><p>它的定义是通过一个前向窗口大小为n，选择n-1个词作为x，第n个词作为label。预测窗口中label的出现概率，最后取中间的词向量矩阵作为词向量。</p><p>例如：我们/今天/去/游泳/又/去/爬山。</p><p>n = 4   x即为（游泳  又  去）   y即为（爬山）</p><p><img src="/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/image-20200920105806829.png" alt="image-20200920105806829"></p><p>上述模型有四层，分别为输入层，投影层，隐藏层，输出层</p><p>输入层：将前n-1个词用onehot编码表示长度|V|</p><p>投影层：假设一个词用D维表示，投影层维度为 |V|×D，通过拼接后输入隐藏层</p><p>隐藏层：激活函数为tanh函数。</p><p>输出层：输出层为词n的概率</p><p>由上图可以看出，<strong>词</strong>是通过一个<strong>look-up表</strong>转化为<strong>词向量</strong>的，我们将这个look-up表称为表C。</p><p>look-up表即为下图</p><p><img src="/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/image-20200920222027446.png" alt="image-20200920222027446"></p><p>C矩阵是投影矩阵，look-up表，也就是稠密词向量表示，在神经网络中是<strong>w参数矩阵</strong>，该矩阵的大小为D<em>V，正好与input层进行全连接(相乘)得到D</em>1的矩阵，采用线性映射将one-hot表示投影到稠密D维表示。</p><p>C矩阵即为我们要求的词向量矩阵。</p><h4 id="5-2-word2vec"><a href="#5-2-word2vec" class="headerlink" title="5.2 word2vec"></a>5.2 word2vec</h4><p>word2vec是2013年提出的一个词嵌入模型。它实际是一种浅层的神经网络模型，有两种形式CBOW和和Skip-gram。</p><h5 id="5-2-1-CBOW"><a href="#5-2-1-CBOW" class="headerlink" title="5.2.1 CBOW"></a>5.2.1 CBOW</h5><p>CBOW通过上下文推理中心词，把中间词当做y，把窗口中的其它词当做x输入，x输入是经过one-hot编码过的，与上面的一样经过look-up表，然后通过一个隐层进行求和操作，最后通过激活函数softmax，可以计算出每个单词的生成概率，接下来的任务就是训练神经网络的权重，使得语料库中所有单词的整体生成概率最大化，而求得的权重矩阵即look-up表就是文本表示词向量的结果。</p><p><img src="/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/v2-d1ca2547dfb91bf6a26c60782a26aa02_r.jpg" alt="v2-d1ca2547dfb91bf6a26c60782a26aa02_r"></p><p>如上图CBOW模型有三层，分别是</p><p>输入层：输入层是一个C×V维的矩阵的one-hot向量，C为词的个数，V为词表的大小</p><p>隐藏层：通过与一个V×N维的W相乘得到一个C×N维的矩阵，通常通过上下文相加或平均将C×N维矩阵转换成1×N的向量。</p><p>输出层：将隐藏成1×N维矩阵，与N×V相乘得到形状1×V的向量。最后通过softmax函数得到中心词概率。</p><p>与上文一样训练出来取中间产物W作为词向量。</p><h5 id="5-2-2-Skip-gram"><a href="#5-2-2-Skip-gram" class="headerlink" title="5.2.2 Skip-gram"></a>5.2.2 Skip-gram</h5><p>与CBOW相反，Skip-gram是根据中心词推理上下文。把中间词当做x，把窗口中的其它词当做y，x输入是经过one-hot编码过的，与上面的一样经过look-up表，然后通过一个隐层进行求和操作，最后通过激活函数softmax，可以计算出每个单词的生成概率，接下来的任务就是训练神经网络的权重，使得语料库中所有单词的整体生成概率最大化，而求得的权重矩阵即look-up表就是文本表示词向量的结果。</p><p><img src="/2020/09/20/%E8%AF%8D%E5%B5%8C%E5%85%A5/v2-ca81e19caa378cee6d4ba6d867f4fc7c_r.png" alt="v2-ca81e19caa378cee6d4ba6d867f4fc7c_r"></p><p>如上图CBOW模型有三层，分别是</p><p>输入层：输入层是一个1×V维的one-hot向量，V为词表的大小</p><p>隐藏层：通过与一个V×N维的W相乘得到一个C×N维的矩阵，通常通过上下文相加或平均将C×N维矩阵转换成1×N的向量。</p><p>输出层：将隐藏成1×N维矩阵，与N×V相乘得到形状1×V的向量。最后通过softmax函数得到中心词预测上下文结果。</p><h4 id="5-2-3-弊端"><a href="#5-2-3-弊端" class="headerlink" title="5.2.3 弊端"></a>5.2.3 弊端</h4><p>1、词向量是基于局部信息训练的，不包含全局信息</p><p>2、每个词向量表示一个词，对于一词多义的词无法表示</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;词嵌入&quot;&gt;&lt;a href=&quot;#词嵌入&quot; class=&quot;headerlink&quot; title=&quot;词嵌入&quot;&gt;&lt;/a&gt;词嵌入&lt;/h2&gt;&lt;p&gt;计算机在处理数据时需要先将词用数字向量的形式表示，而把词映射为向量的技术即为词嵌入。&lt;/p&gt;
&lt;h3 id=&quot;1、one-hot-编码&quot;&gt;&lt;a href=&quot;#1、one-hot-编码&quot; class=&quot;headerlink&quot; title=&quot;1、one hot 编码&quot;&gt;&lt;/a&gt;1、one hot 编码&lt;/h3&gt;&lt;p&gt;one hot编码即独热向量编码，他有两个特征：&lt;/p&gt;
&lt;p&gt;1、向量由01组成&lt;/p&gt;
&lt;p&gt;2、向量长度等于字典长度&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nlp" scheme="https://cenkii.github.io/tags/nlp/"/>
    
      <category term="深度学习" scheme="https://cenkii.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>DBSCAN</title>
    <link href="https://cenkii.github.io/2020/05/29/DBSCAN/"/>
    <id>https://cenkii.github.io/2020/05/29/DBSCAN/</id>
    <published>2020-05-29T13:57:56.000Z</published>
    <updated>2020-06-08T10:25:28.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>dbscan是密度聚类的经典算法，此类算法假设聚类结构能够通过样本分布的密度紧密程度确定。它是基于一组邻域ε和其中的样本数MinPts来刻画样本分布的紧密程度。</p><p>下面先来了解几个概念：</p><span id="more"></span><p>例如，给定数据集D={x1,x2,…,xm}</p><p>ε-邻域：对于xj∈D，其邻域包含样本集D中距离与xj的距离不大于ε的样本即$N_ε = {x_i∈D|dist(x_i,x_j)≤ε}$</p><p>核心对象：若xj的邻域中包含最少MinPts个点则xj即为核心对象</p><p>密度直达：若xi在xj的邻域中则xi可由xj密度直达</p><p>密度可达：若存在x1,x2,x3, x1到x2密度直达，x2到x3密度直达，则x1到x3密度可达</p><p>密度相连：若有x1,x2,x3,x4,x5，若x3到x1密度可达，x3到x5密度可达，则x1和x5密度相连</p><p><img src="/2020/05/29/DBSCAN/image-20200529222607736.png" alt="image-20200529222607736"></p><h3 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2.算法步骤"></a>2.算法步骤</h3><p>1.将所有点标记为核心点、边界点或噪声点；<br>2.删除噪声点；<br>3.为距离在Eps之内的所有核心点之间赋予一条边；<br>4.每组连通的核心点形成一个簇；<br>5.将每个边界点指派到一个与之关联的核心点的簇中（哪一个核心点的半径范围之内）。</p><h3 id="3-算法实现（sklearn）"><a href="#3-算法实现（sklearn）" class="headerlink" title="3.算法实现（sklearn）"></a>3.算法实现（sklearn）</h3><p>用上一篇文章的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data_1 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">data_2 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">data_3 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">data = np.concatenate((data_1, data_2, data_3), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X_train, X_test = train_test_split(data, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> dbscan</span><br><span class="line">core,label = dbscan(X_train,min_samples=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], alpha=<span class="number">0.5</span>, c=label)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h3><p>下图为实验结果数据集与k-means中相同，下图中紫色的点为噪声点。可以看到将数据集划分成了两个簇，而在k-means中分成了3个簇，可见与k-means相比这个数据集中算法表现不算太好。</p><p><img src="/2020/05/29/DBSCAN/image-20200529223126811.png" alt="image-20200529223126811"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DBSCAN&quot;&gt;&lt;a href=&quot;#DBSCAN&quot; class=&quot;headerlink&quot; title=&quot;DBSCAN&quot;&gt;&lt;/a&gt;DBSCAN&lt;/h2&gt;&lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h3&gt;&lt;p&gt;dbscan是密度聚类的经典算法，此类算法假设聚类结构能够通过样本分布的密度紧密程度确定。它是基于一组邻域ε和其中的样本数MinPts来刻画样本分布的紧密程度。&lt;/p&gt;
&lt;p&gt;下面先来了解几个概念：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>影响力最大化——线性阈值</title>
    <link href="https://cenkii.github.io/2020/05/26/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E9%98%88%E5%80%BC/"/>
    <id>https://cenkii.github.io/2020/05/26/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E9%98%88%E5%80%BC/</id>
    <published>2020-05-26T14:27:08.000Z</published>
    <updated>2020-05-27T14:28:16.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性阈值模型"><a href="#线性阈值模型" class="headerlink" title="线性阈值模型"></a>线性阈值模型</h2><p>前面已经介绍过独立级联模型+贪心下面就用线性阈值模型和贪心算法来实现影响力最大化。</p><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h3><p>数据还是用前面的数据karate具体见上一篇</p><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_threshold</span>(<span class="params">G,seed,mc=<span class="number">1000</span></span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#转换为有向图</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> G.is_directed():</span><br><span class="line">        G = G.to_directed()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置边权重 </span></span><br><span class="line">    a,b = <span class="built_in">zip</span>(*G.edges())</span><br><span class="line">    c = []</span><br><span class="line">    </span><br><span class="line">    ind = G.in_degree()</span><br><span class="line">    ind = <span class="built_in">dict</span>(ind)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">        c.append(<span class="number">1.0</span>/ind[i])</span><br><span class="line"></span><br><span class="line">    weight = <span class="built_in">zip</span>(a,b,c)</span><br><span class="line">    G.add_weighted_edges_from(weight)</span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># 循环mc次得到平均结果</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(mc):</span><br><span class="line">        <span class="comment"># 初始化阈值与被影响力</span></span><br><span class="line">        np.random.seed(j)</span><br><span class="line">        p = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>,G.number_of_nodes()+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> G.nodes:</span><br><span class="line">            G.nodes[i][<span class="string">&#x27;threshold&#x27;</span>] = p[i]</span><br><span class="line">            G.nodes[i][<span class="string">&#x27;influence&#x27;</span>] = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        activate_node = seed.copy()</span><br><span class="line">        new_active = seed.copy()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> new_active:</span><br><span class="line">            new_ones = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> G.neighbors(node):</span><br><span class="line">                G.nodes[i][<span class="string">&#x27;influence&#x27;</span>] += G.get_edge_data(node,i)[<span class="string">&#x27;weight&#x27;</span>]</span><br><span class="line">                <span class="keyword">if</span> (G.nodes[i][<span class="string">&#x27;influence&#x27;</span>] &gt; G.nodes[i][<span class="string">&#x27;threshold&#x27;</span>]) <span class="keyword">and</span> (i <span class="keyword">not</span> <span class="keyword">in</span> activate_node):</span><br><span class="line">                    new_ones.append(i)</span><br><span class="line">            new_active += new_ones</span><br><span class="line">            activate_node += new_ones</span><br><span class="line">        </span><br><span class="line">        result.append(<span class="built_in">len</span>(activate_node))</span><br><span class="line">    <span class="keyword">return</span> np.mean(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span>(<span class="params">g,k,p=<span class="number">0.1</span>,mc=<span class="number">1000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:  graph object, number of seed nodes</span></span><br><span class="line"><span class="string">    Output: optimal seed set, resulting spread, time for each iteration</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    S, spread, timelapse, start_time = [], [], [], time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Find k nodes with largest marginal gain</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Loop over nodes that are not yet in seed set to find biggest marginal gain</span></span><br><span class="line">        best_spread = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>,g.number_of_nodes()+<span class="number">1</span>))-<span class="built_in">set</span>(S):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Get the spread</span></span><br><span class="line">            s = linear_threshold(g,S + [j],mc)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Update the winning node and spread so far</span></span><br><span class="line">            <span class="keyword">if</span> s &gt; best_spread:</span><br><span class="line">                best_spread, node = s, j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add the selected node to the seed set</span></span><br><span class="line">        S.append(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Add estimated spread and elapsed time</span></span><br><span class="line">        spread.append(best_spread)</span><br><span class="line">        timelapse.append(time.time() - start_time)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(S,spread,timelapse)</span><br><span class="line"></span><br><span class="line">G = nx.read_gml(<span class="string">&quot;karate.gml&quot;</span>)</span><br><span class="line">greedy(G,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([34, 1], [13.232, 22.98], [8.593012809753418, 27.11247444152832])</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以看到两个模型的结果是完全一样的但时间缺差了许多</p><h3 id="影响力最大化系列"><a href="#影响力最大化系列" class="headerlink" title="影响力最大化系列"></a>影响力最大化系列</h3><p><a href="https://cenkii.github.io/2020/04/18/影响力最大化一/">影响力最大化——影响力测度</a></p><p><a href="https://cenkii.github.io/2020/04/29/IM2/">影响力最大化——节点影响力评估</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性阈值模型&quot;&gt;&lt;a href=&quot;#线性阈值模型&quot; class=&quot;headerlink&quot; title=&quot;线性阈值模型&quot;&gt;&lt;/a&gt;线性阈值模型&lt;/h2&gt;&lt;p&gt;前面已经介绍过独立级联模型+贪心下面就用线性阈值模型和贪心算法来实现影响力最大化。&lt;/p&gt;
&lt;h3 id=&quot;1-数据&quot;&gt;&lt;a href=&quot;#1-数据&quot; class=&quot;headerlink&quot; title=&quot;1.数据&quot;&gt;&lt;/a&gt;1.数据&lt;/h3&gt;&lt;p&gt;数据还是用前面的数据karate具体见上一篇&lt;/p&gt;
&lt;h3 id=&quot;2-代码实现&quot;&gt;&lt;a href=&quot;#2-代码实现&quot; class=&quot;headerlink&quot; title=&quot;2.代码实现&quot;&gt;&lt;/a&gt;2.代码实现&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="影响力最大化" scheme="https://cenkii.github.io/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>K-Means</title>
    <link href="https://cenkii.github.io/2020/05/23/K-Means/"/>
    <id>https://cenkii.github.io/2020/05/23/K-Means/</id>
    <published>2020-05-23T13:40:35.000Z</published>
    <updated>2020-05-29T14:35:56.030Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>k-means也是一种常用的机器学习，它的作用同样是分类，但与决策树，svm，knn等分类不同，k-means是一种无标签分类算法，称之为无监督分类，也叫聚类。</p><span id="more"></span><h3 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h3><p>K-Means算法是以距离作为相似度的评价指标，用样本点到类别中心的误差平方和作为聚类好坏的评价指标。总体误差即<br>$$<br>E = \sum_{i=1}^{k}\sum_{x∈C_i}||x-θ_i||<br>$$<br>其中 </p><p>$C_i$为簇，x为簇中的点</p><p>k为簇的个数</p><p>$θ_i$  为簇的中心点</p><p><img src="/2020/05/23/K-Means/image-20200529215901516.png" alt="image-20200529215901516"></p><p>通过迭代的方法使总体分类的误差平方和函数达到最小的聚类方法。</p><p>具体流程为：</p><blockquote><p>1、从集合(x1, x2, …, xn)中随机取k个元素，作为k个类别的各自的中心。</p><p>2、聚类。分别计算集合中每一个元素到k个类别中心的距离，将这些元素分别划归到距离最小的那一个类别中去，这个过程其实是一个重新聚类的过程。</p><p>3、更新类别中心。根据前面聚类的结果，重新计算每一个类别的中心，计算方法是取当前类别中所有元素，然后计算这些元素在每一个维度的平均值。每一个类别中心都重新计算一遍后，就得到了一个新的类别中心组 。</p><p>4、重复第2，3步，直到聚类结果不再发生变化，这样得到的类别中心，基本上就是我们最后想要找的类别中心。</p></blockquote><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>k-means算法比较简单，但这个算法存在着问题，如下图</p><p><img src="/2020/05/23/K-Means/7312709-e975851b71638ab0.png" alt="img"></p><p>因为定义的初始节点是随机选择，所以很可能出现上面的情况。</p><p>解决方法</p><p>1.多计算几次取平均值</p><p>2.还有一种改进算法k-means++是更改中心点的选取，改进后方法如下：</p><pre><code>1. 随机选取中心点   2. 计算剩余所有点与中心点的距离，选择距离最短的</code></pre><p>$$<br>D(x^{(i)})=min[dist(x^{(i)},C_{1}),dist(x^{(i)},C_{2}),…,dist(x^{(i)},C_{n})]<br>$$</p><p>   可计算每个点被选的概率为<br>$$<br>\frac{D(x^{(i)})^{2}}{\sum{D(x^{(j)})^{2}}}<br>$$<br>​    3.重复计算直到算出k个点</p><p>通过上面的步骤可以看出通过对更改中心点的选取算法，可以看出距离中心点最近的点被选的概率越低。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data_1 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">data_2 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">data_3 = np.random.randn(<span class="number">200</span>, <span class="number">2</span>)+[<span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">data = np.concatenate((data_1, data_2, data_3), axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">X_train, X_test = train_test_split(data, test_size=<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> k_means</span><br><span class="line"><span class="comment">#使用sklearn中的k_means进行聚类</span></span><br><span class="line"><span class="comment">#返回值为 簇中心值集 所属簇label 训练集中所有观测值的最接近的质心</span></span><br><span class="line"><span class="comment">#k_means中使用的算法是改进的k-means++</span></span><br><span class="line">cent_cur,label,inertia = k_means(X_train,n_clusters=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化</span></span><br><span class="line">plt.clf()</span><br><span class="line">plt.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], alpha=<span class="number">0.5</span>, c=label)</span><br><span class="line">plt.scatter(cent_cur[:, <span class="number">0</span>], cent_cur[:, <span class="number">1</span>], marker=<span class="string">&#x27;*&#x27;</span>, c=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2020/05/23/K-Means/img.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h3&gt;&lt;p&gt;k-means也是一种常用的机器学习，它的作用同样是分类，但与决策树，svm，knn等分类不同，k-means是一种无标签分类算法，称之为无监督分类，也叫聚类。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="机器学习" scheme="https://cenkii.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据挖掘" scheme="https://cenkii.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>影响力最大化三——独立级联模型</title>
    <link href="https://cenkii.github.io/2020/05/11/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%89%E2%80%94%E2%80%94%E7%8B%AC%E7%AB%8B%E7%BA%A7%E8%81%94%E6%A8%A1%E5%9E%8B/"/>
    <id>https://cenkii.github.io/2020/05/11/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%89%E2%80%94%E2%80%94%E7%8B%AC%E7%AB%8B%E7%BA%A7%E8%81%94%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-05-11T13:44:00.000Z</published>
    <updated>2020-05-26T14:37:19.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="独立级联模型"><a href="#独立级联模型" class="headerlink" title="独立级联模型"></a>独立级联模型</h2><p>前面已经介绍过独立级联模型下面就用独立级联模型和贪心算法来实现影响力最大化。</p><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h3><p>数据主要使用karate.gml图中有34个点78条边</p><p>具体图形是酱婶的</p><span id="more"></span><p><img src="/2020/05/11/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%89%E2%80%94%E2%80%94%E7%8B%AC%E7%AB%8B%E7%BA%A7%E8%81%94%E6%A8%A1%E5%9E%8B/image-20200526215631109.png" alt="影响力最大化三图一"></p><h3 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2.贪心算法"></a>2.贪心算法</h3><ol><li>首先将遍历所有点找出最大影响力的点 加入S</li><li>如果只找一个点就可以结束了</li><li>否则，在剩下的点集中再找一个点并入S使影响力最大</li><li>重复直至点数满足需求</li></ol><h3 id="3-运行环境"><a href="#3-运行环境" class="headerlink" title="3.运行环境"></a>3.运行环境</h3><p>python 3.7</p><p>networkx 2.1</p><h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IC</span>(<span class="params">G, seeds, p=<span class="number">0.5</span>, epoch=<span class="number">1000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    input：</span></span><br><span class="line"><span class="string">    G：图</span></span><br><span class="line"><span class="string">    seeds：初始节点</span></span><br><span class="line"><span class="string">    p: 激活概率</span></span><br><span class="line"><span class="string">    epoch：循环圈数</span></span><br><span class="line"><span class="string">    return</span></span><br><span class="line"><span class="string">    output：影响力大小</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">        activate_node = seeds.copy()</span><br><span class="line">        new_active = seeds.copy()</span><br><span class="line">        <span class="keyword">while</span> new_active:</span><br><span class="line">            new_ones = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> new_active:</span><br><span class="line">                np.random.seed(i)       </span><br><span class="line">                l = <span class="built_in">list</span>(G.neighbors(node))</span><br><span class="line">                success = np.random.uniform(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(l)) &lt; p                </span><br><span class="line">                new_ones += <span class="built_in">list</span>(np.extract(success, l))</span><br><span class="line">            new_active = <span class="built_in">list</span>(<span class="built_in">set</span>(new_ones) - <span class="built_in">set</span>(activate_node))</span><br><span class="line">            activate_node += new_active</span><br><span class="line">        result.append(<span class="built_in">len</span>(activate_node))</span><br><span class="line">    <span class="keyword">return</span> np.mean(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greedy</span>(<span class="params">g,k,p=<span class="number">0.1</span>,mc=<span class="number">1000</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:  graph object, number of seed nodes</span></span><br><span class="line"><span class="string">    Output: optimal seed set, resulting spread, time for each iteration</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    S, spread, timelapse, start_time = [], [], [], time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找k个点</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line"></span><br><span class="line">        best_spread = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>,g.number_of_nodes()+<span class="number">1</span>))-<span class="built_in">set</span>(S):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取影响力</span></span><br><span class="line">            s = IC(g,S + [j],p,mc)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 验证是否更好</span></span><br><span class="line">            <span class="keyword">if</span> s &gt; best_spread:</span><br><span class="line">                best_spread, node = s, j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将最大点加入S</span></span><br><span class="line">        S.append(node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把影响力加入spread</span></span><br><span class="line">        spread.append(best_spread)</span><br><span class="line">        timelapse.append(time.time() - start_time)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(S,spread,timelapse)</span><br><span class="line"></span><br><span class="line">G = nx.read_gml(<span class="string">&quot;karate.gml&quot;</span>)</span><br><span class="line">greedy(G,<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-结果"><a href="#5-结果" class="headerlink" title="5.结果"></a>5.结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([34, 1], [4.2, 6.501], [2.748678207397461, 8.546141624450684])</span><br></pre></td></tr></table></figure><p>找到的两个点是34和1，影响力分别为4.2,和6.501，找第一个点耗费2.748678207397461第二个点耗费8.546141624450684秒</p><h3 id="影响力最大化系列"><a href="#影响力最大化系列" class="headerlink" title="影响力最大化系列"></a>影响力最大化系列</h3><p><a href="https://cenkii.github.io/2020/04/18/影响力最大化一/">影响力最大化——影响力测度</a></p><p><a href="https://cenkii.github.io/2020/04/29/IM2/">影响力最大化——节点影响力评估</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;独立级联模型&quot;&gt;&lt;a href=&quot;#独立级联模型&quot; class=&quot;headerlink&quot; title=&quot;独立级联模型&quot;&gt;&lt;/a&gt;独立级联模型&lt;/h2&gt;&lt;p&gt;前面已经介绍过独立级联模型下面就用独立级联模型和贪心算法来实现影响力最大化。&lt;/p&gt;
&lt;h3 id=&quot;1-数据&quot;&gt;&lt;a href=&quot;#1-数据&quot; class=&quot;headerlink&quot; title=&quot;1.数据&quot;&gt;&lt;/a&gt;1.数据&lt;/h3&gt;&lt;p&gt;数据主要使用karate.gml图中有34个点78条边&lt;/p&gt;
&lt;p&gt;具体图形是酱婶的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="影响力最大化" scheme="https://cenkii.github.io/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>IM2</title>
    <link href="https://cenkii.github.io/2020/04/29/IM2/"/>
    <id>https://cenkii.github.io/2020/04/29/IM2/</id>
    <published>2020-04-29T07:56:33.000Z</published>
    <updated>2020-05-26T14:24:16.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响力最大化——节点影响力评估"><a href="#影响力最大化——节点影响力评估" class="headerlink" title="影响力最大化——节点影响力评估"></a>影响力最大化——节点影响力评估</h2><p>当完成影响力节点的测度之后，接下来就需要对测度的节点进行评估，从而比较测度的方法的优劣。一般使用以下两种方式进行评估</p><h3 id="传播模型"><a href="#传播模型" class="headerlink" title="传播模型"></a>传播模型</h3><h4 id="1-传统传播模型"><a href="#1-传统传播模型" class="headerlink" title="1.传统传播模型"></a>1.传统传播模型</h4><p>由于信息是通过社会网络用户之间的交互传播的，这与传染病通过人与人接触传播的机制相似，所以传染病模型也可用来对信息传播过程（或者称影响力传播过程）建模。目前应用较广泛的传染病模型有：SI模型（Susceptible-Infected Model)、SIR模型（Susceptible-Infected-Recovered Model)、SIS 模型（Susceptible-Infected-Susceptible Model)。</p><span id="more"></span><p>（1)SI模型<br>SI模型刻画了最简单的情形。SI模型中有两种状态：易感状态S(Susceptible)和感染状态I(Infected)。初始时处于I状态的人以概率β，感染S的人，然后会成为I，去感染为S的人。</p><p>（2)SIR模型</p><p>SIR模型中会多一个R（Recovered）状态——恢复状态。在状态I以β概率感染S状态时，同时会以γ概率恢复为R状态，R状态不会继续去感染人，也不会被人感染。</p><p>（3)SIS模型</p><p>SIS模型中，处于恢复状态的人会再次被感染，也就是说当治愈后处于I状态的人会恢复为S状态。</p><h4 id="2-独立级联模型"><a href="#2-独立级联模型" class="headerlink" title="2.独立级联模型"></a>2.独立级联模型</h4><p>简称ICM，在该模型中，用户接受了解某信息后会将信息传播出去，则此节点处于激活态（active）。反之处于未激活态（inactive）。传播流程如下：</p><blockquote><ol><li>初始时（t=0），只有少量处于激活态，即为种子节点。</li><li>对t&gt;=1时刻，任意在t-1时刻被激活的节点<strong>有且仅有一次</strong>机会尝试以概率p激活所有未激活态邻居。</li><li>当多个节点同时激活一个未激活邻居时，这些节点激活顺序是随机的。</li><li>重复上述过程，直到不再有新增节点。</li></ol></blockquote><h4 id="3-线性阈值模型"><a href="#3-线性阈值模型" class="headerlink" title="3.线性阈值模型"></a>3.线性阈值模型</h4><p>与上述模型一样，节点也有激活态（active）和未激活态两种状态（inactive）。与ICM不同的是，在此模型中每个节点都要设置一个阈值0&lt;θ&lt;=1。网络中连接任意两个节点u,v之间的边都有权重，任意一个节点它的各个邻居节点的边的权重之和为1。每个已激活节点可以多次尝试激活，当权重之和达到阈值时，激活节点。</p><p>传播流程如下：</p><blockquote><ol><li>初始时（t=0），只有少量处于激活态，即为种子节点。</li><li>未激活节点会受激活节点影响</li><li>当未激活节点达到阈值时，激活节点，反之保持原态</li><li>重复上述过程，直到无新节点产生</li></ol></blockquote><h3 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h3><p>就网络攻击而言，就是看复杂网络中部分节点在经受网络攻击后，其网络的连通性以及信息的传输效率是否受到影响，网络的结构和功能被影响的越严重，表明受到攻击的网络节点也就越重要。网络攻击的方式一般分为随机攻击和蓄意攻击两类。其中，蓄意攻击的目标可以根据不同的节点影响力测度方法选出，通过评比不同方法选取的最大影响力节点在经过攻击后的网络脆弱性和稳定性，以此评选出较优的测度方法。此外，不同网络结构对于不 同的攻击具有不同的抗毁性和鲁棒性，如无标度网络对于随机攻击具有较高的鲁棒性，而对蓄意攻击则显得异常脆弱。</p><h3 id="影响力最大化系列"><a href="#影响力最大化系列" class="headerlink" title="影响力最大化系列"></a>影响力最大化系列</h3><p><a href="https://cenkii.github.io/2020/04/18/影响力最大化一/">影响力最大化——影响力测度</a></p><p><a href="https://cenkii.github.io/2020/04/29/IM2/">影响力最大化——节点影响力评估</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;影响力最大化——节点影响力评估&quot;&gt;&lt;a href=&quot;#影响力最大化——节点影响力评估&quot; class=&quot;headerlink&quot; title=&quot;影响力最大化——节点影响力评估&quot;&gt;&lt;/a&gt;影响力最大化——节点影响力评估&lt;/h2&gt;&lt;p&gt;当完成影响力节点的测度之后，接下来就需要对测度的节点进行评估，从而比较测度的方法的优劣。一般使用以下两种方式进行评估&lt;/p&gt;
&lt;h3 id=&quot;传播模型&quot;&gt;&lt;a href=&quot;#传播模型&quot; class=&quot;headerlink&quot; title=&quot;传播模型&quot;&gt;&lt;/a&gt;传播模型&lt;/h3&gt;&lt;h4 id=&quot;1-传统传播模型&quot;&gt;&lt;a href=&quot;#1-传统传播模型&quot; class=&quot;headerlink&quot; title=&quot;1.传统传播模型&quot;&gt;&lt;/a&gt;1.传统传播模型&lt;/h4&gt;&lt;p&gt;由于信息是通过社会网络用户之间的交互传播的，这与传染病通过人与人接触传播的机制相似，所以传染病模型也可用来对信息传播过程（或者称影响力传播过程）建模。目前应用较广泛的传染病模型有：SI模型（Susceptible-Infected Model)、SIR模型（Susceptible-Infected-Recovered Model)、SIS 模型（Susceptible-Infected-Susceptible Model)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="影响力最大化" scheme="https://cenkii.github.io/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>影响力最大化一</title>
    <link href="https://cenkii.github.io/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/"/>
    <id>https://cenkii.github.io/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/</id>
    <published>2020-04-18T12:37:35.000Z</published>
    <updated>2020-05-26T14:24:47.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响力最大化——影响力测度"><a href="#影响力最大化——影响力测度" class="headerlink" title="影响力最大化——影响力测度"></a>影响力最大化——影响力测度</h2><p>对节点重要程度的定义和排序，通过从不同视角、 维度和约束条件下构建起节点影响力指标，并试图以最精准和快速的方式找到最有影响力的节点。</p><span id="more"></span><p><img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E8%A1%A8%E4%B8%80" alt="image-20200425154915814"></p><h3 id="单指标分析"><a href="#单指标分析" class="headerlink" title="单指标分析"></a>单指标分析</h3><ol><li><p>局部信息</p><blockquote><ol><li><p>邻居数量：节点v邻居的数量</p></li><li><p>邻居间连接拓扑信息：</p></li><li><p>三角结构数量（聚集系数）：</p></li></ol><p>​        在有向图中定义如下： $C = \frac{n}{k(k-1)}$ n表示在节点v的所有k个邻居间的边数</p><p>​        无向图：$C = \frac{2*n}{k(k-1)}$ </p><ol start="4"><li>结构洞：</li></ol><p>所谓“结构洞”就是指社会网络中的空隙，即社会网络中某个或某些个体和有些个体发生直接联系，但与其他个体不发生直接联系，即无直接关系或关系间断，从整体看好像网络结构中出现了洞穴。如果两者之间缺少直接的联系，而必须通过第三者才能形成联系，那么第三者就在关系网络中占据了一个结构洞，通常占据结构洞越多则此人的优势越大。</p><p>如下图：A即结构洞，起到桥梁作用</p><p><img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E5%9B%BE%E4%B8%80" alt="image-20200426170735173"></p><p>​    对于结构洞可以用网络约束系数来测量。该系数越高（接近1），结构洞越少，网络闭合性越高。</p><p>​    计算方式如下（注下图网络约束系数扩大了100倍）：</p><p>​    <img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E7%B3%BB%E6%95%B0" alt="image-20200426185352299"></p><p><a href="https://faculty.chicagobooth.edu/ronald.burt/research/files/NNappB.pdf">了解更多</a>[5]</p><ol start="5"><li>社区中心性</li></ol><p>即度中心性其定义是，某个结点相连的链接数量，若节点的连接数量越多，则中心性越大。</p></blockquote><p>2.全局信息</p><blockquote><ol><li>接近中心性</li></ol><p>接近中心性主要用于计算每个顶点到其他所有顶点的最短距离之和。然后将得到的和反过来确定该节点的接近中心性得分。<br>$$<br>C = \frac{1}{\sum_{n=1}^{N}distance^n}<br>$$<br>当C越大的时候，该点在网络中影响越大，因为到其它节点的平均最短距离最小，意味着这个节点从几何角度看是处于图的中心位置。</p><ol start="2"><li>介数中心性</li></ol><p>中介中心性的定义是，该结点作为其他两个结点的最短路上的桥梁的次数。也就是说，如果一个顶点出现在任意两个顶点间最短路径的次数越多，那么该顶点的中介中心性就越大。</p><p>算法第一步为寻找最短路径（通常为广度优先搜索），之后统计所有最短路径中，每个中间顶点出现的次数。</p><ol start="3"><li>流介数中心性</li></ol><p>节点的流介数中心性定义为网络中所有路径数与经过该节点路径数的比值。</p><ol start="4"><li>特征向量中心性</li></ol><p>特征向量中心性的基本思想是，一个节点的中心性是相邻节点中心性的函数。也就是说，与你连接的人越重要，你也就越重要。</p><p>特征向量中心性和点度中心性不同，一个点度中心性高即拥有很多连接的节点特征向量中心性不一定高，因为所有的连接者有可能特征向量中心性很低。同理，特征向量中心性高并不意味着它的点度中心性高，它拥有很少但很重要的连接者也可以拥有高特征向量中心性。</p><p>首先，计算的是每个点的点度中心性（degree centrality），即以点的连接数来衡量中心性的高低。</p><p>结果向量的第一个元素是用矩阵A的第一行去“获取”每一个与第一个点有连接的点的值（连接数，点度中心性），也就是第2个、第3个和第4个点的值，然后将它们加起来。</p><p>换句话说，邻接矩阵做的事情是将相邻节点的求和值重新分配给每个点。这样做的结果就是“扩散了”点度中心性。你的朋友的朋友越多，你的特征向量中心性就越高。</p><p>然后采用 $x(t)=cAx(t-1)$ 迭代，达到稳态时，x即为特征向量</p><ol start="5"><li>k-shell分解法</li></ol><p>K-shell分解方法给出了节点重要性的一种粗粒化的划分。其基本思想如下, 假设边缘节点的K-shell值为1, 然后往内一层层进入网络的核心, 先去除网络中度值等于1的所有节点以及连边。若剩下的节点里面, 仍有度值等于1的节点, 则重复上述操作, 即去除这些节点和连边, 直至所有节点的度值都大于1, 把这些去除的节点的K-shell值记为1, 也就是说这些节点均处于ks值为1的层。然后依次去除度值小于或等于k的节点及连边 (k为整数, k≥2) , 直到所有的节点都有对应的ks值为止。</p></blockquote></li></ol><h3 id="多指标分析"><a href="#多指标分析" class="headerlink" title="多指标分析"></a>多指标分析</h3><ol><li><p>3指标法</p><p>分别计算每个结点的 度、介数以及kcore，然后采用欧式距离公式得出综合指标[2]</p></li><li><p>4指标法</p><p>使用degree度中心性，接近中心性，介数中心性和kshell计算四指标，然后通过topsis计算排序[3]</p></li><li><p>7指标法</p><p>通过ListNet排序学习对网络中单个节点的 网络约束系数，网络有效规模、效率、等级度、阶数中心性，PageRank值和聚类系数7个度量指标进行融合，综合评价复杂网络中面向结构洞的节点重要性，从而对网络中关键节点进行排序。[1]</p></li><li><p>内部属性+外部属性</p><p>其公式为：</p><p><img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E5%85%AC%E5%BC%8F" alt="image-20200429135331396"></p><blockquote><p>其中</p><p>$f_{internal}(v_0)=\frac{K(v_0)}{max(K(v))}$   </p><p>K为内部属性 例如度介数紧密度等</p><p><img src="/2020/04/18/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80/%E5%A4%96%E9%83%A8" alt="image-20200429135948373"></p><p>d(vo,c) 为节点 vo 在社区 c 中的邻居节点的总个数</p><p>|c|为社区大小</p><p>分母为归一化因子</p></blockquote></li></ol><p>参考文献</p><p>[1] 面向结构洞的复杂网络关键节点排序_韩忠明</p><p>[2] <em>Identifying all-around nodes for</em> <em>spreading dynamics in complex networks</em></p><p>[3] The node importance in actual complex networks based on a multi-attribute ranking method</p><p>[4] 复杂网络节点影响力测度及其最大化研究综述_张应青</p><p>[5] <a href="https://faculty.chicagobooth.edu/ronald.burt/research/files/NNappB.pdf">https://faculty.chicagobooth.edu/ronald.burt/research/files/NNappB.pdf</a></p><p>[6] 一种新的网络传播中最有影响力的节点发现方法</p><h3 id="影响力最大化系列"><a href="#影响力最大化系列" class="headerlink" title="影响力最大化系列"></a>影响力最大化系列</h3><p><a href="https://cenkii.github.io/2020/04/18/影响力最大化一/">影响力最大化——影响力测度</a></p><p><a href="https://cenkii.github.io/2020/04/29/IM2/">影响力最大化——节点影响力评估</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;影响力最大化——影响力测度&quot;&gt;&lt;a href=&quot;#影响力最大化——影响力测度&quot; class=&quot;headerlink&quot; title=&quot;影响力最大化——影响力测度&quot;&gt;&lt;/a&gt;影响力最大化——影响力测度&lt;/h2&gt;&lt;p&gt;对节点重要程度的定义和排序，通过从不同视角、 维度和约束条件下构建起节点影响力指标，并试图以最精准和快速的方式找到最有影响力的节点。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="影响力最大化" scheme="https://cenkii.github.io/tags/%E5%BD%B1%E5%93%8D%E5%8A%9B%E6%9C%80%E5%A4%A7%E5%8C%96/"/>
    
  </entry>
  
</feed>
